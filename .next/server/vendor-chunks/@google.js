"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@google";
exports.ids = ["vendor-chunks/@google"];
exports.modules = {

/***/ "(rsc)/./node_modules/@google/genai/dist/node/index.mjs":
/*!********************************************************!*\
  !*** ./node_modules/@google/genai/dist/node/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActivityHandling: () => (/* binding */ ActivityHandling),\n/* harmony export */   AdapterSize: () => (/* binding */ AdapterSize),\n/* harmony export */   ApiError: () => (/* binding */ ApiError),\n/* harmony export */   ApiSpec: () => (/* binding */ ApiSpec),\n/* harmony export */   AuthType: () => (/* binding */ AuthType),\n/* harmony export */   Batches: () => (/* binding */ Batches),\n/* harmony export */   Behavior: () => (/* binding */ Behavior),\n/* harmony export */   BlockedReason: () => (/* binding */ BlockedReason),\n/* harmony export */   Caches: () => (/* binding */ Caches),\n/* harmony export */   Chat: () => (/* binding */ Chat),\n/* harmony export */   Chats: () => (/* binding */ Chats),\n/* harmony export */   ComputeTokensResponse: () => (/* binding */ ComputeTokensResponse),\n/* harmony export */   ContentReferenceImage: () => (/* binding */ ContentReferenceImage),\n/* harmony export */   ControlReferenceImage: () => (/* binding */ ControlReferenceImage),\n/* harmony export */   ControlReferenceType: () => (/* binding */ ControlReferenceType),\n/* harmony export */   CountTokensResponse: () => (/* binding */ CountTokensResponse),\n/* harmony export */   CreateFileResponse: () => (/* binding */ CreateFileResponse),\n/* harmony export */   DeleteCachedContentResponse: () => (/* binding */ DeleteCachedContentResponse),\n/* harmony export */   DeleteFileResponse: () => (/* binding */ DeleteFileResponse),\n/* harmony export */   DeleteModelResponse: () => (/* binding */ DeleteModelResponse),\n/* harmony export */   DynamicRetrievalConfigMode: () => (/* binding */ DynamicRetrievalConfigMode),\n/* harmony export */   EditImageResponse: () => (/* binding */ EditImageResponse),\n/* harmony export */   EditMode: () => (/* binding */ EditMode),\n/* harmony export */   EmbedContentResponse: () => (/* binding */ EmbedContentResponse),\n/* harmony export */   EndSensitivity: () => (/* binding */ EndSensitivity),\n/* harmony export */   Environment: () => (/* binding */ Environment),\n/* harmony export */   FeatureSelectionPreference: () => (/* binding */ FeatureSelectionPreference),\n/* harmony export */   FileSource: () => (/* binding */ FileSource),\n/* harmony export */   FileState: () => (/* binding */ FileState),\n/* harmony export */   Files: () => (/* binding */ Files),\n/* harmony export */   FinishReason: () => (/* binding */ FinishReason),\n/* harmony export */   FunctionCallingConfigMode: () => (/* binding */ FunctionCallingConfigMode),\n/* harmony export */   FunctionResponse: () => (/* binding */ FunctionResponse),\n/* harmony export */   FunctionResponseBlob: () => (/* binding */ FunctionResponseBlob),\n/* harmony export */   FunctionResponseFileData: () => (/* binding */ FunctionResponseFileData),\n/* harmony export */   FunctionResponsePart: () => (/* binding */ FunctionResponsePart),\n/* harmony export */   FunctionResponseScheduling: () => (/* binding */ FunctionResponseScheduling),\n/* harmony export */   GenerateContentResponse: () => (/* binding */ GenerateContentResponse),\n/* harmony export */   GenerateContentResponsePromptFeedback: () => (/* binding */ GenerateContentResponsePromptFeedback),\n/* harmony export */   GenerateContentResponseUsageMetadata: () => (/* binding */ GenerateContentResponseUsageMetadata),\n/* harmony export */   GenerateImagesResponse: () => (/* binding */ GenerateImagesResponse),\n/* harmony export */   GenerateVideosOperation: () => (/* binding */ GenerateVideosOperation),\n/* harmony export */   GenerateVideosResponse: () => (/* binding */ GenerateVideosResponse),\n/* harmony export */   GoogleGenAI: () => (/* binding */ GoogleGenAI),\n/* harmony export */   HarmBlockMethod: () => (/* binding */ HarmBlockMethod),\n/* harmony export */   HarmBlockThreshold: () => (/* binding */ HarmBlockThreshold),\n/* harmony export */   HarmCategory: () => (/* binding */ HarmCategory),\n/* harmony export */   HarmProbability: () => (/* binding */ HarmProbability),\n/* harmony export */   HarmSeverity: () => (/* binding */ HarmSeverity),\n/* harmony export */   HttpResponse: () => (/* binding */ HttpResponse),\n/* harmony export */   ImagePromptLanguage: () => (/* binding */ ImagePromptLanguage),\n/* harmony export */   InlinedEmbedContentResponse: () => (/* binding */ InlinedEmbedContentResponse),\n/* harmony export */   InlinedResponse: () => (/* binding */ InlinedResponse),\n/* harmony export */   JobState: () => (/* binding */ JobState),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   ListBatchJobsResponse: () => (/* binding */ ListBatchJobsResponse),\n/* harmony export */   ListCachedContentsResponse: () => (/* binding */ ListCachedContentsResponse),\n/* harmony export */   ListFilesResponse: () => (/* binding */ ListFilesResponse),\n/* harmony export */   ListModelsResponse: () => (/* binding */ ListModelsResponse),\n/* harmony export */   ListTuningJobsResponse: () => (/* binding */ ListTuningJobsResponse),\n/* harmony export */   Live: () => (/* binding */ Live),\n/* harmony export */   LiveClientToolResponse: () => (/* binding */ LiveClientToolResponse),\n/* harmony export */   LiveMusicPlaybackControl: () => (/* binding */ LiveMusicPlaybackControl),\n/* harmony export */   LiveMusicServerMessage: () => (/* binding */ LiveMusicServerMessage),\n/* harmony export */   LiveSendToolResponseParameters: () => (/* binding */ LiveSendToolResponseParameters),\n/* harmony export */   LiveServerMessage: () => (/* binding */ LiveServerMessage),\n/* harmony export */   MaskReferenceImage: () => (/* binding */ MaskReferenceImage),\n/* harmony export */   MaskReferenceMode: () => (/* binding */ MaskReferenceMode),\n/* harmony export */   MediaModality: () => (/* binding */ MediaModality),\n/* harmony export */   MediaResolution: () => (/* binding */ MediaResolution),\n/* harmony export */   Modality: () => (/* binding */ Modality),\n/* harmony export */   Mode: () => (/* binding */ Mode),\n/* harmony export */   Models: () => (/* binding */ Models),\n/* harmony export */   MusicGenerationMode: () => (/* binding */ MusicGenerationMode),\n/* harmony export */   Operations: () => (/* binding */ Operations),\n/* harmony export */   Outcome: () => (/* binding */ Outcome),\n/* harmony export */   PagedItem: () => (/* binding */ PagedItem),\n/* harmony export */   Pager: () => (/* binding */ Pager),\n/* harmony export */   PersonGeneration: () => (/* binding */ PersonGeneration),\n/* harmony export */   RawReferenceImage: () => (/* binding */ RawReferenceImage),\n/* harmony export */   RecontextImageResponse: () => (/* binding */ RecontextImageResponse),\n/* harmony export */   ReplayResponse: () => (/* binding */ ReplayResponse),\n/* harmony export */   SafetyFilterLevel: () => (/* binding */ SafetyFilterLevel),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   SegmentImageResponse: () => (/* binding */ SegmentImageResponse),\n/* harmony export */   SegmentMode: () => (/* binding */ SegmentMode),\n/* harmony export */   Session: () => (/* binding */ Session),\n/* harmony export */   SingleEmbedContentResponse: () => (/* binding */ SingleEmbedContentResponse),\n/* harmony export */   StartSensitivity: () => (/* binding */ StartSensitivity),\n/* harmony export */   StyleReferenceImage: () => (/* binding */ StyleReferenceImage),\n/* harmony export */   SubjectReferenceImage: () => (/* binding */ SubjectReferenceImage),\n/* harmony export */   SubjectReferenceType: () => (/* binding */ SubjectReferenceType),\n/* harmony export */   Tokens: () => (/* binding */ Tokens),\n/* harmony export */   TrafficType: () => (/* binding */ TrafficType),\n/* harmony export */   TuningMode: () => (/* binding */ TuningMode),\n/* harmony export */   TuningTask: () => (/* binding */ TuningTask),\n/* harmony export */   TurnCompleteReason: () => (/* binding */ TurnCompleteReason),\n/* harmony export */   TurnCoverage: () => (/* binding */ TurnCoverage),\n/* harmony export */   Type: () => (/* binding */ Type),\n/* harmony export */   UpscaleImageResponse: () => (/* binding */ UpscaleImageResponse),\n/* harmony export */   UrlRetrievalStatus: () => (/* binding */ UrlRetrievalStatus),\n/* harmony export */   VideoCompressionQuality: () => (/* binding */ VideoCompressionQuality),\n/* harmony export */   VideoGenerationMaskMode: () => (/* binding */ VideoGenerationMaskMode),\n/* harmony export */   VideoGenerationReferenceType: () => (/* binding */ VideoGenerationReferenceType),\n/* harmony export */   createModelContent: () => (/* binding */ createModelContent),\n/* harmony export */   createPartFromBase64: () => (/* binding */ createPartFromBase64),\n/* harmony export */   createPartFromCodeExecutionResult: () => (/* binding */ createPartFromCodeExecutionResult),\n/* harmony export */   createPartFromExecutableCode: () => (/* binding */ createPartFromExecutableCode),\n/* harmony export */   createPartFromFunctionCall: () => (/* binding */ createPartFromFunctionCall),\n/* harmony export */   createPartFromFunctionResponse: () => (/* binding */ createPartFromFunctionResponse),\n/* harmony export */   createPartFromText: () => (/* binding */ createPartFromText),\n/* harmony export */   createPartFromUri: () => (/* binding */ createPartFromUri),\n/* harmony export */   createUserContent: () => (/* binding */ createUserContent),\n/* harmony export */   mcpToTool: () => (/* binding */ mcpToTool),\n/* harmony export */   setDefaultBaseUrls: () => (/* binding */ setDefaultBaseUrls)\n/* harmony export */ });\n/* harmony import */ var google_auth_library__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! google-auth-library */ \"(rsc)/./node_modules/google-auth-library/build/src/index.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var node_stream__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:stream */ \"node:stream\");\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! fs/promises */ \"fs/promises\");\n\n\n\n\n\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nlet _defaultBaseGeminiUrl = undefined;\nlet _defaultBaseVertexUrl = undefined;\n/**\n * Overrides the base URLs for the Gemini API and Vertex AI API.\n *\n * @remarks This function should be called before initializing the SDK. If the\n * base URLs are set after initializing the SDK, the base URLs will not be\n * updated. Base URLs provided in the HttpOptions will also take precedence over\n * URLs set here.\n *\n * @example\n * ```ts\n * import {GoogleGenAI, setDefaultBaseUrls} from '@google/genai';\n * // Override the base URL for the Gemini API.\n * setDefaultBaseUrls({geminiUrl:'https://gemini.google.com'});\n *\n * // Override the base URL for the Vertex AI API.\n * setDefaultBaseUrls({vertexUrl: 'https://vertexai.googleapis.com'});\n *\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n */\nfunction setDefaultBaseUrls(baseUrlParams) {\n    _defaultBaseGeminiUrl = baseUrlParams.geminiUrl;\n    _defaultBaseVertexUrl = baseUrlParams.vertexUrl;\n}\n/**\n * Returns the default base URLs for the Gemini API and Vertex AI API.\n */\nfunction getDefaultBaseUrls() {\n    return {\n        geminiUrl: _defaultBaseGeminiUrl,\n        vertexUrl: _defaultBaseVertexUrl,\n    };\n}\n/**\n * Returns the default base URL based on the following priority:\n *   1. Base URLs set via HttpOptions.\n *   2. Base URLs set via the latest call to setDefaultBaseUrls.\n *   3. Base URLs set via environment variables.\n */\nfunction getBaseUrl(httpOptions, vertexai, vertexBaseUrlFromEnv, geminiBaseUrlFromEnv) {\n    var _a, _b;\n    if (!(httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.baseUrl)) {\n        const defaultBaseUrls = getDefaultBaseUrls();\n        if (vertexai) {\n            return (_a = defaultBaseUrls.vertexUrl) !== null && _a !== void 0 ? _a : vertexBaseUrlFromEnv;\n        }\n        else {\n            return (_b = defaultBaseUrls.geminiUrl) !== null && _b !== void 0 ? _b : geminiBaseUrlFromEnv;\n        }\n    }\n    return httpOptions.baseUrl;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass BaseModule {\n}\nfunction formatMap(templateString, valueMap) {\n    // Use a regular expression to find all placeholders in the template string\n    const regex = /\\{([^}]+)\\}/g;\n    // Replace each placeholder with its corresponding value from the valueMap\n    return templateString.replace(regex, (match, key) => {\n        if (Object.prototype.hasOwnProperty.call(valueMap, key)) {\n            const value = valueMap[key];\n            // Convert the value to a string if it's not a string already\n            return value !== undefined && value !== null ? String(value) : '';\n        }\n        else {\n            // Handle missing keys\n            throw new Error(`Key '${key}' not found in valueMap.`);\n        }\n    });\n}\nfunction setValueByPath(data, keys, value) {\n    for (let i = 0; i < keys.length - 1; i++) {\n        const key = keys[i];\n        if (key.endsWith('[]')) {\n            const keyName = key.slice(0, -2);\n            if (!(keyName in data)) {\n                if (Array.isArray(value)) {\n                    data[keyName] = Array.from({ length: value.length }, () => ({}));\n                }\n                else {\n                    throw new Error(`Value must be a list given an array path ${key}`);\n                }\n            }\n            if (Array.isArray(data[keyName])) {\n                const arrayData = data[keyName];\n                if (Array.isArray(value)) {\n                    for (let j = 0; j < arrayData.length; j++) {\n                        const entry = arrayData[j];\n                        setValueByPath(entry, keys.slice(i + 1), value[j]);\n                    }\n                }\n                else {\n                    for (const d of arrayData) {\n                        setValueByPath(d, keys.slice(i + 1), value);\n                    }\n                }\n            }\n            return;\n        }\n        else if (key.endsWith('[0]')) {\n            const keyName = key.slice(0, -3);\n            if (!(keyName in data)) {\n                data[keyName] = [{}];\n            }\n            const arrayData = data[keyName];\n            setValueByPath(arrayData[0], keys.slice(i + 1), value);\n            return;\n        }\n        if (!data[key] || typeof data[key] !== 'object') {\n            data[key] = {};\n        }\n        data = data[key];\n    }\n    const keyToSet = keys[keys.length - 1];\n    const existingData = data[keyToSet];\n    if (existingData !== undefined) {\n        if (!value ||\n            (typeof value === 'object' && Object.keys(value).length === 0)) {\n            return;\n        }\n        if (value === existingData) {\n            return;\n        }\n        if (typeof existingData === 'object' &&\n            typeof value === 'object' &&\n            existingData !== null &&\n            value !== null) {\n            Object.assign(existingData, value);\n        }\n        else {\n            throw new Error(`Cannot set value for an existing key. Key: ${keyToSet}`);\n        }\n    }\n    else {\n        if (keyToSet === '_self' &&\n            typeof value === 'object' &&\n            value !== null &&\n            !Array.isArray(value)) {\n            const valueAsRecord = value;\n            Object.assign(data, valueAsRecord);\n        }\n        else {\n            data[keyToSet] = value;\n        }\n    }\n}\nfunction getValueByPath(data, keys) {\n    try {\n        if (keys.length === 1 && keys[0] === '_self') {\n            return data;\n        }\n        for (let i = 0; i < keys.length; i++) {\n            if (typeof data !== 'object' || data === null) {\n                return undefined;\n            }\n            const key = keys[i];\n            if (key.endsWith('[]')) {\n                const keyName = key.slice(0, -2);\n                if (keyName in data) {\n                    const arrayData = data[keyName];\n                    if (!Array.isArray(arrayData)) {\n                        return undefined;\n                    }\n                    return arrayData.map((d) => getValueByPath(d, keys.slice(i + 1)));\n                }\n                else {\n                    return undefined;\n                }\n            }\n            else {\n                data = data[key];\n            }\n        }\n        return data;\n    }\n    catch (error) {\n        if (error instanceof TypeError) {\n            return undefined;\n        }\n        throw error;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tBytes$1(fromBytes) {\n    if (typeof fromBytes !== 'string') {\n        throw new Error('fromImageBytes must be a string');\n    }\n    // TODO(b/389133914): Remove dummy bytes converter.\n    return fromBytes;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction fetchPredictOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['operationName'], fromOperationName);\n    }\n    const fromResourceName = getValueByPath(fromObject, ['resourceName']);\n    if (fromResourceName != null) {\n        setValueByPath(toObject, ['_url', 'resourceName'], fromResourceName);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex$1(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev$1(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex$1(fromVideo));\n    }\n    return toObject;\n}\nfunction getOperationParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction getOperationParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromOperationName = getValueByPath(fromObject, [\n        'operationName',\n    ]);\n    if (fromOperationName != null) {\n        setValueByPath(toObject, ['_url', 'operationName'], fromOperationName);\n    }\n    return toObject;\n}\nfunction videoFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['video', 'uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'video',\n        'encodedVideo',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes$1(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/** Required. Outcome of the code execution. */\nvar Outcome;\n(function (Outcome) {\n    /**\n     * Unspecified status. This value should not be used.\n     */\n    Outcome[\"OUTCOME_UNSPECIFIED\"] = \"OUTCOME_UNSPECIFIED\";\n    /**\n     * Code execution completed successfully.\n     */\n    Outcome[\"OUTCOME_OK\"] = \"OUTCOME_OK\";\n    /**\n     * Code execution finished but with a failure. `stderr` should contain the reason.\n     */\n    Outcome[\"OUTCOME_FAILED\"] = \"OUTCOME_FAILED\";\n    /**\n     * Code execution ran for too long, and was cancelled. There may or may not be a partial output present.\n     */\n    Outcome[\"OUTCOME_DEADLINE_EXCEEDED\"] = \"OUTCOME_DEADLINE_EXCEEDED\";\n})(Outcome || (Outcome = {}));\n/** Required. Programming language of the `code`. */\nvar Language;\n(function (Language) {\n    /**\n     * Unspecified language. This value should not be used.\n     */\n    Language[\"LANGUAGE_UNSPECIFIED\"] = \"LANGUAGE_UNSPECIFIED\";\n    /**\n     * Python >= 3.10, with numpy and simpy available.\n     */\n    Language[\"PYTHON\"] = \"PYTHON\";\n})(Language || (Language = {}));\n/** Optional. The type of the data. */\nvar Type;\n(function (Type) {\n    /**\n     * Not specified, should not be used.\n     */\n    Type[\"TYPE_UNSPECIFIED\"] = \"TYPE_UNSPECIFIED\";\n    /**\n     * OpenAPI string type\n     */\n    Type[\"STRING\"] = \"STRING\";\n    /**\n     * OpenAPI number type\n     */\n    Type[\"NUMBER\"] = \"NUMBER\";\n    /**\n     * OpenAPI integer type\n     */\n    Type[\"INTEGER\"] = \"INTEGER\";\n    /**\n     * OpenAPI boolean type\n     */\n    Type[\"BOOLEAN\"] = \"BOOLEAN\";\n    /**\n     * OpenAPI array type\n     */\n    Type[\"ARRAY\"] = \"ARRAY\";\n    /**\n     * OpenAPI object type\n     */\n    Type[\"OBJECT\"] = \"OBJECT\";\n    /**\n     * Null type\n     */\n    Type[\"NULL\"] = \"NULL\";\n})(Type || (Type = {}));\n/** Required. Harm category. */\nvar HarmCategory;\n(function (HarmCategory) {\n    /**\n     * The harm category is unspecified.\n     */\n    HarmCategory[\"HARM_CATEGORY_UNSPECIFIED\"] = \"HARM_CATEGORY_UNSPECIFIED\";\n    /**\n     * The harm category is hate speech.\n     */\n    HarmCategory[\"HARM_CATEGORY_HATE_SPEECH\"] = \"HARM_CATEGORY_HATE_SPEECH\";\n    /**\n     * The harm category is dangerous content.\n     */\n    HarmCategory[\"HARM_CATEGORY_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is harassment.\n     */\n    HarmCategory[\"HARM_CATEGORY_HARASSMENT\"] = \"HARM_CATEGORY_HARASSMENT\";\n    /**\n     * The harm category is sexually explicit content.\n     */\n    HarmCategory[\"HARM_CATEGORY_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_SEXUALLY_EXPLICIT\";\n    /**\n     * Deprecated: Election filter is not longer supported. The harm category is civic integrity.\n     */\n    HarmCategory[\"HARM_CATEGORY_CIVIC_INTEGRITY\"] = \"HARM_CATEGORY_CIVIC_INTEGRITY\";\n    /**\n     * The harm category is image hate.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HATE\"] = \"HARM_CATEGORY_IMAGE_HATE\";\n    /**\n     * The harm category is image dangerous content.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\"] = \"HARM_CATEGORY_IMAGE_DANGEROUS_CONTENT\";\n    /**\n     * The harm category is image harassment.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_HARASSMENT\"] = \"HARM_CATEGORY_IMAGE_HARASSMENT\";\n    /**\n     * The harm category is image sexually explicit content.\n     */\n    HarmCategory[\"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\"] = \"HARM_CATEGORY_IMAGE_SEXUALLY_EXPLICIT\";\n})(HarmCategory || (HarmCategory = {}));\n/** Optional. Specify if the threshold is used for probability or severity score. If not specified, the threshold is used for probability score. */\nvar HarmBlockMethod;\n(function (HarmBlockMethod) {\n    /**\n     * The harm block method is unspecified.\n     */\n    HarmBlockMethod[\"HARM_BLOCK_METHOD_UNSPECIFIED\"] = \"HARM_BLOCK_METHOD_UNSPECIFIED\";\n    /**\n     * The harm block method uses both probability and severity scores.\n     */\n    HarmBlockMethod[\"SEVERITY\"] = \"SEVERITY\";\n    /**\n     * The harm block method uses the probability score.\n     */\n    HarmBlockMethod[\"PROBABILITY\"] = \"PROBABILITY\";\n})(HarmBlockMethod || (HarmBlockMethod = {}));\n/** Required. The harm block threshold. */\nvar HarmBlockThreshold;\n(function (HarmBlockThreshold) {\n    /**\n     * Unspecified harm block threshold.\n     */\n    HarmBlockThreshold[\"HARM_BLOCK_THRESHOLD_UNSPECIFIED\"] = \"HARM_BLOCK_THRESHOLD_UNSPECIFIED\";\n    /**\n     * Block low threshold and above (i.e. block more).\n     */\n    HarmBlockThreshold[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    /**\n     * Block medium threshold and above.\n     */\n    HarmBlockThreshold[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    /**\n     * Block only high threshold (i.e. block less).\n     */\n    HarmBlockThreshold[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    /**\n     * Block none.\n     */\n    HarmBlockThreshold[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n    /**\n     * Turn off the safety filter.\n     */\n    HarmBlockThreshold[\"OFF\"] = \"OFF\";\n})(HarmBlockThreshold || (HarmBlockThreshold = {}));\n/** The mode of the predictor to be used in dynamic retrieval. */\nvar Mode;\n(function (Mode) {\n    /**\n     * Always trigger retrieval.\n     */\n    Mode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    Mode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(Mode || (Mode = {}));\n/** Type of auth scheme. */\nvar AuthType;\n(function (AuthType) {\n    AuthType[\"AUTH_TYPE_UNSPECIFIED\"] = \"AUTH_TYPE_UNSPECIFIED\";\n    /**\n     * No Auth.\n     */\n    AuthType[\"NO_AUTH\"] = \"NO_AUTH\";\n    /**\n     * API Key Auth.\n     */\n    AuthType[\"API_KEY_AUTH\"] = \"API_KEY_AUTH\";\n    /**\n     * HTTP Basic Auth.\n     */\n    AuthType[\"HTTP_BASIC_AUTH\"] = \"HTTP_BASIC_AUTH\";\n    /**\n     * Google Service Account Auth.\n     */\n    AuthType[\"GOOGLE_SERVICE_ACCOUNT_AUTH\"] = \"GOOGLE_SERVICE_ACCOUNT_AUTH\";\n    /**\n     * OAuth auth.\n     */\n    AuthType[\"OAUTH\"] = \"OAUTH\";\n    /**\n     * OpenID Connect (OIDC) Auth.\n     */\n    AuthType[\"OIDC_AUTH\"] = \"OIDC_AUTH\";\n})(AuthType || (AuthType = {}));\n/** The API spec that the external API implements. */\nvar ApiSpec;\n(function (ApiSpec) {\n    /**\n     * Unspecified API spec. This value should not be used.\n     */\n    ApiSpec[\"API_SPEC_UNSPECIFIED\"] = \"API_SPEC_UNSPECIFIED\";\n    /**\n     * Simple search API spec.\n     */\n    ApiSpec[\"SIMPLE_SEARCH\"] = \"SIMPLE_SEARCH\";\n    /**\n     * Elastic search API spec.\n     */\n    ApiSpec[\"ELASTIC_SEARCH\"] = \"ELASTIC_SEARCH\";\n})(ApiSpec || (ApiSpec = {}));\n/** Status of the url retrieval. */\nvar UrlRetrievalStatus;\n(function (UrlRetrievalStatus) {\n    /**\n     * Default value. This value is unused\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSPECIFIED\"] = \"URL_RETRIEVAL_STATUS_UNSPECIFIED\";\n    /**\n     * Url retrieval is successful.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_SUCCESS\"] = \"URL_RETRIEVAL_STATUS_SUCCESS\";\n    /**\n     * Url retrieval is failed due to error.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_ERROR\"] = \"URL_RETRIEVAL_STATUS_ERROR\";\n    /**\n     * Url retrieval is failed because the content is behind paywall.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_PAYWALL\"] = \"URL_RETRIEVAL_STATUS_PAYWALL\";\n    /**\n     * Url retrieval is failed because the content is unsafe.\n     */\n    UrlRetrievalStatus[\"URL_RETRIEVAL_STATUS_UNSAFE\"] = \"URL_RETRIEVAL_STATUS_UNSAFE\";\n})(UrlRetrievalStatus || (UrlRetrievalStatus = {}));\n/** Output only. The reason why the model stopped generating tokens.\n\n  If empty, the model has not stopped generating the tokens.\n   */\nvar FinishReason;\n(function (FinishReason) {\n    /**\n     * The finish reason is unspecified.\n     */\n    FinishReason[\"FINISH_REASON_UNSPECIFIED\"] = \"FINISH_REASON_UNSPECIFIED\";\n    /**\n     * Token generation reached a natural stopping point or a configured stop sequence.\n     */\n    FinishReason[\"STOP\"] = \"STOP\";\n    /**\n     * Token generation reached the configured maximum output tokens.\n     */\n    FinishReason[\"MAX_TOKENS\"] = \"MAX_TOKENS\";\n    /**\n     * Token generation stopped because the content potentially contains safety violations. NOTE: When streaming, [content][] is empty if content filters blocks the output.\n     */\n    FinishReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * The token generation stopped because of potential recitation.\n     */\n    FinishReason[\"RECITATION\"] = \"RECITATION\";\n    /**\n     * The token generation stopped because of using an unsupported language.\n     */\n    FinishReason[\"LANGUAGE\"] = \"LANGUAGE\";\n    /**\n     * All other reasons that stopped the token generation.\n     */\n    FinishReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Token generation stopped because the content contains forbidden terms.\n     */\n    FinishReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Token generation stopped for potentially containing prohibited content.\n     */\n    FinishReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).\n     */\n    FinishReason[\"SPII\"] = \"SPII\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    FinishReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * Token generation stopped because generated images have safety violations.\n     */\n    FinishReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n    /**\n     * The tool call generated by the model is invalid.\n     */\n    FinishReason[\"UNEXPECTED_TOOL_CALL\"] = \"UNEXPECTED_TOOL_CALL\";\n    /**\n     * Image generation stopped because the generated images have prohibited content.\n     */\n    FinishReason[\"IMAGE_PROHIBITED_CONTENT\"] = \"IMAGE_PROHIBITED_CONTENT\";\n})(FinishReason || (FinishReason = {}));\n/** Output only. Harm probability levels in the content. */\nvar HarmProbability;\n(function (HarmProbability) {\n    /**\n     * Harm probability unspecified.\n     */\n    HarmProbability[\"HARM_PROBABILITY_UNSPECIFIED\"] = \"HARM_PROBABILITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm.\n     */\n    HarmProbability[\"NEGLIGIBLE\"] = \"NEGLIGIBLE\";\n    /**\n     * Low level of harm.\n     */\n    HarmProbability[\"LOW\"] = \"LOW\";\n    /**\n     * Medium level of harm.\n     */\n    HarmProbability[\"MEDIUM\"] = \"MEDIUM\";\n    /**\n     * High level of harm.\n     */\n    HarmProbability[\"HIGH\"] = \"HIGH\";\n})(HarmProbability || (HarmProbability = {}));\n/** Output only. Harm severity levels in the content. */\nvar HarmSeverity;\n(function (HarmSeverity) {\n    /**\n     * Harm severity unspecified.\n     */\n    HarmSeverity[\"HARM_SEVERITY_UNSPECIFIED\"] = \"HARM_SEVERITY_UNSPECIFIED\";\n    /**\n     * Negligible level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_NEGLIGIBLE\"] = \"HARM_SEVERITY_NEGLIGIBLE\";\n    /**\n     * Low level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_LOW\"] = \"HARM_SEVERITY_LOW\";\n    /**\n     * Medium level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_MEDIUM\"] = \"HARM_SEVERITY_MEDIUM\";\n    /**\n     * High level of harm severity.\n     */\n    HarmSeverity[\"HARM_SEVERITY_HIGH\"] = \"HARM_SEVERITY_HIGH\";\n})(HarmSeverity || (HarmSeverity = {}));\n/** Output only. Blocked reason. */\nvar BlockedReason;\n(function (BlockedReason) {\n    /**\n     * Unspecified blocked reason.\n     */\n    BlockedReason[\"BLOCKED_REASON_UNSPECIFIED\"] = \"BLOCKED_REASON_UNSPECIFIED\";\n    /**\n     * Candidates blocked due to safety.\n     */\n    BlockedReason[\"SAFETY\"] = \"SAFETY\";\n    /**\n     * Candidates blocked due to other reason.\n     */\n    BlockedReason[\"OTHER\"] = \"OTHER\";\n    /**\n     * Candidates blocked due to the terms which are included from the terminology blocklist.\n     */\n    BlockedReason[\"BLOCKLIST\"] = \"BLOCKLIST\";\n    /**\n     * Candidates blocked due to prohibited content.\n     */\n    BlockedReason[\"PROHIBITED_CONTENT\"] = \"PROHIBITED_CONTENT\";\n    /**\n     * Candidates blocked due to unsafe image generation content.\n     */\n    BlockedReason[\"IMAGE_SAFETY\"] = \"IMAGE_SAFETY\";\n})(BlockedReason || (BlockedReason = {}));\n/** Output only. Traffic type. This shows whether a request consumes Pay-As-You-Go or Provisioned Throughput quota. */\nvar TrafficType;\n(function (TrafficType) {\n    /**\n     * Unspecified request traffic type.\n     */\n    TrafficType[\"TRAFFIC_TYPE_UNSPECIFIED\"] = \"TRAFFIC_TYPE_UNSPECIFIED\";\n    /**\n     * Type for Pay-As-You-Go traffic.\n     */\n    TrafficType[\"ON_DEMAND\"] = \"ON_DEMAND\";\n    /**\n     * Type for Provisioned Throughput traffic.\n     */\n    TrafficType[\"PROVISIONED_THROUGHPUT\"] = \"PROVISIONED_THROUGHPUT\";\n})(TrafficType || (TrafficType = {}));\n/** Server content modalities. */\nvar Modality;\n(function (Modality) {\n    /**\n     * The modality is unspecified.\n     */\n    Modality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Indicates the model should return text\n     */\n    Modality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Indicates the model should return images.\n     */\n    Modality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Indicates the model should return audio.\n     */\n    Modality[\"AUDIO\"] = \"AUDIO\";\n})(Modality || (Modality = {}));\n/** The media resolution to use. */\nvar MediaResolution;\n(function (MediaResolution) {\n    /**\n     * Media resolution has not been set\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_UNSPECIFIED\"] = \"MEDIA_RESOLUTION_UNSPECIFIED\";\n    /**\n     * Media resolution set to low (64 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_LOW\"] = \"MEDIA_RESOLUTION_LOW\";\n    /**\n     * Media resolution set to medium (256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_MEDIUM\"] = \"MEDIA_RESOLUTION_MEDIUM\";\n    /**\n     * Media resolution set to high (zoomed reframing with 256 tokens).\n     */\n    MediaResolution[\"MEDIA_RESOLUTION_HIGH\"] = \"MEDIA_RESOLUTION_HIGH\";\n})(MediaResolution || (MediaResolution = {}));\n/** Job state. */\nvar JobState;\n(function (JobState) {\n    /**\n     * The job state is unspecified.\n     */\n    JobState[\"JOB_STATE_UNSPECIFIED\"] = \"JOB_STATE_UNSPECIFIED\";\n    /**\n     * The job has been just created or resumed and processing has not yet begun.\n     */\n    JobState[\"JOB_STATE_QUEUED\"] = \"JOB_STATE_QUEUED\";\n    /**\n     * The service is preparing to run the job.\n     */\n    JobState[\"JOB_STATE_PENDING\"] = \"JOB_STATE_PENDING\";\n    /**\n     * The job is in progress.\n     */\n    JobState[\"JOB_STATE_RUNNING\"] = \"JOB_STATE_RUNNING\";\n    /**\n     * The job completed successfully.\n     */\n    JobState[\"JOB_STATE_SUCCEEDED\"] = \"JOB_STATE_SUCCEEDED\";\n    /**\n     * The job failed.\n     */\n    JobState[\"JOB_STATE_FAILED\"] = \"JOB_STATE_FAILED\";\n    /**\n     * The job is being cancelled. From this state the job may only go to either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.\n     */\n    JobState[\"JOB_STATE_CANCELLING\"] = \"JOB_STATE_CANCELLING\";\n    /**\n     * The job has been cancelled.\n     */\n    JobState[\"JOB_STATE_CANCELLED\"] = \"JOB_STATE_CANCELLED\";\n    /**\n     * The job has been stopped, and can be resumed.\n     */\n    JobState[\"JOB_STATE_PAUSED\"] = \"JOB_STATE_PAUSED\";\n    /**\n     * The job has expired.\n     */\n    JobState[\"JOB_STATE_EXPIRED\"] = \"JOB_STATE_EXPIRED\";\n    /**\n     * The job is being updated. Only jobs in the `JOB_STATE_RUNNING` state can be updated. After updating, the job goes back to the `JOB_STATE_RUNNING` state.\n     */\n    JobState[\"JOB_STATE_UPDATING\"] = \"JOB_STATE_UPDATING\";\n    /**\n     * The job is partially succeeded, some results may be missing due to errors.\n     */\n    JobState[\"JOB_STATE_PARTIALLY_SUCCEEDED\"] = \"JOB_STATE_PARTIALLY_SUCCEEDED\";\n})(JobState || (JobState = {}));\n/** Tuning mode. */\nvar TuningMode;\n(function (TuningMode) {\n    /**\n     * Tuning mode is unspecified.\n     */\n    TuningMode[\"TUNING_MODE_UNSPECIFIED\"] = \"TUNING_MODE_UNSPECIFIED\";\n    /**\n     * Full fine-tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_FULL\"] = \"TUNING_MODE_FULL\";\n    /**\n     * PEFT adapter tuning mode.\n     */\n    TuningMode[\"TUNING_MODE_PEFT_ADAPTER\"] = \"TUNING_MODE_PEFT_ADAPTER\";\n})(TuningMode || (TuningMode = {}));\n/** Optional. Adapter size for tuning. */\nvar AdapterSize;\n(function (AdapterSize) {\n    /**\n     * Adapter size is unspecified.\n     */\n    AdapterSize[\"ADAPTER_SIZE_UNSPECIFIED\"] = \"ADAPTER_SIZE_UNSPECIFIED\";\n    /**\n     * Adapter size 1.\n     */\n    AdapterSize[\"ADAPTER_SIZE_ONE\"] = \"ADAPTER_SIZE_ONE\";\n    /**\n     * Adapter size 2.\n     */\n    AdapterSize[\"ADAPTER_SIZE_TWO\"] = \"ADAPTER_SIZE_TWO\";\n    /**\n     * Adapter size 4.\n     */\n    AdapterSize[\"ADAPTER_SIZE_FOUR\"] = \"ADAPTER_SIZE_FOUR\";\n    /**\n     * Adapter size 8.\n     */\n    AdapterSize[\"ADAPTER_SIZE_EIGHT\"] = \"ADAPTER_SIZE_EIGHT\";\n    /**\n     * Adapter size 16.\n     */\n    AdapterSize[\"ADAPTER_SIZE_SIXTEEN\"] = \"ADAPTER_SIZE_SIXTEEN\";\n    /**\n     * Adapter size 32.\n     */\n    AdapterSize[\"ADAPTER_SIZE_THIRTY_TWO\"] = \"ADAPTER_SIZE_THIRTY_TWO\";\n})(AdapterSize || (AdapterSize = {}));\n/** Optional. The tuning task. Either I2V or T2V. */\nvar TuningTask;\n(function (TuningTask) {\n    /**\n     * Default value. This value is unused.\n     */\n    TuningTask[\"TUNING_TASK_UNSPECIFIED\"] = \"TUNING_TASK_UNSPECIFIED\";\n    /**\n     * Tuning task for image to video.\n     */\n    TuningTask[\"TUNING_TASK_I2V\"] = \"TUNING_TASK_I2V\";\n    /**\n     * Tuning task for text to video.\n     */\n    TuningTask[\"TUNING_TASK_T2V\"] = \"TUNING_TASK_T2V\";\n})(TuningTask || (TuningTask = {}));\n/** Options for feature selection preference. */\nvar FeatureSelectionPreference;\n(function (FeatureSelectionPreference) {\n    FeatureSelectionPreference[\"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\"] = \"FEATURE_SELECTION_PREFERENCE_UNSPECIFIED\";\n    FeatureSelectionPreference[\"PRIORITIZE_QUALITY\"] = \"PRIORITIZE_QUALITY\";\n    FeatureSelectionPreference[\"BALANCED\"] = \"BALANCED\";\n    FeatureSelectionPreference[\"PRIORITIZE_COST\"] = \"PRIORITIZE_COST\";\n})(FeatureSelectionPreference || (FeatureSelectionPreference = {}));\n/** Defines the function behavior. Defaults to `BLOCKING`. */\nvar Behavior;\n(function (Behavior) {\n    /**\n     * This value is unused.\n     */\n    Behavior[\"UNSPECIFIED\"] = \"UNSPECIFIED\";\n    /**\n     * If set, the system will wait to receive the function response before continuing the conversation.\n     */\n    Behavior[\"BLOCKING\"] = \"BLOCKING\";\n    /**\n     * If set, the system will not wait to receive the function response. Instead, it will attempt to handle function responses as they become available while maintaining the conversation between the user and the model.\n     */\n    Behavior[\"NON_BLOCKING\"] = \"NON_BLOCKING\";\n})(Behavior || (Behavior = {}));\n/** Config for the dynamic retrieval config mode. */\nvar DynamicRetrievalConfigMode;\n(function (DynamicRetrievalConfigMode) {\n    /**\n     * Always trigger retrieval.\n     */\n    DynamicRetrievalConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Run retrieval only when system decides it is necessary.\n     */\n    DynamicRetrievalConfigMode[\"MODE_DYNAMIC\"] = \"MODE_DYNAMIC\";\n})(DynamicRetrievalConfigMode || (DynamicRetrievalConfigMode = {}));\n/** The environment being operated. */\nvar Environment;\n(function (Environment) {\n    /**\n     * Defaults to browser.\n     */\n    Environment[\"ENVIRONMENT_UNSPECIFIED\"] = \"ENVIRONMENT_UNSPECIFIED\";\n    /**\n     * Operates in a web browser.\n     */\n    Environment[\"ENVIRONMENT_BROWSER\"] = \"ENVIRONMENT_BROWSER\";\n})(Environment || (Environment = {}));\n/** Config for the function calling config mode. */\nvar FunctionCallingConfigMode;\n(function (FunctionCallingConfigMode) {\n    /**\n     * The function calling config mode is unspecified. Should not be used.\n     */\n    FunctionCallingConfigMode[\"MODE_UNSPECIFIED\"] = \"MODE_UNSPECIFIED\";\n    /**\n     * Default model behavior, model decides to predict either function calls or natural language response.\n     */\n    FunctionCallingConfigMode[\"AUTO\"] = \"AUTO\";\n    /**\n     * Model is constrained to always predicting function calls only. If \"allowed_function_names\" are set, the predicted function calls will be limited to any one of \"allowed_function_names\", else the predicted function calls will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"ANY\"] = \"ANY\";\n    /**\n     * Model will not predict any function calls. Model behavior is same as when not passing any function declarations.\n     */\n    FunctionCallingConfigMode[\"NONE\"] = \"NONE\";\n    /**\n     * Model decides to predict either a function call or a natural language response, but will validate function calls with constrained decoding. If \"allowed_function_names\" are set, the predicted function call will be limited to any one of \"allowed_function_names\", else the predicted function call will be any one of the provided \"function_declarations\".\n     */\n    FunctionCallingConfigMode[\"VALIDATED\"] = \"VALIDATED\";\n})(FunctionCallingConfigMode || (FunctionCallingConfigMode = {}));\n/** Enum that controls the safety filter level for objectionable content. */\nvar SafetyFilterLevel;\n(function (SafetyFilterLevel) {\n    SafetyFilterLevel[\"BLOCK_LOW_AND_ABOVE\"] = \"BLOCK_LOW_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_MEDIUM_AND_ABOVE\"] = \"BLOCK_MEDIUM_AND_ABOVE\";\n    SafetyFilterLevel[\"BLOCK_ONLY_HIGH\"] = \"BLOCK_ONLY_HIGH\";\n    SafetyFilterLevel[\"BLOCK_NONE\"] = \"BLOCK_NONE\";\n})(SafetyFilterLevel || (SafetyFilterLevel = {}));\n/** Enum that controls the generation of people. */\nvar PersonGeneration;\n(function (PersonGeneration) {\n    /**\n     * Block generation of images of people.\n     */\n    PersonGeneration[\"DONT_ALLOW\"] = \"DONT_ALLOW\";\n    /**\n     * Generate images of adults, but not children.\n     */\n    PersonGeneration[\"ALLOW_ADULT\"] = \"ALLOW_ADULT\";\n    /**\n     * Generate images that include adults and children.\n     */\n    PersonGeneration[\"ALLOW_ALL\"] = \"ALLOW_ALL\";\n})(PersonGeneration || (PersonGeneration = {}));\n/** Enum that specifies the language of the text in the prompt. */\nvar ImagePromptLanguage;\n(function (ImagePromptLanguage) {\n    /**\n     * Auto-detect the language.\n     */\n    ImagePromptLanguage[\"auto\"] = \"auto\";\n    /**\n     * English\n     */\n    ImagePromptLanguage[\"en\"] = \"en\";\n    /**\n     * Japanese\n     */\n    ImagePromptLanguage[\"ja\"] = \"ja\";\n    /**\n     * Korean\n     */\n    ImagePromptLanguage[\"ko\"] = \"ko\";\n    /**\n     * Hindi\n     */\n    ImagePromptLanguage[\"hi\"] = \"hi\";\n    /**\n     * Chinese\n     */\n    ImagePromptLanguage[\"zh\"] = \"zh\";\n    /**\n     * Portuguese\n     */\n    ImagePromptLanguage[\"pt\"] = \"pt\";\n    /**\n     * Spanish\n     */\n    ImagePromptLanguage[\"es\"] = \"es\";\n})(ImagePromptLanguage || (ImagePromptLanguage = {}));\n/** Enum representing the mask mode of a mask reference image. */\nvar MaskReferenceMode;\n(function (MaskReferenceMode) {\n    MaskReferenceMode[\"MASK_MODE_DEFAULT\"] = \"MASK_MODE_DEFAULT\";\n    MaskReferenceMode[\"MASK_MODE_USER_PROVIDED\"] = \"MASK_MODE_USER_PROVIDED\";\n    MaskReferenceMode[\"MASK_MODE_BACKGROUND\"] = \"MASK_MODE_BACKGROUND\";\n    MaskReferenceMode[\"MASK_MODE_FOREGROUND\"] = \"MASK_MODE_FOREGROUND\";\n    MaskReferenceMode[\"MASK_MODE_SEMANTIC\"] = \"MASK_MODE_SEMANTIC\";\n})(MaskReferenceMode || (MaskReferenceMode = {}));\n/** Enum representing the control type of a control reference image. */\nvar ControlReferenceType;\n(function (ControlReferenceType) {\n    ControlReferenceType[\"CONTROL_TYPE_DEFAULT\"] = \"CONTROL_TYPE_DEFAULT\";\n    ControlReferenceType[\"CONTROL_TYPE_CANNY\"] = \"CONTROL_TYPE_CANNY\";\n    ControlReferenceType[\"CONTROL_TYPE_SCRIBBLE\"] = \"CONTROL_TYPE_SCRIBBLE\";\n    ControlReferenceType[\"CONTROL_TYPE_FACE_MESH\"] = \"CONTROL_TYPE_FACE_MESH\";\n})(ControlReferenceType || (ControlReferenceType = {}));\n/** Enum representing the subject type of a subject reference image. */\nvar SubjectReferenceType;\n(function (SubjectReferenceType) {\n    SubjectReferenceType[\"SUBJECT_TYPE_DEFAULT\"] = \"SUBJECT_TYPE_DEFAULT\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PERSON\"] = \"SUBJECT_TYPE_PERSON\";\n    SubjectReferenceType[\"SUBJECT_TYPE_ANIMAL\"] = \"SUBJECT_TYPE_ANIMAL\";\n    SubjectReferenceType[\"SUBJECT_TYPE_PRODUCT\"] = \"SUBJECT_TYPE_PRODUCT\";\n})(SubjectReferenceType || (SubjectReferenceType = {}));\n/** Enum representing the editing mode. */\nvar EditMode;\n(function (EditMode) {\n    EditMode[\"EDIT_MODE_DEFAULT\"] = \"EDIT_MODE_DEFAULT\";\n    EditMode[\"EDIT_MODE_INPAINT_REMOVAL\"] = \"EDIT_MODE_INPAINT_REMOVAL\";\n    EditMode[\"EDIT_MODE_INPAINT_INSERTION\"] = \"EDIT_MODE_INPAINT_INSERTION\";\n    EditMode[\"EDIT_MODE_OUTPAINT\"] = \"EDIT_MODE_OUTPAINT\";\n    EditMode[\"EDIT_MODE_CONTROLLED_EDITING\"] = \"EDIT_MODE_CONTROLLED_EDITING\";\n    EditMode[\"EDIT_MODE_STYLE\"] = \"EDIT_MODE_STYLE\";\n    EditMode[\"EDIT_MODE_BGSWAP\"] = \"EDIT_MODE_BGSWAP\";\n    EditMode[\"EDIT_MODE_PRODUCT_IMAGE\"] = \"EDIT_MODE_PRODUCT_IMAGE\";\n})(EditMode || (EditMode = {}));\n/** Enum that represents the segmentation mode. */\nvar SegmentMode;\n(function (SegmentMode) {\n    SegmentMode[\"FOREGROUND\"] = \"FOREGROUND\";\n    SegmentMode[\"BACKGROUND\"] = \"BACKGROUND\";\n    SegmentMode[\"PROMPT\"] = \"PROMPT\";\n    SegmentMode[\"SEMANTIC\"] = \"SEMANTIC\";\n    SegmentMode[\"INTERACTIVE\"] = \"INTERACTIVE\";\n})(SegmentMode || (SegmentMode = {}));\n/** Enum for the reference type of a video generation reference image. */\nvar VideoGenerationReferenceType;\n(function (VideoGenerationReferenceType) {\n    /**\n     * A reference image that provides assets to the generated video,\n        such as the scene, an object, a character, etc.\n     */\n    VideoGenerationReferenceType[\"ASSET\"] = \"ASSET\";\n    /**\n     * A reference image that provides aesthetics including colors,\n        lighting, texture, etc., to be used as the style of the generated video,\n        such as 'anime', 'photography', 'origami', etc.\n     */\n    VideoGenerationReferenceType[\"STYLE\"] = \"STYLE\";\n})(VideoGenerationReferenceType || (VideoGenerationReferenceType = {}));\n/** Enum for the mask mode of a video generation mask. */\nvar VideoGenerationMaskMode;\n(function (VideoGenerationMaskMode) {\n    /**\n     * The image mask contains a masked rectangular region which is\n        applied on the first frame of the input video. The object described in\n        the prompt is inserted into this region and will appear in subsequent\n        frames.\n     */\n    VideoGenerationMaskMode[\"INSERT\"] = \"INSERT\";\n    /**\n     * The image mask is used to determine an object in the\n        first video frame to track. This object is removed from the video.\n     */\n    VideoGenerationMaskMode[\"REMOVE\"] = \"REMOVE\";\n    /**\n     * The image mask is used to determine a region in the\n        video. Objects in this region will be removed.\n     */\n    VideoGenerationMaskMode[\"REMOVE_STATIC\"] = \"REMOVE_STATIC\";\n    /**\n     * The image mask contains a masked rectangular region where\n        the input video will go. The remaining area will be generated. Video\n        masks are not supported.\n     */\n    VideoGenerationMaskMode[\"OUTPAINT\"] = \"OUTPAINT\";\n})(VideoGenerationMaskMode || (VideoGenerationMaskMode = {}));\n/** Enum that controls the compression quality of the generated videos. */\nvar VideoCompressionQuality;\n(function (VideoCompressionQuality) {\n    /**\n     * Optimized video compression quality. This will produce videos\n        with a compressed, smaller file size.\n     */\n    VideoCompressionQuality[\"OPTIMIZED\"] = \"OPTIMIZED\";\n    /**\n     * Lossless video compression quality. This will produce videos\n        with a larger file size.\n     */\n    VideoCompressionQuality[\"LOSSLESS\"] = \"LOSSLESS\";\n})(VideoCompressionQuality || (VideoCompressionQuality = {}));\n/** State for the lifecycle of a File. */\nvar FileState;\n(function (FileState) {\n    FileState[\"STATE_UNSPECIFIED\"] = \"STATE_UNSPECIFIED\";\n    FileState[\"PROCESSING\"] = \"PROCESSING\";\n    FileState[\"ACTIVE\"] = \"ACTIVE\";\n    FileState[\"FAILED\"] = \"FAILED\";\n})(FileState || (FileState = {}));\n/** Source of the File. */\nvar FileSource;\n(function (FileSource) {\n    FileSource[\"SOURCE_UNSPECIFIED\"] = \"SOURCE_UNSPECIFIED\";\n    FileSource[\"UPLOADED\"] = \"UPLOADED\";\n    FileSource[\"GENERATED\"] = \"GENERATED\";\n})(FileSource || (FileSource = {}));\n/** The reason why the turn is complete. */\nvar TurnCompleteReason;\n(function (TurnCompleteReason) {\n    /**\n     * Default value. Reason is unspecified.\n     */\n    TurnCompleteReason[\"TURN_COMPLETE_REASON_UNSPECIFIED\"] = \"TURN_COMPLETE_REASON_UNSPECIFIED\";\n    /**\n     * The function call generated by the model is invalid.\n     */\n    TurnCompleteReason[\"MALFORMED_FUNCTION_CALL\"] = \"MALFORMED_FUNCTION_CALL\";\n    /**\n     * The response is rejected by the model.\n     */\n    TurnCompleteReason[\"RESPONSE_REJECTED\"] = \"RESPONSE_REJECTED\";\n    /**\n     * Needs more input from the user.\n     */\n    TurnCompleteReason[\"NEED_MORE_INPUT\"] = \"NEED_MORE_INPUT\";\n})(TurnCompleteReason || (TurnCompleteReason = {}));\n/** Server content modalities. */\nvar MediaModality;\n(function (MediaModality) {\n    /**\n     * The modality is unspecified.\n     */\n    MediaModality[\"MODALITY_UNSPECIFIED\"] = \"MODALITY_UNSPECIFIED\";\n    /**\n     * Plain text.\n     */\n    MediaModality[\"TEXT\"] = \"TEXT\";\n    /**\n     * Images.\n     */\n    MediaModality[\"IMAGE\"] = \"IMAGE\";\n    /**\n     * Video.\n     */\n    MediaModality[\"VIDEO\"] = \"VIDEO\";\n    /**\n     * Audio.\n     */\n    MediaModality[\"AUDIO\"] = \"AUDIO\";\n    /**\n     * Document, e.g. PDF.\n     */\n    MediaModality[\"DOCUMENT\"] = \"DOCUMENT\";\n})(MediaModality || (MediaModality = {}));\n/** Start of speech sensitivity. */\nvar StartSensitivity;\n(function (StartSensitivity) {\n    /**\n     * The default is START_SENSITIVITY_LOW.\n     */\n    StartSensitivity[\"START_SENSITIVITY_UNSPECIFIED\"] = \"START_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection will detect the start of speech more often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_HIGH\"] = \"START_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection will detect the start of speech less often.\n     */\n    StartSensitivity[\"START_SENSITIVITY_LOW\"] = \"START_SENSITIVITY_LOW\";\n})(StartSensitivity || (StartSensitivity = {}));\n/** End of speech sensitivity. */\nvar EndSensitivity;\n(function (EndSensitivity) {\n    /**\n     * The default is END_SENSITIVITY_LOW.\n     */\n    EndSensitivity[\"END_SENSITIVITY_UNSPECIFIED\"] = \"END_SENSITIVITY_UNSPECIFIED\";\n    /**\n     * Automatic detection ends speech more often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_HIGH\"] = \"END_SENSITIVITY_HIGH\";\n    /**\n     * Automatic detection ends speech less often.\n     */\n    EndSensitivity[\"END_SENSITIVITY_LOW\"] = \"END_SENSITIVITY_LOW\";\n})(EndSensitivity || (EndSensitivity = {}));\n/** The different ways of handling user activity. */\nvar ActivityHandling;\n(function (ActivityHandling) {\n    /**\n     * If unspecified, the default behavior is `START_OF_ACTIVITY_INTERRUPTS`.\n     */\n    ActivityHandling[\"ACTIVITY_HANDLING_UNSPECIFIED\"] = \"ACTIVITY_HANDLING_UNSPECIFIED\";\n    /**\n     * If true, start of activity will interrupt the model's response (also called \"barge in\"). The model's current response will be cut-off in the moment of the interruption. This is the default behavior.\n     */\n    ActivityHandling[\"START_OF_ACTIVITY_INTERRUPTS\"] = \"START_OF_ACTIVITY_INTERRUPTS\";\n    /**\n     * The model's response will not be interrupted.\n     */\n    ActivityHandling[\"NO_INTERRUPTION\"] = \"NO_INTERRUPTION\";\n})(ActivityHandling || (ActivityHandling = {}));\n/** Options about which input is included in the user's turn. */\nvar TurnCoverage;\n(function (TurnCoverage) {\n    /**\n     * If unspecified, the default behavior is `TURN_INCLUDES_ONLY_ACTIVITY`.\n     */\n    TurnCoverage[\"TURN_COVERAGE_UNSPECIFIED\"] = \"TURN_COVERAGE_UNSPECIFIED\";\n    /**\n     * The users turn only includes activity since the last turn, excluding inactivity (e.g. silence on the audio stream). This is the default behavior.\n     */\n    TurnCoverage[\"TURN_INCLUDES_ONLY_ACTIVITY\"] = \"TURN_INCLUDES_ONLY_ACTIVITY\";\n    /**\n     * The users turn includes all realtime input since the last turn, including inactivity (e.g. silence on the audio stream).\n     */\n    TurnCoverage[\"TURN_INCLUDES_ALL_INPUT\"] = \"TURN_INCLUDES_ALL_INPUT\";\n})(TurnCoverage || (TurnCoverage = {}));\n/** Specifies how the response should be scheduled in the conversation. */\nvar FunctionResponseScheduling;\n(function (FunctionResponseScheduling) {\n    /**\n     * This value is unused.\n     */\n    FunctionResponseScheduling[\"SCHEDULING_UNSPECIFIED\"] = \"SCHEDULING_UNSPECIFIED\";\n    /**\n     * Only add the result to the conversation context, do not interrupt or trigger generation.\n     */\n    FunctionResponseScheduling[\"SILENT\"] = \"SILENT\";\n    /**\n     * Add the result to the conversation context, and prompt to generate output without interrupting ongoing generation.\n     */\n    FunctionResponseScheduling[\"WHEN_IDLE\"] = \"WHEN_IDLE\";\n    /**\n     * Add the result to the conversation context, interrupt ongoing generation and prompt to generate output.\n     */\n    FunctionResponseScheduling[\"INTERRUPT\"] = \"INTERRUPT\";\n})(FunctionResponseScheduling || (FunctionResponseScheduling = {}));\n/** Scale of the generated music. */\nvar Scale;\n(function (Scale) {\n    /**\n     * Default value. This value is unused.\n     */\n    Scale[\"SCALE_UNSPECIFIED\"] = \"SCALE_UNSPECIFIED\";\n    /**\n     * C major or A minor.\n     */\n    Scale[\"C_MAJOR_A_MINOR\"] = \"C_MAJOR_A_MINOR\";\n    /**\n     * Db major or Bb minor.\n     */\n    Scale[\"D_FLAT_MAJOR_B_FLAT_MINOR\"] = \"D_FLAT_MAJOR_B_FLAT_MINOR\";\n    /**\n     * D major or B minor.\n     */\n    Scale[\"D_MAJOR_B_MINOR\"] = \"D_MAJOR_B_MINOR\";\n    /**\n     * Eb major or C minor\n     */\n    Scale[\"E_FLAT_MAJOR_C_MINOR\"] = \"E_FLAT_MAJOR_C_MINOR\";\n    /**\n     * E major or Db minor.\n     */\n    Scale[\"E_MAJOR_D_FLAT_MINOR\"] = \"E_MAJOR_D_FLAT_MINOR\";\n    /**\n     * F major or D minor.\n     */\n    Scale[\"F_MAJOR_D_MINOR\"] = \"F_MAJOR_D_MINOR\";\n    /**\n     * Gb major or Eb minor.\n     */\n    Scale[\"G_FLAT_MAJOR_E_FLAT_MINOR\"] = \"G_FLAT_MAJOR_E_FLAT_MINOR\";\n    /**\n     * G major or E minor.\n     */\n    Scale[\"G_MAJOR_E_MINOR\"] = \"G_MAJOR_E_MINOR\";\n    /**\n     * Ab major or F minor.\n     */\n    Scale[\"A_FLAT_MAJOR_F_MINOR\"] = \"A_FLAT_MAJOR_F_MINOR\";\n    /**\n     * A major or Gb minor.\n     */\n    Scale[\"A_MAJOR_G_FLAT_MINOR\"] = \"A_MAJOR_G_FLAT_MINOR\";\n    /**\n     * Bb major or G minor.\n     */\n    Scale[\"B_FLAT_MAJOR_G_MINOR\"] = \"B_FLAT_MAJOR_G_MINOR\";\n    /**\n     * B major or Ab minor.\n     */\n    Scale[\"B_MAJOR_A_FLAT_MINOR\"] = \"B_MAJOR_A_FLAT_MINOR\";\n})(Scale || (Scale = {}));\n/** The mode of music generation. */\nvar MusicGenerationMode;\n(function (MusicGenerationMode) {\n    /**\n     * Rely on the server default generation mode.\n     */\n    MusicGenerationMode[\"MUSIC_GENERATION_MODE_UNSPECIFIED\"] = \"MUSIC_GENERATION_MODE_UNSPECIFIED\";\n    /**\n     * Steer text prompts to regions of latent space with higher quality\n        music.\n     */\n    MusicGenerationMode[\"QUALITY\"] = \"QUALITY\";\n    /**\n     * Steer text prompts to regions of latent space with a larger\n        diversity of music.\n     */\n    MusicGenerationMode[\"DIVERSITY\"] = \"DIVERSITY\";\n    /**\n     * Steer text prompts to regions of latent space more likely to\n        generate music with vocals.\n     */\n    MusicGenerationMode[\"VOCALIZATION\"] = \"VOCALIZATION\";\n})(MusicGenerationMode || (MusicGenerationMode = {}));\n/** The playback control signal to apply to the music generation. */\nvar LiveMusicPlaybackControl;\n(function (LiveMusicPlaybackControl) {\n    /**\n     * This value is unused.\n     */\n    LiveMusicPlaybackControl[\"PLAYBACK_CONTROL_UNSPECIFIED\"] = \"PLAYBACK_CONTROL_UNSPECIFIED\";\n    /**\n     * Start generating the music.\n     */\n    LiveMusicPlaybackControl[\"PLAY\"] = \"PLAY\";\n    /**\n     * Hold the music generation. Use PLAY to resume from the current position.\n     */\n    LiveMusicPlaybackControl[\"PAUSE\"] = \"PAUSE\";\n    /**\n     * Stop the music generation and reset the context (prompts retained).\n        Use PLAY to restart the music generation.\n     */\n    LiveMusicPlaybackControl[\"STOP\"] = \"STOP\";\n    /**\n     * Reset the context of the music generation without stopping it.\n        Retains the current prompts and config.\n     */\n    LiveMusicPlaybackControl[\"RESET_CONTEXT\"] = \"RESET_CONTEXT\";\n})(LiveMusicPlaybackControl || (LiveMusicPlaybackControl = {}));\n/** Raw media bytes for function response.\n\n  Text should not be sent as raw bytes, use the FunctionResponse.response\n  field.\n   */\nclass FunctionResponseBlob {\n}\n/** URI based data for function response. */\nclass FunctionResponseFileData {\n}\n/** A datatype containing media that is part of a `FunctionResponse` message.\n\n  A `FunctionResponsePart` consists of data which has an associated datatype. A\n  `FunctionResponsePart` can only contain one of the accepted types in\n  `FunctionResponsePart.data`.\n\n  A `FunctionResponsePart` must have a fixed IANA MIME type identifying the\n  type and subtype of the media if the `inline_data` field is filled with raw\n  bytes.\n   */\nclass FunctionResponsePart {\n}\n/** A function response. */\nclass FunctionResponse {\n}\n/**\n * Creates a `Part` object from a `URI` string.\n */\nfunction createPartFromUri(uri, mimeType) {\n    return {\n        fileData: {\n            fileUri: uri,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `text` string.\n */\nfunction createPartFromText(text) {\n    return {\n        text: text,\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionCall` object.\n */\nfunction createPartFromFunctionCall(name, args) {\n    return {\n        functionCall: {\n            name: name,\n            args: args,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `FunctionResponse` object.\n */\nfunction createPartFromFunctionResponse(id, name, response) {\n    return {\n        functionResponse: {\n            id: id,\n            name: name,\n            response: response,\n        },\n    };\n}\n/**\n * Creates a `Part` object from a `base64` encoded `string`.\n */\nfunction createPartFromBase64(data, mimeType) {\n    return {\n        inlineData: {\n            data: data,\n            mimeType: mimeType,\n        },\n    };\n}\n/**\n * Creates a `Part` object from the `outcome` and `output` of a `CodeExecutionResult` object.\n */\nfunction createPartFromCodeExecutionResult(outcome, output) {\n    return {\n        codeExecutionResult: {\n            outcome: outcome,\n            output: output,\n        },\n    };\n}\n/**\n * Creates a `Part` object from the `code` and `language` of an `ExecutableCode` object.\n */\nfunction createPartFromExecutableCode(code, language) {\n    return {\n        executableCode: {\n            code: code,\n            language: language,\n        },\n    };\n}\nfunction _isPart(obj) {\n    if (typeof obj === 'object' && obj !== null) {\n        return ('fileData' in obj ||\n            'text' in obj ||\n            'functionCall' in obj ||\n            'functionResponse' in obj ||\n            'inlineData' in obj ||\n            'videoMetadata' in obj ||\n            'codeExecutionResult' in obj ||\n            'executableCode' in obj);\n    }\n    return false;\n}\nfunction _toParts(partOrString) {\n    const parts = [];\n    if (typeof partOrString === 'string') {\n        parts.push(createPartFromText(partOrString));\n    }\n    else if (_isPart(partOrString)) {\n        parts.push(partOrString);\n    }\n    else if (Array.isArray(partOrString)) {\n        if (partOrString.length === 0) {\n            throw new Error('partOrString cannot be an empty array');\n        }\n        for (const part of partOrString) {\n            if (typeof part === 'string') {\n                parts.push(createPartFromText(part));\n            }\n            else if (_isPart(part)) {\n                parts.push(part);\n            }\n            else {\n                throw new Error('element in PartUnion must be a Part object or string');\n            }\n        }\n    }\n    else {\n        throw new Error('partOrString must be a Part object, string, or array');\n    }\n    return parts;\n}\n/**\n * Creates a `Content` object with a user role from a `PartListUnion` object or `string`.\n */\nfunction createUserContent(partOrString) {\n    return {\n        role: 'user',\n        parts: _toParts(partOrString),\n    };\n}\n/**\n * Creates a `Content` object with a model role from a `PartListUnion` object or `string`.\n */\nfunction createModelContent(partOrString) {\n    return {\n        role: 'model',\n        parts: _toParts(partOrString),\n    };\n}\n/** A wrapper class for the http response. */\nclass HttpResponse {\n    constructor(response) {\n        // Process the headers.\n        const headers = {};\n        for (const pair of response.headers.entries()) {\n            headers[pair[0]] = pair[1];\n        }\n        this.headers = headers;\n        // Keep the original response.\n        this.responseInternal = response;\n    }\n    json() {\n        return this.responseInternal.json();\n    }\n}\n/** Content filter results for a prompt sent in the request. */\nclass GenerateContentResponsePromptFeedback {\n}\n/** Usage metadata about response(s). */\nclass GenerateContentResponseUsageMetadata {\n}\n/** Response message for PredictionService.GenerateContent. */\nclass GenerateContentResponse {\n    /**\n     * Returns the concatenation of all text parts from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the text from the first\n     * one will be returned.\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     * If there are thought parts in the response, the concatenation of all text\n     * parts excluding the thought parts will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'Why is the sky blue?',\n     * });\n     *\n     * console.debug(response.text);\n     * ```\n     */\n    get text() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning text from the first one.');\n        }\n        let text = '';\n        let anyTextPartText = false;\n        const nonTextParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartText = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartText ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the first candidate\n     * in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the inline data from the\n     * first one will be returned. If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning data from the first one.');\n        }\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) !== null && _h !== void 0 ? _h : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' &&\n                    (fieldValue !== null || fieldValue !== undefined)) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n    /**\n     * Returns the function calls from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the function calls from\n     * the first one will be returned.\n     * If there are no function calls in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const controlLightFunctionDeclaration: FunctionDeclaration = {\n     *   name: 'controlLight',\n     *   parameters: {\n     *   type: Type.OBJECT,\n     *   description: 'Set the brightness and color temperature of a room light.',\n     *   properties: {\n     *     brightness: {\n     *       type: Type.NUMBER,\n     *       description:\n     *         'Light level from 0 to 100. Zero is off and 100 is full brightness.',\n     *     },\n     *     colorTemperature: {\n     *       type: Type.STRING,\n     *       description:\n     *         'Color temperature of the light fixture which can be `daylight`, `cool` or `warm`.',\n     *     },\n     *   },\n     *   required: ['brightness', 'colorTemperature'],\n     *  };\n     *  const response = await ai.models.generateContent({\n     *     model: 'gemini-2.0-flash',\n     *     contents: 'Dim the lights so the room feels cozy and warm.',\n     *     config: {\n     *       tools: [{functionDeclarations: [controlLightFunctionDeclaration]}],\n     *       toolConfig: {\n     *         functionCallingConfig: {\n     *           mode: FunctionCallingConfigMode.ANY,\n     *           allowedFunctionNames: ['controlLight'],\n     *         },\n     *       },\n     *     },\n     *   });\n     *  console.debug(JSON.stringify(response.functionCalls));\n     * ```\n     */\n    get functionCalls() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning function calls from the first one.');\n        }\n        const functionCalls = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.functionCall).map((part) => part.functionCall).filter((functionCall) => functionCall !== undefined);\n        if ((functionCalls === null || functionCalls === void 0 ? void 0 : functionCalls.length) === 0) {\n            return undefined;\n        }\n        return functionCalls;\n    }\n    /**\n     * Returns the first executable code from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the executable code from\n     * the first one will be returned.\n     * If there are no executable code in the response, undefined will be\n     * returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.executableCode);\n     * ```\n     */\n    get executableCode() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning executable code from the first one.');\n        }\n        const executableCode = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.executableCode).map((part) => part.executableCode).filter((executableCode) => executableCode !== undefined);\n        if ((executableCode === null || executableCode === void 0 ? void 0 : executableCode.length) === 0) {\n            return undefined;\n        }\n        return (_j = executableCode === null || executableCode === void 0 ? void 0 : executableCode[0]) === null || _j === void 0 ? void 0 : _j.code;\n    }\n    /**\n     * Returns the first code execution result from the first candidate in the response.\n     *\n     * @remarks\n     * If there are multiple candidates in the response, the code execution result from\n     * the first one will be returned.\n     * If there are no code execution result in the response, undefined will be returned.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.generateContent({\n     *   model: 'gemini-2.0-flash',\n     *   contents:\n     *     'What is the sum of the first 50 prime numbers? Generate and run code for the calculation, and make sure you get all 50.'\n     *   config: {\n     *     tools: [{codeExecution: {}}],\n     *   },\n     * });\n     *\n     * console.debug(response.codeExecutionResult);\n     * ```\n     */\n    get codeExecutionResult() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        if (((_d = (_c = (_b = (_a = this.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content) === null || _c === void 0 ? void 0 : _c.parts) === null || _d === void 0 ? void 0 : _d.length) === 0) {\n            return undefined;\n        }\n        if (this.candidates && this.candidates.length > 1) {\n            console.warn('there are multiple candidates in the response, returning code execution result from the first one.');\n        }\n        const codeExecutionResult = (_h = (_g = (_f = (_e = this.candidates) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.parts) === null || _h === void 0 ? void 0 : _h.filter((part) => part.codeExecutionResult).map((part) => part.codeExecutionResult).filter((codeExecutionResult) => codeExecutionResult !== undefined);\n        if ((codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult.length) === 0) {\n            return undefined;\n        }\n        return (_j = codeExecutionResult === null || codeExecutionResult === void 0 ? void 0 : codeExecutionResult[0]) === null || _j === void 0 ? void 0 : _j.output;\n    }\n}\n/** Response for the embed_content method. */\nclass EmbedContentResponse {\n}\n/** The output images response. */\nclass GenerateImagesResponse {\n}\n/** Response for the request to edit an image. */\nclass EditImageResponse {\n}\nclass UpscaleImageResponse {\n}\n/** The output images response. */\nclass RecontextImageResponse {\n}\n/** The output images response. */\nclass SegmentImageResponse {\n}\nclass ListModelsResponse {\n}\nclass DeleteModelResponse {\n}\n/** Response for counting tokens. */\nclass CountTokensResponse {\n}\n/** Response for computing tokens. */\nclass ComputeTokensResponse {\n}\n/** Response with generated videos. */\nclass GenerateVideosResponse {\n}\n/** A video generation operation. */\nclass GenerateVideosOperation {\n    /**\n     * Instantiates an Operation of the same type as the one being called with the fields set from the API response.\n     * @internal\n     */\n    _fromAPIResponse({ apiResponse, isVertexAI, }) {\n        const operation = new GenerateVideosOperation();\n        let response;\n        const op = apiResponse;\n        if (isVertexAI) {\n            response = generateVideosOperationFromVertex$1(op);\n        }\n        else {\n            response = generateVideosOperationFromMldev$1(op);\n        }\n        Object.assign(operation, response);\n        return operation;\n    }\n}\n/** Response for the list tuning jobs method. */\nclass ListTuningJobsResponse {\n}\n/** Empty response for caches.delete method. */\nclass DeleteCachedContentResponse {\n}\nclass ListCachedContentsResponse {\n}\n/** Response for the list files method. */\nclass ListFilesResponse {\n}\n/** Response for the create file method. */\nclass CreateFileResponse {\n}\n/** Response for the delete file method. */\nclass DeleteFileResponse {\n}\n/** Config for `inlined_responses` parameter. */\nclass InlinedResponse {\n}\n/** Config for `response` parameter. */\nclass SingleEmbedContentResponse {\n}\n/** Config for `inlined_embedding_responses` parameter. */\nclass InlinedEmbedContentResponse {\n}\n/** Config for batches.list return value. */\nclass ListBatchJobsResponse {\n}\n/** Represents a single response in a replay. */\nclass ReplayResponse {\n}\n/** A raw reference image.\n\n  A raw reference image represents the base image to edit, provided by the user.\n  It can optionally be provided in addition to a mask reference image or\n  a style reference image.\n   */\nclass RawReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_RAW',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A mask reference image.\n\n  This encapsulates either a mask image provided by the user and configs for\n  the user provided mask, or only config parameters for the model to generate\n  a mask.\n\n  A mask image is an image whose non-zero values indicate where to edit the base\n  image. If the user provides a mask image, the mask must be in the same\n  dimensions as the raw image.\n   */\nclass MaskReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_MASK',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            maskImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A control reference image.\n\n  The image of the control reference image is either a control image provided\n  by the user, or a regular image which the backend will use to generate a\n  control image of. In the case of the latter, the\n  enable_control_image_computation field in the config should be set to True.\n\n  A control image is an image that represents a sketch image of areas for the\n  model to fill in based on the prompt.\n   */\nclass ControlReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTROL',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            controlImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A style reference image.\n\n  This encapsulates a style reference image provided by the user, and\n  additionally optional config parameters for the style reference image.\n\n  A raw reference image can also be provided as a destination for the style to\n  be applied to.\n   */\nclass StyleReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_STYLE',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            styleImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A subject reference image.\n\n  This encapsulates a subject reference image provided by the user, and\n  additionally optional config parameters for the subject reference image.\n\n  A raw reference image can also be provided as a destination for the subject to\n  be applied to.\n   */\nclass SubjectReferenceImage {\n    /* Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_SUBJECT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n            subjectImageConfig: this.config,\n        };\n        return referenceImageAPI;\n    }\n}\n/** A content reference image.\n\n  A content reference image represents a subject to reference (ex. person,\n  product, animal) provided by the user. It can optionally be provided in\n  addition to a style reference image (ex. background, style reference).\n   */\nclass ContentReferenceImage {\n    /** Internal method to convert to ReferenceImageAPIInternal. */\n    toReferenceImageAPI() {\n        const referenceImageAPI = {\n            referenceType: 'REFERENCE_TYPE_CONTENT',\n            referenceImage: this.referenceImage,\n            referenceId: this.referenceId,\n        };\n        return referenceImageAPI;\n    }\n}\n/** Response message for API call. */\nclass LiveServerMessage {\n    /**\n     * Returns the concatenation of all text parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-text parts in the response, the concatenation of all text\n     * parts will be returned, and a warning will be logged.\n     */\n    get text() {\n        var _a, _b, _c;\n        let text = '';\n        let anyTextPartFound = false;\n        const nonTextParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'text' &&\n                    fieldName !== 'thought' &&\n                    fieldValue !== null) {\n                    nonTextParts.push(fieldName);\n                }\n            }\n            if (typeof part.text === 'string') {\n                if (typeof part.thought === 'boolean' && part.thought) {\n                    continue;\n                }\n                anyTextPartFound = true;\n                text += part.text;\n            }\n        }\n        if (nonTextParts.length > 0) {\n            console.warn(`there are non-text parts ${nonTextParts} in the response, returning concatenation of all text parts. Please refer to the non text parts for a full response from model.`);\n        }\n        // part.text === '' is different from part.text is null\n        return anyTextPartFound ? text : undefined;\n    }\n    /**\n     * Returns the concatenation of all inline data parts from the server content if present.\n     *\n     * @remarks\n     * If there are non-inline data parts in the\n     * response, the concatenation of all inline data parts will be returned, and\n     * a warning will be logged.\n     */\n    get data() {\n        var _a, _b, _c;\n        let data = '';\n        const nonDataParts = [];\n        for (const part of (_c = (_b = (_a = this.serverContent) === null || _a === void 0 ? void 0 : _a.modelTurn) === null || _b === void 0 ? void 0 : _b.parts) !== null && _c !== void 0 ? _c : []) {\n            for (const [fieldName, fieldValue] of Object.entries(part)) {\n                if (fieldName !== 'inlineData' && fieldValue !== null) {\n                    nonDataParts.push(fieldName);\n                }\n            }\n            if (part.inlineData && typeof part.inlineData.data === 'string') {\n                data += atob(part.inlineData.data);\n            }\n        }\n        if (nonDataParts.length > 0) {\n            console.warn(`there are non-data parts ${nonDataParts} in the response, returning concatenation of all data parts. Please refer to the non data parts for a full response from model.`);\n        }\n        return data.length > 0 ? btoa(data) : undefined;\n    }\n}\n/** Client generated response to a `ToolCall` received from the server.\n\n  Individual `FunctionResponse` objects are matched to the respective\n  `FunctionCall` objects by the `id` field.\n\n  Note that in the unary and server-streaming GenerateContent APIs function\n  calling happens by exchanging the `Content` parts, while in the bidi\n  GenerateContent APIs function calling happens over this dedicated set of\n  messages.\n   */\nclass LiveClientToolResponse {\n}\n/** Parameters for sending tool responses to the live API. */\nclass LiveSendToolResponseParameters {\n    constructor() {\n        /** Tool responses to send to the session. */\n        this.functionResponses = [];\n    }\n}\n/** Response message for the LiveMusicClientMessage call. */\nclass LiveMusicServerMessage {\n    /**\n     * Returns the first audio chunk from the server content, if present.\n     *\n     * @remarks\n     * If there are no audio chunks in the response, undefined will be returned.\n     */\n    get audioChunk() {\n        if (this.serverContent &&\n            this.serverContent.audioChunks &&\n            this.serverContent.audioChunks.length > 0) {\n            return this.serverContent.audioChunks[0];\n        }\n        return undefined;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction tModel(apiClient, model) {\n    if (!model || typeof model !== 'string') {\n        throw new Error('model is required and must be a string');\n    }\n    if (apiClient.isVertexAI()) {\n        if (model.startsWith('publishers/') ||\n            model.startsWith('projects/') ||\n            model.startsWith('models/')) {\n            return model;\n        }\n        else if (model.indexOf('/') >= 0) {\n            const parts = model.split('/', 2);\n            return `publishers/${parts[0]}/models/${parts[1]}`;\n        }\n        else {\n            return `publishers/google/models/${model}`;\n        }\n    }\n    else {\n        if (model.startsWith('models/') || model.startsWith('tunedModels/')) {\n            return model;\n        }\n        else {\n            return `models/${model}`;\n        }\n    }\n}\nfunction tCachesModel(apiClient, model) {\n    const transformedModel = tModel(apiClient, model);\n    if (!transformedModel) {\n        return '';\n    }\n    if (transformedModel.startsWith('publishers/') && apiClient.isVertexAI()) {\n        // vertex caches only support model name start with projects.\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/${transformedModel}`;\n    }\n    else if (transformedModel.startsWith('models/') && apiClient.isVertexAI()) {\n        return `projects/${apiClient.getProject()}/locations/${apiClient.getLocation()}/publishers/google/${transformedModel}`;\n    }\n    else {\n        return transformedModel;\n    }\n}\nfunction tBlobs(blobs) {\n    if (Array.isArray(blobs)) {\n        return blobs.map((blob) => tBlob(blob));\n    }\n    else {\n        return [tBlob(blobs)];\n    }\n}\nfunction tBlob(blob) {\n    if (typeof blob === 'object' && blob !== null) {\n        return blob;\n    }\n    throw new Error(`Could not parse input as Blob. Unsupported blob type: ${typeof blob}`);\n}\nfunction tImageBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('image/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tAudioBlob(blob) {\n    const transformedBlob = tBlob(blob);\n    if (transformedBlob.mimeType &&\n        transformedBlob.mimeType.startsWith('audio/')) {\n        return transformedBlob;\n    }\n    throw new Error(`Unsupported mime type: ${transformedBlob.mimeType}`);\n}\nfunction tPart(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('PartUnion is required');\n    }\n    if (typeof origin === 'object') {\n        return origin;\n    }\n    if (typeof origin === 'string') {\n        return { text: origin };\n    }\n    throw new Error(`Unsupported part type: ${typeof origin}`);\n}\nfunction tParts(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('PartListUnion is required');\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tPart(item));\n    }\n    return [tPart(origin)];\n}\nfunction _isContent(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'parts' in origin &&\n        Array.isArray(origin.parts));\n}\nfunction _isFunctionCallPart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionCall' in origin);\n}\nfunction _isFunctionResponsePart(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'functionResponse' in origin);\n}\nfunction tContent(origin) {\n    if (origin === null || origin === undefined) {\n        throw new Error('ContentUnion is required');\n    }\n    if (_isContent(origin)) {\n        // _isContent is a utility function that checks if the\n        // origin is a Content.\n        return origin;\n    }\n    return {\n        role: 'user',\n        parts: tParts(origin),\n    };\n}\nfunction tContentsForEmbed(apiClient, origin) {\n    if (!origin) {\n        return [];\n    }\n    if (apiClient.isVertexAI() && Array.isArray(origin)) {\n        return origin.flatMap((item) => {\n            const content = tContent(item);\n            if (content.parts &&\n                content.parts.length > 0 &&\n                content.parts[0].text !== undefined) {\n                return [content.parts[0].text];\n            }\n            return [];\n        });\n    }\n    else if (apiClient.isVertexAI()) {\n        const content = tContent(origin);\n        if (content.parts &&\n            content.parts.length > 0 &&\n            content.parts[0].text !== undefined) {\n            return [content.parts[0].text];\n        }\n        return [];\n    }\n    if (Array.isArray(origin)) {\n        return origin.map((item) => tContent(item));\n    }\n    return [tContent(origin)];\n}\nfunction tContents(origin) {\n    if (origin === null ||\n        origin === undefined ||\n        (Array.isArray(origin) && origin.length === 0)) {\n        throw new Error('contents are required');\n    }\n    if (!Array.isArray(origin)) {\n        // If it's not an array, it's a single content or a single PartUnion.\n        if (_isFunctionCallPart(origin) || _isFunctionResponsePart(origin)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them in a Content object, specifying the role for them');\n        }\n        return [tContent(origin)];\n    }\n    const result = [];\n    const accumulatedParts = [];\n    const isContentArray = _isContent(origin[0]);\n    for (const item of origin) {\n        const isContent = _isContent(item);\n        if (isContent != isContentArray) {\n            throw new Error('Mixing Content and Parts is not supported, please group the parts into a the appropriate Content objects and specify the roles for them');\n        }\n        if (isContent) {\n            // `isContent` contains the result of _isContent, which is a utility\n            // function that checks if the item is a Content.\n            result.push(item);\n        }\n        else if (_isFunctionCallPart(item) || _isFunctionResponsePart(item)) {\n            throw new Error('To specify functionCall or functionResponse parts, please wrap them, and any other parts, in Content objects as appropriate, specifying the role for them');\n        }\n        else {\n            accumulatedParts.push(item);\n        }\n    }\n    if (!isContentArray) {\n        result.push({ role: 'user', parts: tParts(accumulatedParts) });\n    }\n    return result;\n}\n/*\nTransform the type field from an array of types to an array of anyOf fields.\nExample:\n  {type: ['STRING', 'NUMBER']}\nwill be transformed to\n  {anyOf: [{type: 'STRING'}, {type: 'NUMBER'}]}\n*/\nfunction flattenTypeArrayToAnyOf(typeList, resultingSchema) {\n    if (typeList.includes('null')) {\n        resultingSchema['nullable'] = true;\n    }\n    const listWithoutNull = typeList.filter((type) => type !== 'null');\n    if (listWithoutNull.length === 1) {\n        resultingSchema['type'] = Object.values(Type).includes(listWithoutNull[0].toUpperCase())\n            ? listWithoutNull[0].toUpperCase()\n            : Type.TYPE_UNSPECIFIED;\n    }\n    else {\n        resultingSchema['anyOf'] = [];\n        for (const i of listWithoutNull) {\n            resultingSchema['anyOf'].push({\n                'type': Object.values(Type).includes(i.toUpperCase())\n                    ? i.toUpperCase()\n                    : Type.TYPE_UNSPECIFIED,\n            });\n        }\n    }\n}\nfunction processJsonSchema(_jsonSchema) {\n    const genAISchema = {};\n    const schemaFieldNames = ['items'];\n    const listSchemaFieldNames = ['anyOf'];\n    const dictSchemaFieldNames = ['properties'];\n    if (_jsonSchema['type'] && _jsonSchema['anyOf']) {\n        throw new Error('type and anyOf cannot be both populated.');\n    }\n    /*\n    This is to handle the nullable array or object. The _jsonSchema will\n    be in the format of {anyOf: [{type: 'null'}, {type: 'object'}]}. The\n    logic is to check if anyOf has 2 elements and one of the element is null,\n    if so, the anyOf field is unnecessary, so we need to get rid of the anyOf\n    field and make the schema nullable. Then use the other element as the new\n    _jsonSchema for processing. This is because the backend doesn't have a null\n    type.\n    This has to be checked before we process any other fields.\n    For example:\n      const objectNullable = z.object({\n        nullableArray: z.array(z.string()).nullable(),\n      });\n    Will have the raw _jsonSchema as:\n    {\n      type: 'OBJECT',\n      properties: {\n          nullableArray: {\n             anyOf: [\n                {type: 'null'},\n                {\n                  type: 'array',\n                  items: {type: 'string'},\n                },\n              ],\n          }\n      },\n      required: [ 'nullableArray' ],\n    }\n    Will result in following schema compatible with Gemini API:\n      {\n        type: 'OBJECT',\n        properties: {\n           nullableArray: {\n              nullable: true,\n              type: 'ARRAY',\n              items: {type: 'string'},\n           }\n        },\n        required: [ 'nullableArray' ],\n      }\n    */\n    const incomingAnyOf = _jsonSchema['anyOf'];\n    if (incomingAnyOf != null && incomingAnyOf.length == 2) {\n        if (incomingAnyOf[0]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[1];\n        }\n        else if (incomingAnyOf[1]['type'] === 'null') {\n            genAISchema['nullable'] = true;\n            _jsonSchema = incomingAnyOf[0];\n        }\n    }\n    if (_jsonSchema['type'] instanceof Array) {\n        flattenTypeArrayToAnyOf(_jsonSchema['type'], genAISchema);\n    }\n    for (const [fieldName, fieldValue] of Object.entries(_jsonSchema)) {\n        // Skip if the fieldvalue is undefined or null.\n        if (fieldValue == null) {\n            continue;\n        }\n        if (fieldName == 'type') {\n            if (fieldValue === 'null') {\n                throw new Error('type: null can not be the only possible type for the field.');\n            }\n            if (fieldValue instanceof Array) {\n                // we have already handled the type field with array of types in the\n                // beginning of this function.\n                continue;\n            }\n            genAISchema['type'] = Object.values(Type).includes(fieldValue.toUpperCase())\n                ? fieldValue.toUpperCase()\n                : Type.TYPE_UNSPECIFIED;\n        }\n        else if (schemaFieldNames.includes(fieldName)) {\n            genAISchema[fieldName] =\n                processJsonSchema(fieldValue);\n        }\n        else if (listSchemaFieldNames.includes(fieldName)) {\n            const listSchemaFieldValue = [];\n            for (const item of fieldValue) {\n                if (item['type'] == 'null') {\n                    genAISchema['nullable'] = true;\n                    continue;\n                }\n                listSchemaFieldValue.push(processJsonSchema(item));\n            }\n            genAISchema[fieldName] =\n                listSchemaFieldValue;\n        }\n        else if (dictSchemaFieldNames.includes(fieldName)) {\n            const dictSchemaFieldValue = {};\n            for (const [key, value] of Object.entries(fieldValue)) {\n                dictSchemaFieldValue[key] = processJsonSchema(value);\n            }\n            genAISchema[fieldName] =\n                dictSchemaFieldValue;\n        }\n        else {\n            // additionalProperties is not included in JSONSchema, skipping it.\n            if (fieldName === 'additionalProperties') {\n                continue;\n            }\n            genAISchema[fieldName] = fieldValue;\n        }\n    }\n    return genAISchema;\n}\n// we take the unknown in the schema field because we want enable user to pass\n// the output of major schema declaration tools without casting. Tools such as\n// zodToJsonSchema, typebox, zodToJsonSchema function can return JsonSchema7Type\n// or object, see details in\n// https://github.com/StefanTerdell/zod-to-json-schema/blob/70525efe555cd226691e093d171370a3b10921d1/src/zodToJsonSchema.ts#L7\n// typebox can return unknown, see details in\n// https://github.com/sinclairzx81/typebox/blob/5a5431439f7d5ca6b494d0d18fbfd7b1a356d67c/src/type/create/type.ts#L35\n// Note: proper json schemas with the $schema field set never arrive to this\n// transformer. Schemas with $schema are routed to the equivalent API json\n// schema field.\nfunction tSchema(schema) {\n    return processJsonSchema(schema);\n}\nfunction tSpeechConfig(speechConfig) {\n    if (typeof speechConfig === 'object') {\n        return speechConfig;\n    }\n    else if (typeof speechConfig === 'string') {\n        return {\n            voiceConfig: {\n                prebuiltVoiceConfig: {\n                    voiceName: speechConfig,\n                },\n            },\n        };\n    }\n    else {\n        throw new Error(`Unsupported speechConfig type: ${typeof speechConfig}`);\n    }\n}\nfunction tLiveSpeechConfig(speechConfig) {\n    if ('multiSpeakerVoiceConfig' in speechConfig) {\n        throw new Error('multiSpeakerVoiceConfig is not supported in the live API.');\n    }\n    return speechConfig;\n}\nfunction tTool(tool) {\n    if (tool.functionDeclarations) {\n        for (const functionDeclaration of tool.functionDeclarations) {\n            if (functionDeclaration.parameters) {\n                if (!Object.keys(functionDeclaration.parameters).includes('$schema')) {\n                    functionDeclaration.parameters = processJsonSchema(functionDeclaration.parameters);\n                }\n                else {\n                    if (!functionDeclaration.parametersJsonSchema) {\n                        functionDeclaration.parametersJsonSchema =\n                            functionDeclaration.parameters;\n                        delete functionDeclaration.parameters;\n                    }\n                }\n            }\n            if (functionDeclaration.response) {\n                if (!Object.keys(functionDeclaration.response).includes('$schema')) {\n                    functionDeclaration.response = processJsonSchema(functionDeclaration.response);\n                }\n                else {\n                    if (!functionDeclaration.responseJsonSchema) {\n                        functionDeclaration.responseJsonSchema =\n                            functionDeclaration.response;\n                        delete functionDeclaration.response;\n                    }\n                }\n            }\n        }\n    }\n    return tool;\n}\nfunction tTools(tools) {\n    // Check if the incoming type is defined.\n    if (tools === undefined || tools === null) {\n        throw new Error('tools is required');\n    }\n    if (!Array.isArray(tools)) {\n        throw new Error('tools is required and must be an array of Tools');\n    }\n    const result = [];\n    for (const tool of tools) {\n        result.push(tool);\n    }\n    return result;\n}\n/**\n * Prepends resource name with project, location, resource_prefix if needed.\n *\n * @param client The API client.\n * @param resourceName The resource name.\n * @param resourcePrefix The resource prefix.\n * @param splitsAfterPrefix The number of splits after the prefix.\n * @returns The completed resource name.\n *\n * Examples:\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/bar/locations/us-west1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'projects/foo/locations/us-central1/cachedContents/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = True\n * client.project = 'bar'\n * client.location = 'us-west1'\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns: 'projects/foo/locations/us-central1/cachedContents/123'\n * ```\n *\n * ```\n * resource_name = '123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * returns 'cachedContents/123'\n * ```\n *\n * ```\n * resource_name = 'some/wrong/cachedContents/resource/name/123'\n * resource_prefix = 'cachedContents'\n * splits_after_prefix = 1\n * client.vertexai = False\n * # client.vertexai = True\n * _resource_name(client, resource_name, resource_prefix, splits_after_prefix)\n * -> 'some/wrong/resource/name/123'\n * ```\n */\nfunction resourceName(client, resourceName, resourcePrefix, splitsAfterPrefix = 1) {\n    const shouldAppendPrefix = !resourceName.startsWith(`${resourcePrefix}/`) &&\n        resourceName.split('/').length === splitsAfterPrefix;\n    if (client.isVertexAI()) {\n        if (resourceName.startsWith('projects/')) {\n            return resourceName;\n        }\n        else if (resourceName.startsWith('locations/')) {\n            return `projects/${client.getProject()}/${resourceName}`;\n        }\n        else if (resourceName.startsWith(`${resourcePrefix}/`)) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourceName}`;\n        }\n        else if (shouldAppendPrefix) {\n            return `projects/${client.getProject()}/locations/${client.getLocation()}/${resourcePrefix}/${resourceName}`;\n        }\n        else {\n            return resourceName;\n        }\n    }\n    if (shouldAppendPrefix) {\n        return `${resourcePrefix}/${resourceName}`;\n    }\n    return resourceName;\n}\nfunction tCachedContentName(apiClient, name) {\n    if (typeof name !== 'string') {\n        throw new Error('name must be a string');\n    }\n    return resourceName(apiClient, name, 'cachedContents');\n}\nfunction tTuningJobStatus(status) {\n    switch (status) {\n        case 'STATE_UNSPECIFIED':\n            return 'JOB_STATE_UNSPECIFIED';\n        case 'CREATING':\n            return 'JOB_STATE_RUNNING';\n        case 'ACTIVE':\n            return 'JOB_STATE_SUCCEEDED';\n        case 'FAILED':\n            return 'JOB_STATE_FAILED';\n        default:\n            return status;\n    }\n}\nfunction tBytes(fromImageBytes) {\n    return tBytes$1(fromImageBytes);\n}\nfunction _isFile(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'name' in origin);\n}\nfunction isGeneratedVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'video' in origin);\n}\nfunction isVideo(origin) {\n    return (origin !== null &&\n        origin !== undefined &&\n        typeof origin === 'object' &&\n        'uri' in origin);\n}\nfunction tFileName(fromName) {\n    var _a;\n    let name;\n    if (_isFile(fromName)) {\n        name = fromName.name;\n    }\n    if (isVideo(fromName)) {\n        name = fromName.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (isGeneratedVideo(fromName)) {\n        name = (_a = fromName.video) === null || _a === void 0 ? void 0 : _a.uri;\n        if (name === undefined) {\n            return undefined;\n        }\n    }\n    if (typeof fromName === 'string') {\n        name = fromName;\n    }\n    if (name === undefined) {\n        throw new Error('Could not extract file name from the provided input.');\n    }\n    if (name.startsWith('https://')) {\n        const suffix = name.split('files/')[1];\n        const match = suffix.match(/[a-z0-9]+/);\n        if (match === null) {\n            throw new Error(`Could not extract file name from URI ${name}`);\n        }\n        name = match[0];\n    }\n    else if (name.startsWith('files/')) {\n        name = name.split('files/')[1];\n    }\n    return name;\n}\nfunction tModelsUrl(apiClient, baseModels) {\n    let res;\n    if (apiClient.isVertexAI()) {\n        res = baseModels ? 'publishers/google/models' : 'models';\n    }\n    else {\n        res = baseModels ? 'models' : 'tunedModels';\n    }\n    return res;\n}\nfunction tExtractModels(response) {\n    for (const key of ['models', 'tunedModels', 'publisherModels']) {\n        if (hasField(response, key)) {\n            return response[key];\n        }\n    }\n    return [];\n}\nfunction hasField(data, fieldName) {\n    return data !== null && typeof data === 'object' && fieldName in data;\n}\nfunction mcpToGeminiTool(mcpTool, config = {}) {\n    const mcpToolSchema = mcpTool;\n    const functionDeclaration = {\n        name: mcpToolSchema['name'],\n        description: mcpToolSchema['description'],\n        parametersJsonSchema: mcpToolSchema['inputSchema'],\n    };\n    if (mcpToolSchema['outputSchema']) {\n        functionDeclaration['responseJsonSchema'] = mcpToolSchema['outputSchema'];\n    }\n    if (config.behavior) {\n        functionDeclaration['behavior'] = config.behavior;\n    }\n    const geminiTool = {\n        functionDeclarations: [\n            functionDeclaration,\n        ],\n    };\n    return geminiTool;\n}\n/**\n * Converts a list of MCP tools to a single Gemini tool with a list of function\n * declarations.\n */\nfunction mcpToolsToGeminiTool(mcpTools, config = {}) {\n    const functionDeclarations = [];\n    const toolNames = new Set();\n    for (const mcpTool of mcpTools) {\n        const mcpToolName = mcpTool.name;\n        if (toolNames.has(mcpToolName)) {\n            throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n        }\n        toolNames.add(mcpToolName);\n        const geminiTool = mcpToGeminiTool(mcpTool, config);\n        if (geminiTool.functionDeclarations) {\n            functionDeclarations.push(...geminiTool.functionDeclarations);\n        }\n    }\n    return { functionDeclarations: functionDeclarations };\n}\n// Transforms a source input into a BatchJobSource object with validation.\nfunction tBatchJobSource(client, src) {\n    let sourceObj;\n    if (typeof src === 'string') {\n        if (client.isVertexAI()) {\n            if (src.startsWith('gs://')) {\n                sourceObj = { format: 'jsonl', gcsUri: [src] };\n            }\n            else if (src.startsWith('bq://')) {\n                sourceObj = { format: 'bigquery', bigqueryUri: src };\n            }\n            else {\n                throw new Error(`Unsupported string source for Vertex AI: ${src}`);\n            }\n        }\n        else {\n            // MLDEV\n            if (src.startsWith('files/')) {\n                sourceObj = { fileName: src }; // Default to fileName for string input\n            }\n            else {\n                throw new Error(`Unsupported string source for Gemini API: ${src}`);\n            }\n        }\n    }\n    else if (Array.isArray(src)) {\n        if (client.isVertexAI()) {\n            throw new Error('InlinedRequest[] is not supported in Vertex AI.');\n        }\n        sourceObj = { inlinedRequests: src };\n    }\n    else {\n        // It's already a BatchJobSource object\n        sourceObj = src;\n    }\n    // Validation logic\n    const vertexSourcesCount = [sourceObj.gcsUri, sourceObj.bigqueryUri].filter(Boolean).length;\n    const mldevSourcesCount = [\n        sourceObj.inlinedRequests,\n        sourceObj.fileName,\n    ].filter(Boolean).length;\n    if (client.isVertexAI()) {\n        if (mldevSourcesCount > 0 || vertexSourcesCount !== 1) {\n            throw new Error('Exactly one of `gcsUri` or `bigqueryUri` must be set for Vertex AI.');\n        }\n    }\n    else {\n        // MLDEV\n        if (vertexSourcesCount > 0 || mldevSourcesCount !== 1) {\n            throw new Error('Exactly one of `inlinedRequests`, `fileName`, ' +\n                'must be set for Gemini API.');\n        }\n    }\n    return sourceObj;\n}\nfunction tBatchJobDestination(dest) {\n    if (typeof dest !== 'string') {\n        return dest;\n    }\n    const destString = dest;\n    if (destString.startsWith('gs://')) {\n        return {\n            format: 'jsonl',\n            gcsUri: destString,\n        };\n    }\n    else if (destString.startsWith('bq://')) {\n        return {\n            format: 'bigquery',\n            bigqueryUri: destString,\n        };\n    }\n    else {\n        throw new Error(`Unsupported destination: ${destString}`);\n    }\n}\nfunction tRecvBatchJobDestination(dest) {\n    // Ensure dest is a non-null object before proceeding.\n    if (typeof dest !== 'object' || dest === null) {\n        // If the input is not an object, it cannot be a valid BatchJobDestination\n        // based on the operations performed. Return it cast, or handle as an error.\n        // Casting an empty object might be a safe default.\n        return {};\n    }\n    // Cast to Record<string, unknown> to allow string property access.\n    const obj = dest;\n    // Safely access nested properties.\n    const inlineResponsesVal = obj['inlinedResponses'];\n    if (typeof inlineResponsesVal !== 'object' || inlineResponsesVal === null) {\n        return dest;\n    }\n    const inlineResponsesObj = inlineResponsesVal;\n    const responsesArray = inlineResponsesObj['inlinedResponses'];\n    if (!Array.isArray(responsesArray) || responsesArray.length === 0) {\n        return dest;\n    }\n    // Check if any response has the 'embedding' property.\n    let hasEmbedding = false;\n    for (const responseItem of responsesArray) {\n        if (typeof responseItem !== 'object' || responseItem === null) {\n            continue;\n        }\n        const responseItemObj = responseItem;\n        const responseVal = responseItemObj['response'];\n        if (typeof responseVal !== 'object' || responseVal === null) {\n            continue;\n        }\n        const responseObj = responseVal;\n        // Check for the existence of the 'embedding' key.\n        if (responseObj['embedding'] !== undefined) {\n            hasEmbedding = true;\n            break;\n        }\n    }\n    // Perform the transformation if an embedding was found.\n    if (hasEmbedding) {\n        obj['inlinedEmbedContentResponses'] = obj['inlinedResponses'];\n        delete obj['inlinedResponses'];\n    }\n    // Cast the (potentially) modified object to the target type.\n    return dest;\n}\nfunction tBatchJobName(apiClient, name) {\n    const nameString = name;\n    if (!apiClient.isVertexAI()) {\n        const mldevPattern = /batches\\/[^/]+$/;\n        if (mldevPattern.test(nameString)) {\n            return nameString.split('/').pop();\n        }\n        else {\n            throw new Error(`Invalid batch job name: ${nameString}.`);\n        }\n    }\n    const vertexPattern = /^projects\\/[^/]+\\/locations\\/[^/]+\\/batchPredictionJobs\\/[^/]+$/;\n    if (vertexPattern.test(nameString)) {\n        return nameString.split('/').pop();\n    }\n    else if (/^\\d+$/.test(nameString)) {\n        return nameString;\n    }\n    else {\n        throw new Error(`Invalid batch job name: ${nameString}.`);\n    }\n}\nfunction tJobState(state) {\n    const stateString = state;\n    if (stateString === 'BATCH_STATE_UNSPECIFIED') {\n        return 'JOB_STATE_UNSPECIFIED';\n    }\n    else if (stateString === 'BATCH_STATE_PENDING') {\n        return 'JOB_STATE_PENDING';\n    }\n    else if (stateString === 'BATCH_STATE_RUNNING') {\n        return 'JOB_STATE_RUNNING';\n    }\n    else if (stateString === 'BATCH_STATE_SUCCEEDED') {\n        return 'JOB_STATE_SUCCEEDED';\n    }\n    else if (stateString === 'BATCH_STATE_FAILED') {\n        return 'JOB_STATE_FAILED';\n    }\n    else if (stateString === 'BATCH_STATE_CANCELLED') {\n        return 'JOB_STATE_CANCELLED';\n    }\n    else if (stateString === 'BATCH_STATE_EXPIRED') {\n        return 'JOB_STATE_EXPIRED';\n    }\n    else {\n        return stateString;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction batchJobDestinationFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['responsesFile']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedResponses = getValueByPath(fromObject, [\n        'inlinedResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedResponses != null) {\n        let transformedList = fromInlinedResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['inlinedResponses'], transformedList);\n    }\n    const fromInlinedEmbedContentResponses = getValueByPath(fromObject, [\n        'inlinedEmbedContentResponses',\n        'inlinedResponses',\n    ]);\n    if (fromInlinedEmbedContentResponses != null) {\n        let transformedList = fromInlinedEmbedContentResponses;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedEmbedContentResponseFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['inlinedEmbedContentResponses'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobDestinationFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['predictionsFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, [\n        'gcsDestination',\n        'outputUriPrefix',\n    ]);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigqueryDestination',\n        'outputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobDestinationToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['predictionsFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsDestination', 'outputUriPrefix'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryDestination', 'outputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedResponses']) !== undefined) {\n        throw new Error('inlinedResponses parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedEmbedContentResponses']) !==\n        undefined) {\n        throw new Error('inlinedEmbedContentResponses parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction batchJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, [\n        'metadata',\n        'displayName',\n    ]);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['metadata', 'state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, [\n        'metadata',\n        'createTime',\n    ]);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'metadata',\n        'endTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, [\n        'metadata',\n        'updateTime',\n    ]);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['metadata', 'model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromDest = getValueByPath(fromObject, ['metadata', 'output']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromMldev(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tJobState(fromState));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], jobErrorFromVertex(fromError));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromSrc = getValueByPath(fromObject, ['inputConfig']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['src'], batchJobSourceFromVertex(fromSrc));\n    }\n    const fromDest = getValueByPath(fromObject, ['outputConfig']);\n    if (fromDest != null) {\n        setValueByPath(toObject, ['dest'], batchJobDestinationFromVertex(tRecvBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction batchJobSourceFromVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['instancesFormat']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsSource', 'uris']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, [\n        'bigquerySource',\n        'inputUri',\n    ]);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigqueryUri'], fromBigqueryUri);\n    }\n    return toObject;\n}\nfunction batchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['format']) !== undefined) {\n        throw new Error('format parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['bigqueryUri']) !== undefined) {\n        throw new Error('bigqueryUri parameter is not supported in Gemini API.');\n    }\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['fileName'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        let transformedList = fromInlinedRequests;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return inlinedRequestToMldev(apiClient, item);\n            });\n        }\n        setValueByPath(toObject, ['requests', 'requests'], transformedList);\n    }\n    return toObject;\n}\nfunction batchJobSourceToVertex(fromObject) {\n    const toObject = {};\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['instancesFormat'], fromFormat);\n    }\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsSource', 'uris'], fromGcsUri);\n    }\n    const fromBigqueryUri = getValueByPath(fromObject, ['bigqueryUri']);\n    if (fromBigqueryUri != null) {\n        setValueByPath(toObject, ['bigquerySource', 'inputUri'], fromBigqueryUri);\n    }\n    if (getValueByPath(fromObject, ['fileName']) !== undefined) {\n        throw new Error('fileName parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['inlinedRequests']) !== undefined) {\n        throw new Error('inlinedRequests parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction blobFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction cancelBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction candidateFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], contentFromMldev$2(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev$1(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], urlContextMetadataFromMldev$2(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        setValueByPath(toObject, ['citations'], fromCitations);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$4(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, ['values']);\n    if (fromValues != null) {\n        setValueByPath(toObject, ['values'], fromValues);\n    }\n    return toObject;\n}\nfunction contentFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentToMldev$4(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    if (getValueByPath(fromObject, ['dest']) !== undefined) {\n        throw new Error('dest parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createBatchJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDest = getValueByPath(fromObject, ['dest']);\n    if (parentObject !== undefined && fromDest != null) {\n        setValueByPath(parentObject, ['outputConfig'], batchJobDestinationToVertex(tBatchJobDestination(fromDest)));\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], batchJobSourceToMldev(apiClient, tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['inputConfig'], batchJobSourceToVertex(tBatchJobSource(apiClient, fromSrc)));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createBatchJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['batch', 'displayName'], fromDisplayName);\n    }\n    return toObject;\n}\nfunction createEmbeddingsBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSrc = getValueByPath(fromObject, ['src']);\n    if (fromSrc != null) {\n        setValueByPath(toObject, ['batch', 'inputConfig'], embeddingsBatchJobSourceToMldev(apiClient, fromSrc));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createEmbeddingsBatchJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction deleteResourceJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], jobErrorFromVertex(fromError));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$4(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction embedContentBatchToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        setValueByPath(toObject, ['requests[]', 'request', 'content'], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], embedContentConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embeddingsBatchJobSourceToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromFileName = getValueByPath(fromObject, ['fileName']);\n    if (fromFileName != null) {\n        setValueByPath(toObject, ['file_name'], fromFileName);\n    }\n    const fromInlinedRequests = getValueByPath(fromObject, [\n        'inlinedRequests',\n    ]);\n    if (fromInlinedRequests != null) {\n        setValueByPath(toObject, ['requests'], embedContentBatchToMldev(apiClient, fromInlinedRequests));\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$4(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$4(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$4(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, ['behavior']);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, ['behavior'], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev$1(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$4(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], schemaToMldev$1(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev$1(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$4(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev$2(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToMldev$3(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], thinkingConfigToMldev$3(fromThinkingConfig));\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToMldev$1(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getBatchJobParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tBatchJobName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToMldev$4(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$4(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToMldev$4(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction imageConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    return toObject;\n}\nfunction inlinedEmbedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], singleEmbedContentResponseFromMldev(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction inlinedRequestToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['request', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['request', 'contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['request', 'generationConfig'], generateContentConfigToMldev$1(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction inlinedResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateContentResponseFromMldev$1(fromResponse));\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], jobErrorFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction intervalToMldev$4(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction jobErrorFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, ['details']);\n    if (fromDetails != null) {\n        setValueByPath(toObject, ['details'], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, ['code']);\n    if (fromCode != null) {\n        setValueByPath(toObject, ['code'], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, ['message']);\n    if (fromMessage != null) {\n        setValueByPath(toObject, ['message'], fromMessage);\n    }\n    return toObject;\n}\nfunction jobErrorFromVertex(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, ['details']);\n    if (fromDetails != null) {\n        setValueByPath(toObject, ['details'], fromDetails);\n    }\n    const fromCode = getValueByPath(fromObject, ['code']);\n    if (fromCode != null) {\n        setValueByPath(toObject, ['code'], fromCode);\n    }\n    const fromMessage = getValueByPath(fromObject, ['message']);\n    if (fromMessage != null) {\n        setValueByPath(toObject, ['message'], fromMessage);\n    }\n    return toObject;\n}\nfunction latLngToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, ['latitude']);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, ['latitude'], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, ['longitude']);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, ['longitude'], fromLongitude);\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    if (getValueByPath(fromObject, ['filter']) !== undefined) {\n        throw new Error('filter parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction listBatchJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listBatchJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, ['operations']);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listBatchJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromBatchJobs = getValueByPath(fromObject, [\n        'batchPredictionJobs',\n    ]);\n    if (fromBatchJobs != null) {\n        let transformedList = fromBatchJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return batchJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['batchJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        'speakerVoiceConfigs',\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return speakerVoiceConfigToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, ['speakerVoiceConfigs'], transformedList);\n    }\n    return toObject;\n}\nfunction partFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataFromMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobFromMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataFromMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallFromMldev$2(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partToMldev$4(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToMldev$4(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$4(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$4(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$4(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, ['voiceName']);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, ['voiceName'], fromVoiceName);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, ['latLng']);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, ['latLng'], latLngToMldev$2(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction schemaToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, ['anyOf']);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, ['anyOf'], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, ['default']);\n    if (fromDefault != null) {\n        setValueByPath(toObject, ['default'], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, ['enum']);\n    if (fromEnum != null) {\n        setValueByPath(toObject, ['enum'], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, ['example']);\n    if (fromExample != null) {\n        setValueByPath(toObject, ['example'], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, ['items']);\n    if (fromItems != null) {\n        setValueByPath(toObject, ['items'], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, ['maxItems']);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, ['maxItems'], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, ['maxLength']);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, ['maxLength'], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        'maxProperties',\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, ['maxProperties'], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, ['maximum']);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, ['maximum'], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, ['minItems']);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, ['minItems'], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, ['minLength']);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, ['minLength'], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        'minProperties',\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, ['minProperties'], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, ['minimum']);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, ['minimum'], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, ['nullable']);\n    if (fromNullable != null) {\n        setValueByPath(toObject, ['nullable'], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, ['pattern']);\n    if (fromPattern != null) {\n        setValueByPath(toObject, ['pattern'], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, ['properties']);\n    if (fromProperties != null) {\n        setValueByPath(toObject, ['properties'], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        'propertyOrdering',\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, ['propertyOrdering'], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, ['required']);\n    if (fromRequired != null) {\n        setValueByPath(toObject, ['required'], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (fromTitle != null) {\n        setValueByPath(toObject, ['title'], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, ['type']);\n    if (fromType != null) {\n        setValueByPath(toObject, ['type'], fromType);\n    }\n    return toObject;\n}\nfunction singleEmbedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromEmbedding = getValueByPath(fromObject, ['embedding']);\n    if (fromEmbedding != null) {\n        setValueByPath(toObject, ['embedding'], contentEmbeddingFromMldev$1(fromEmbedding));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, ['speaker']);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, ['speaker'], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev$3(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        'multiSpeakerVoiceConfig',\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, ['multiSpeakerVoiceConfig'], multiSpeakerVoiceConfigToMldev$3(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        'includeThoughts',\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        'thinkingBudget',\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, ['thinkingBudget'], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev$2(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], retrievalConfigToMldev$2(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToMldev$4(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$4(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToMldev$4(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['googleMaps']) !== undefined) {\n        throw new Error('googleMaps parameter is not supported in Gemini API.');\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToMldev$4());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToMldev$4(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, ['urlMetadata']);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return urlMetadataFromMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['urlMetadata'], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$4() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, ['retrievedUrl']);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, ['retrievedUrl'], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        'urlRetrievalStatus',\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, ['urlRetrievalStatus'], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$4(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        'prebuiltVoiceConfig',\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, ['prebuiltVoiceConfig'], prebuiltVoiceConfigToMldev$3(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nvar PagedItem;\n(function (PagedItem) {\n    PagedItem[\"PAGED_ITEM_BATCH_JOBS\"] = \"batchJobs\";\n    PagedItem[\"PAGED_ITEM_MODELS\"] = \"models\";\n    PagedItem[\"PAGED_ITEM_TUNING_JOBS\"] = \"tuningJobs\";\n    PagedItem[\"PAGED_ITEM_FILES\"] = \"files\";\n    PagedItem[\"PAGED_ITEM_CACHED_CONTENTS\"] = \"cachedContents\";\n})(PagedItem || (PagedItem = {}));\n/**\n * Pager class for iterating through paginated results.\n */\nclass Pager {\n    constructor(name, request, response, params) {\n        this.pageInternal = [];\n        this.paramsInternal = {};\n        this.requestInternal = request;\n        this.init(name, response, params);\n    }\n    init(name, response, params) {\n        var _a, _b;\n        this.nameInternal = name;\n        this.pageInternal = response[this.nameInternal] || [];\n        this.sdkHttpResponseInternal = response === null || response === void 0 ? void 0 : response.sdkHttpResponse;\n        this.idxInternal = 0;\n        let requestParams = { config: {} };\n        if (!params || Object.keys(params).length === 0) {\n            requestParams = { config: {} };\n        }\n        else if (typeof params === 'object') {\n            requestParams = Object.assign({}, params);\n        }\n        else {\n            requestParams = params;\n        }\n        if (requestParams['config']) {\n            requestParams['config']['pageToken'] = response['nextPageToken'];\n        }\n        this.paramsInternal = requestParams;\n        this.pageInternalSize =\n            (_b = (_a = requestParams['config']) === null || _a === void 0 ? void 0 : _a['pageSize']) !== null && _b !== void 0 ? _b : this.pageInternal.length;\n    }\n    initNextPage(response) {\n        this.init(this.nameInternal, response, this.paramsInternal);\n    }\n    /**\n     * Returns the current page, which is a list of items.\n     *\n     * @remarks\n     * The first page is retrieved when the pager is created. The returned list of\n     * items could be a subset of the entire list.\n     */\n    get page() {\n        return this.pageInternal;\n    }\n    /**\n     * Returns the type of paged item (for example, ``batch_jobs``).\n     */\n    get name() {\n        return this.nameInternal;\n    }\n    /**\n     * Returns the length of the page fetched each time by this pager.\n     *\n     * @remarks\n     * The number of items in the page is less than or equal to the page length.\n     */\n    get pageSize() {\n        return this.pageInternalSize;\n    }\n    /**\n     * Returns the headers of the API response.\n     */\n    get sdkHttpResponse() {\n        return this.sdkHttpResponseInternal;\n    }\n    /**\n     * Returns the parameters when making the API request for the next page.\n     *\n     * @remarks\n     * Parameters contain a set of optional configs that can be\n     * used to customize the API request. For example, the `pageToken` parameter\n     * contains the token to request the next page.\n     */\n    get params() {\n        return this.paramsInternal;\n    }\n    /**\n     * Returns the total number of items in the current page.\n     */\n    get pageLength() {\n        return this.pageInternal.length;\n    }\n    /**\n     * Returns the item at the given index.\n     */\n    getItem(index) {\n        return this.pageInternal[index];\n    }\n    /**\n     * Returns an async iterator that support iterating through all items\n     * retrieved from the API.\n     *\n     * @remarks\n     * The iterator will automatically fetch the next page if there are more items\n     * to fetch from the API.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * for await (const file of pager) {\n     *   console.log(file.name);\n     * }\n     * ```\n     */\n    [Symbol.asyncIterator]() {\n        return {\n            next: async () => {\n                if (this.idxInternal >= this.pageLength) {\n                    if (this.hasNextPage()) {\n                        await this.nextPage();\n                    }\n                    else {\n                        return { value: undefined, done: true };\n                    }\n                }\n                const item = this.getItem(this.idxInternal);\n                this.idxInternal += 1;\n                return { value: item, done: false };\n            },\n            return: async () => {\n                return { value: undefined, done: true };\n            },\n        };\n    }\n    /**\n     * Fetches the next page of items. This makes a new API request.\n     *\n     * @throws {Error} If there are no more pages to fetch.\n     *\n     * @example\n     *\n     * ```ts\n     * const pager = await ai.files.list({config: {pageSize: 10}});\n     * let page = pager.page;\n     * while (true) {\n     *   for (const file of page) {\n     *     console.log(file.name);\n     *   }\n     *   if (!pager.hasNextPage()) {\n     *     break;\n     *   }\n     *   page = await pager.nextPage();\n     * }\n     * ```\n     */\n    async nextPage() {\n        if (!this.hasNextPage()) {\n            throw new Error('No more pages to fetch.');\n        }\n        const response = await this.requestInternal(this.params);\n        this.initNextPage(response);\n        return this.page;\n    }\n    /**\n     * Returns true if there are more pages to fetch from the API.\n     */\n    hasNextPage() {\n        var _a;\n        if (((_a = this.params['config']) === null || _a === void 0 ? void 0 : _a['pageToken']) !== undefined) {\n            return true;\n        }\n        return false;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Batches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Create batch job.\n         *\n         * @param params - The parameters for create batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.create({\n         *   model: 'gemini-2.0-flash',\n         *   src: {gcsUri: 'gs://bucket/path/to/file.jsonl', format: 'jsonl'},\n         *   config: {\n         *     dest: {gcsUri: 'gs://bucket/path/output/directory', format: 'jsonl'},\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.create = async (params) => {\n            var _a, _b;\n            if (this.apiClient.isVertexAI()) {\n                // Format destination if not provided\n                // Cast params.src as Vertex AI path does not handle InlinedRequest[]\n                params.config = this.formatDestination(params.src, params.config);\n                return this.createInternal(params);\n            }\n            // MLDEV\n            const src = params.src;\n            const is_inlined = Array.isArray(params.src) || src.inlinedRequests !== undefined;\n            if (!is_inlined) {\n                return this.createInternal(params);\n            }\n            // Inlined generate content requests handling\n            const result = this.createInlinedGenerateContentRequest(params);\n            const path = result.path;\n            const requestBody = result.body;\n            const queryParams = createBatchJobParametersToMldev(this.apiClient, params)['_query'] || {};\n            const response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(requestBody),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        };\n        /**\n         * **Experimental** Creates an embedding batch job.\n         *\n         * @param params - The parameters for create embedding batch job request.\n         * @return The created batch job.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.batches.createEmbeddings({\n         *   model: 'text-embedding-004',\n         *   src: {fileName: 'files/my_embedding_input'},\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.createEmbeddings = async (params) => {\n            var _a, _b;\n            console.warn('batches.createEmbeddings() is experimental and may change without notice.');\n            if (this.apiClient.isVertexAI()) {\n                throw new Error('Vertex AI does not support batches.createEmbeddings.');\n            }\n            // MLDEV\n            const src = params.src;\n            const is_inlined = src.inlinedRequests !== undefined;\n            if (!is_inlined) {\n                return this.createEmbeddingsInternal(params); // Fixed typo here\n            }\n            // Inlined embed content requests handling\n            const result = this.createInlinedEmbedContentRequest(params);\n            const path = result.path;\n            const requestBody = result.body;\n            const queryParams = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params)['_query'] || {};\n            const response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(requestBody),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        };\n        /**\n         * Lists batch job configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of batch jobs.\n         *\n         * @example\n         * ```ts\n         * const batchJobs = await ai.batches.list({config: {'pageSize': 2}});\n         * for await (const batchJob of batchJobs) {\n         *   console.log(batchJob);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_BATCH_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    // Helper function to handle inlined generate content requests\n    createInlinedGenerateContentRequest(params) {\n        const body = createBatchJobParametersToMldev(this.apiClient, // Use instance apiClient\n        params);\n        const urlParams = body['_url'];\n        const path = formatMap('{model}:batchGenerateContent', urlParams);\n        const batch = body['batch'];\n        const inputConfig = batch['inputConfig'];\n        const requestsWrapper = inputConfig['requests'];\n        const requests = requestsWrapper['requests'];\n        const newRequests = [];\n        for (const request of requests) {\n            const requestDict = Object.assign({}, request); // Clone\n            if (requestDict['systemInstruction']) {\n                const systemInstructionValue = requestDict['systemInstruction'];\n                delete requestDict['systemInstruction'];\n                const requestContent = requestDict['request'];\n                requestContent['systemInstruction'] = systemInstructionValue;\n                requestDict['request'] = requestContent;\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper['requests'] = newRequests;\n        delete body['config'];\n        delete body['_url'];\n        delete body['_query'];\n        return { path, body };\n    }\n    // Helper function to handle inlined embedding requests\n    createInlinedEmbedContentRequest(params) {\n        const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, // Use instance apiClient\n        params);\n        const urlParams = body['_url'];\n        const path = formatMap('{model}:asyncBatchEmbedContent', urlParams);\n        const batch = body['batch'];\n        const inputConfig = batch['inputConfig'];\n        const requestsWrapper = inputConfig['requests'];\n        const requests = requestsWrapper['requests'];\n        const newRequests = [];\n        delete requestsWrapper['config']; // Remove top-level config\n        for (const request of requests) {\n            const requestDict = Object.assign({}, request); // Clone\n            const innerRequest = requestDict['request'];\n            for (const key in requestDict) {\n                if (key !== 'request') {\n                    innerRequest[key] = requestDict[key];\n                    delete requestDict[key];\n                }\n            }\n            newRequests.push(requestDict);\n        }\n        requestsWrapper['requests'] = newRequests;\n        delete body['config'];\n        delete body['_url'];\n        delete body['_query'];\n        return { path, body };\n    }\n    // Helper function to get the first GCS URI\n    getGcsUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('gs://') ? src : undefined;\n        }\n        if (!Array.isArray(src) && src.gcsUri && src.gcsUri.length > 0) {\n            return src.gcsUri[0];\n        }\n        return undefined;\n    }\n    // Helper function to get the BigQuery URI\n    getBigqueryUri(src) {\n        if (typeof src === 'string') {\n            return src.startsWith('bq://') ? src : undefined;\n        }\n        if (!Array.isArray(src)) {\n            return src.bigqueryUri;\n        }\n        return undefined;\n    }\n    // Function to format the destination configuration for Vertex AI\n    formatDestination(src, config) {\n        const newConfig = config ? Object.assign({}, config) : {};\n        const timestampStr = Date.now().toString();\n        if (!newConfig.displayName) {\n            newConfig.displayName = `genaiBatchJob_${timestampStr}`;\n        }\n        if (newConfig.dest === undefined) {\n            const gcsUri = this.getGcsUri(src);\n            const bigqueryUri = this.getBigqueryUri(src);\n            if (gcsUri) {\n                if (gcsUri.endsWith('.jsonl')) {\n                    // For .jsonl files, remove suffix and add /dest\n                    newConfig.dest = `${gcsUri.slice(0, -6)}/dest`;\n                }\n                else {\n                    // Fallback for other GCS URIs\n                    newConfig.dest = `${gcsUri}_dest_${timestampStr}`;\n                }\n            }\n            else if (bigqueryUri) {\n                newConfig.dest = `${bigqueryUri}_dest_${timestampStr}`;\n            }\n            else {\n                throw new Error('Unsupported source for Vertex AI: No GCS or BigQuery URI found.');\n            }\n        }\n        return newConfig;\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = createBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchGenerateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Internal method to create batch job.\n     *\n     * @param params - The parameters for create batch job request.\n     * @return The created batch job.\n     *\n     */\n    async createEmbeddingsInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createEmbeddingsBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:asyncBatchEmbedContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets batch job configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The batch job.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = batchJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Cancels a batch job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listBatchJobsParametersToVertex(params);\n            path = formatMap('batchPredictionJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listBatchJobsParametersToMldev(params);\n            path = formatMap('batches', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listBatchJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListBatchJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Deletes a batch job.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.batches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteBatchJobParametersToVertex(this.apiClient, params);\n            path = formatMap('batchPredictionJobs/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = deleteBatchJobParametersToMldev(this.apiClient, params);\n            path = formatMap('batches/{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteResourceJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction apiKeyConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, ['apiKeyString']);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, ['apiKeyString'], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, ['apiKeyConfig']);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, ['apiKeyConfig'], apiKeyConfigToVertex$2(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, ['authType']);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, ['authType'], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        'googleServiceAccountConfig',\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, ['googleServiceAccountConfig'], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        'httpBasicAuthConfig',\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, ['httpBasicAuthConfig'], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, ['oauthConfig']);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, ['oauthConfig'], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, ['oidcConfig']);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, ['oidcConfig'], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction blobToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction cachedContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, ['expireTime'], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction cachedContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (fromExpireTime != null) {\n        setValueByPath(toObject, ['expireTime'], fromExpireTime);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$3(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction computerUseToVertex$2(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentToMldev$3(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$3(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$3(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev$1(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['kmsKeyName']) !== undefined) {\n        throw new Error('kmsKeyName parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (parentObject !== undefined && fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, ['contents'], transformedList);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToVertex$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$2(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToVertex$1(fromToolConfig));\n    }\n    const fromKmsKeyName = getValueByPath(fromObject, ['kmsKeyName']);\n    if (parentObject !== undefined && fromKmsKeyName != null) {\n        setValueByPath(parentObject, ['encryption_spec', 'kmsKeyName'], fromKmsKeyName);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], tCachesModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteCachedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$3(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        'excludeDomains',\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, ['excludeDomains'], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$3(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$3(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToVertex$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$3(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, ['behavior']);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, ['behavior'], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction getCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$2(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, ['authConfig']);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, ['authConfig'], authConfigToVertex$2(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToMldev$3(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToVertex$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$3(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToMldev$3(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToVertex$2(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        'excludeDomains',\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, ['excludeDomains'], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction intervalToMldev$3(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction latLngToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, ['latitude']);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, ['latitude'], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, ['longitude']);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, ['longitude'], fromLongitude);\n    }\n    return toObject;\n}\nfunction latLngToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, ['latitude']);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, ['latitude'], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, ['longitude']);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, ['longitude'], fromLongitude);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listCachedContentsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return cachedContentFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction listCachedContentsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromCachedContents = getValueByPath(fromObject, [\n        'cachedContents',\n    ]);\n    if (fromCachedContents != null) {\n        let transformedList = fromCachedContents;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return cachedContentFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['cachedContents'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev$3(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToMldev$3(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$3(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$3(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$3(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToVertex$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToVertex$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToVertex$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToVertex$2(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, ['latLng']);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, ['latLng'], latLngToMldev$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, ['latLng']);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, ['latLng'], latLngToVertex$1(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], retrievalConfigToMldev$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToVertex$1(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], retrievalConfigToVertex$1(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToMldev$3(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$3(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToMldev$3(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['googleMaps']) !== undefined) {\n        throw new Error('googleMaps parameter is not supported in Gemini API.');\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToMldev$3());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToMldev$3(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$2(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToVertex$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToVertex$2(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], enterpriseWebSearchToVertex$2(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToVertex$2(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToVertex$2());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToVertex$2(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTtl = getValueByPath(fromObject, ['ttl']);\n    if (parentObject !== undefined && fromTtl != null) {\n        setValueByPath(parentObject, ['ttl'], fromTtl);\n    }\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateCachedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], tCachedContentName(apiClient, fromName));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateCachedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$3() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataToMldev$3(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Caches extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists cached content configurations.\n         *\n         * @param params - The parameters for the list request.\n         * @return The paginated results of the list of cached contents.\n         *\n         * @example\n         * ```ts\n         * const cachedContents = await ai.caches.list({config: {'pageSize': 2}});\n         * for await (const cachedContent of cachedContents) {\n         *   console.log(cachedContent);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_CACHED_CONTENTS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Creates a cached contents resource.\n     *\n     * @remarks\n     * Context caching is only supported for specific models. See [Gemini\n     * Developer API reference](https://ai.google.dev/gemini-api/docs/caching?lang=node/context-cac)\n     * and [Vertex AI reference](https://cloud.google.com/vertex-ai/generative-ai/docs/context-cache/context-cache-overview#supported_models)\n     * for more information.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created cached content.\n     *\n     * @example\n     * ```ts\n     * const contents = ...; // Initialize the content to cache.\n     * const response = await ai.caches.create({\n     *   model: 'gemini-2.0-flash-001',\n     *   config: {\n     *    'contents': contents,\n     *    'displayName': 'test cache',\n     *    'systemInstruction': 'What is the sum of the two pdfs?',\n     *    'ttl': '86400s',\n     *  }\n     * });\n     * ```\n     */\n    async create(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = createCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Gets cached content configurations.\n     *\n     * @param params - The parameters for the get request.\n     * @return The cached content.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.get({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes cached content.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.caches.delete({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromVertex(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteCachedContentResponseFromMldev(apiResponse);\n                const typedResp = new DeleteCachedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates cached content configurations.\n     *\n     * @param params - The parameters for the update request.\n     * @return The updated cached content.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.caches.update({\n     *   name: '...',  // The server-generated resource name.\n     *   config: {'ttl': '7600s'}\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateCachedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = cachedContentFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = updateCachedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = cachedContentFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listCachedContentsParametersToVertex(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromVertex(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listCachedContentsParametersToMldev(params);\n            path = formatMap('cachedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listCachedContentsResponseFromMldev(apiResponse);\n                const typedResp = new ListCachedContentsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns true if the response is valid, false otherwise.\n */\nfunction isValidResponse(response) {\n    var _a;\n    if (response.candidates == undefined || response.candidates.length === 0) {\n        return false;\n    }\n    const content = (_a = response.candidates[0]) === null || _a === void 0 ? void 0 : _a.content;\n    if (content === undefined) {\n        return false;\n    }\n    return isValidContent(content);\n}\nfunction isValidContent(content) {\n    if (content.parts === undefined || content.parts.length === 0) {\n        return false;\n    }\n    for (const part of content.parts) {\n        if (part === undefined || Object.keys(part).length === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Validates the history contains the correct roles.\n *\n * @throws Error if the history does not start with a user turn.\n * @throws Error if the history contains an invalid role.\n */\nfunction validateHistory(history) {\n    // Empty history is valid.\n    if (history.length === 0) {\n        return;\n    }\n    for (const content of history) {\n        if (content.role !== 'user' && content.role !== 'model') {\n            throw new Error(`Role must be user or model, but got ${content.role}.`);\n        }\n    }\n}\n/**\n * Extracts the curated (valid) history from a comprehensive history.\n *\n * @remarks\n * The model may sometimes generate invalid or empty contents(e.g., due to safty\n * filters or recitation). Extracting valid turns from the history\n * ensures that subsequent requests could be accpeted by the model.\n */\nfunction extractCuratedHistory(comprehensiveHistory) {\n    if (comprehensiveHistory === undefined || comprehensiveHistory.length === 0) {\n        return [];\n    }\n    const curatedHistory = [];\n    const length = comprehensiveHistory.length;\n    let i = 0;\n    while (i < length) {\n        if (comprehensiveHistory[i].role === 'user') {\n            curatedHistory.push(comprehensiveHistory[i]);\n            i++;\n        }\n        else {\n            const modelOutput = [];\n            let isValid = true;\n            while (i < length && comprehensiveHistory[i].role === 'model') {\n                modelOutput.push(comprehensiveHistory[i]);\n                if (isValid && !isValidContent(comprehensiveHistory[i])) {\n                    isValid = false;\n                }\n                i++;\n            }\n            if (isValid) {\n                curatedHistory.push(...modelOutput);\n            }\n            else {\n                // Remove the last user input when model content is invalid.\n                curatedHistory.pop();\n            }\n        }\n    }\n    return curatedHistory;\n}\n/**\n * A utility class to create a chat session.\n */\nclass Chats {\n    constructor(modelsModule, apiClient) {\n        this.modelsModule = modelsModule;\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates a new chat session.\n     *\n     * @remarks\n     * The config in the params will be used for all requests within the chat\n     * session unless overridden by a per-request `config` in\n     * @see {@link types.SendMessageParameters#config}.\n     *\n     * @param params - Parameters for creating a chat session.\n     * @returns A new chat session.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({\n     *   model: 'gemini-2.0-flash'\n     *   config: {\n     *     temperature: 0.5,\n     *     maxOutputTokens: 1024,\n     *   }\n     * });\n     * ```\n     */\n    create(params) {\n        return new Chat(this.apiClient, this.modelsModule, params.model, params.config, \n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        structuredClone(params.history));\n    }\n}\n/**\n * Chat session that enables sending messages to the model with previous\n * conversation context.\n *\n * @remarks\n * The session maintains all the turns between user and model.\n */\nclass Chat {\n    constructor(apiClient, modelsModule, model, config = {}, history = []) {\n        this.apiClient = apiClient;\n        this.modelsModule = modelsModule;\n        this.model = model;\n        this.config = config;\n        this.history = history;\n        // A promise to represent the current state of the message being sent to the\n        // model.\n        this.sendPromise = Promise.resolve();\n        validateHistory(history);\n    }\n    /**\n     * Sends a message to the model and returns the response.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessageStream} for streaming method.\n     * @param params - parameters for sending messages within a chat session.\n     * @returns The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessage({\n     *   message: 'Why is the sky blue?'\n     * });\n     * console.log(response.text);\n     * ```\n     */\n    async sendMessage(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const responsePromise = this.modelsModule.generateContent({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        this.sendPromise = (async () => {\n            var _a, _b, _c;\n            const response = await responsePromise;\n            const outputContent = (_b = (_a = response.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n            // Because the AFC input contains the entire curated chat history in\n            // addition to the new user input, we need to truncate the AFC history\n            // to deduplicate the existing chat history.\n            const fullAutomaticFunctionCallingHistory = response.automaticFunctionCallingHistory;\n            const index = this.getHistory(true).length;\n            let automaticFunctionCallingHistory = [];\n            if (fullAutomaticFunctionCallingHistory != null) {\n                automaticFunctionCallingHistory =\n                    (_c = fullAutomaticFunctionCallingHistory.slice(index)) !== null && _c !== void 0 ? _c : [];\n            }\n            const modelOutput = outputContent ? [outputContent] : [];\n            this.recordHistory(inputContent, modelOutput, automaticFunctionCallingHistory);\n            return;\n        })();\n        await this.sendPromise.catch(() => {\n            // Resets sendPromise to avoid subsequent calls failing\n            this.sendPromise = Promise.resolve();\n        });\n        return responsePromise;\n    }\n    /**\n     * Sends a message to the model and returns the response in chunks.\n     *\n     * @remarks\n     * This method will wait for the previous message to be processed before\n     * sending the next message.\n     *\n     * @see {@link Chat#sendMessage} for non-streaming method.\n     * @param params - parameters for sending the message.\n     * @return The model's response.\n     *\n     * @example\n     * ```ts\n     * const chat = ai.chats.create({model: 'gemini-2.0-flash'});\n     * const response = await chat.sendMessageStream({\n     *   message: 'Why is the sky blue?'\n     * });\n     * for await (const chunk of response) {\n     *   console.log(chunk.text);\n     * }\n     * ```\n     */\n    async sendMessageStream(params) {\n        var _a;\n        await this.sendPromise;\n        const inputContent = tContent(params.message);\n        const streamResponse = this.modelsModule.generateContentStream({\n            model: this.model,\n            contents: this.getHistory(true).concat(inputContent),\n            config: (_a = params.config) !== null && _a !== void 0 ? _a : this.config,\n        });\n        // Resolve the internal tracking of send completion promise - `sendPromise`\n        // for both success and failure response. The actual failure is still\n        // propagated by the `await streamResponse`.\n        this.sendPromise = streamResponse\n            .then(() => undefined)\n            .catch(() => undefined);\n        const response = await streamResponse;\n        const result = this.processStreamResponse(response, inputContent);\n        return result;\n    }\n    /**\n     * Returns the chat history.\n     *\n     * @remarks\n     * The history is a list of contents alternating between user and model.\n     *\n     * There are two types of history:\n     * - The `curated history` contains only the valid turns between user and\n     * model, which will be included in the subsequent requests sent to the model.\n     * - The `comprehensive history` contains all turns, including invalid or\n     *   empty model outputs, providing a complete record of the history.\n     *\n     * The history is updated after receiving the response from the model,\n     * for streaming response, it means receiving the last chunk of the response.\n     *\n     * The `comprehensive history` is returned by default. To get the `curated\n     * history`, set the `curated` parameter to `true`.\n     *\n     * @param curated - whether to return the curated history or the comprehensive\n     *     history.\n     * @return History contents alternating between user and model for the entire\n     *     chat session.\n     */\n    getHistory(curated = false) {\n        const history = curated\n            ? extractCuratedHistory(this.history)\n            : this.history;\n        // Deep copy the history to avoid mutating the history outside of the\n        // chat session.\n        return structuredClone(history);\n    }\n    processStreamResponse(streamResponse, inputContent) {\n        var _a, _b;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            var _c, e_1, _d, _e;\n            const outputContent = [];\n            try {\n                for (var _f = true, streamResponse_1 = __asyncValues(streamResponse), streamResponse_1_1; streamResponse_1_1 = yield __await(streamResponse_1.next()), _c = streamResponse_1_1.done, !_c; _f = true) {\n                    _e = streamResponse_1_1.value;\n                    _f = false;\n                    const chunk = _e;\n                    if (isValidResponse(chunk)) {\n                        const content = (_b = (_a = chunk.candidates) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.content;\n                        if (content !== undefined) {\n                            outputContent.push(content);\n                        }\n                    }\n                    yield yield __await(chunk);\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_c && (_d = streamResponse_1.return)) yield __await(_d.call(streamResponse_1));\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            this.recordHistory(inputContent, outputContent);\n        });\n    }\n    recordHistory(userInput, modelOutput, automaticFunctionCallingHistory) {\n        let outputContents = [];\n        if (modelOutput.length > 0 &&\n            modelOutput.every((content) => content.role !== undefined)) {\n            outputContents = modelOutput;\n        }\n        else {\n            // Appends an empty content when model returns empty response, so that the\n            // history is always alternating between user and model.\n            outputContents.push({\n                role: 'model',\n                parts: [],\n            });\n        }\n        if (automaticFunctionCallingHistory &&\n            automaticFunctionCallingHistory.length > 0) {\n            this.history.push(...extractCuratedHistory(automaticFunctionCallingHistory));\n        }\n        else {\n            this.history.push(userInput);\n        }\n        this.history.push(...outputContents);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * API errors raised by the GenAI API.\n */\nclass ApiError extends Error {\n    constructor(options) {\n        super(options.message);\n        this.name = 'ApiError';\n        this.status = options.status;\n        Object.setPrototypeOf(this, ApiError.prototype);\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction createFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromFile = getValueByPath(fromObject, ['file']);\n    if (fromFile != null) {\n        setValueByPath(toObject, ['file'], fileToMldev(fromFile));\n    }\n    return toObject;\n}\nfunction createFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction deleteFileResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction fileFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, ['sizeBytes']);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, ['sizeBytes'], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        'expirationTime',\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, ['expirationTime'], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, ['sha256Hash']);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, ['sha256Hash'], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, ['downloadUri']);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, ['downloadUri'], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        setValueByPath(toObject, ['source'], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fileStatusFromMldev(fromError));\n    }\n    return toObject;\n}\nfunction fileStatusFromMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, ['details']);\n    if (fromDetails != null) {\n        setValueByPath(toObject, ['details'], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, ['message']);\n    if (fromMessage != null) {\n        setValueByPath(toObject, ['message'], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, ['code']);\n    if (fromCode != null) {\n        setValueByPath(toObject, ['code'], fromCode);\n    }\n    return toObject;\n}\nfunction fileStatusToMldev(fromObject) {\n    const toObject = {};\n    const fromDetails = getValueByPath(fromObject, ['details']);\n    if (fromDetails != null) {\n        setValueByPath(toObject, ['details'], fromDetails);\n    }\n    const fromMessage = getValueByPath(fromObject, ['message']);\n    if (fromMessage != null) {\n        setValueByPath(toObject, ['message'], fromMessage);\n    }\n    const fromCode = getValueByPath(fromObject, ['code']);\n    if (fromCode != null) {\n        setValueByPath(toObject, ['code'], fromCode);\n    }\n    return toObject;\n}\nfunction fileToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    const fromSizeBytes = getValueByPath(fromObject, ['sizeBytes']);\n    if (fromSizeBytes != null) {\n        setValueByPath(toObject, ['sizeBytes'], fromSizeBytes);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromExpirationTime = getValueByPath(fromObject, [\n        'expirationTime',\n    ]);\n    if (fromExpirationTime != null) {\n        setValueByPath(toObject, ['expirationTime'], fromExpirationTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromSha256Hash = getValueByPath(fromObject, ['sha256Hash']);\n    if (fromSha256Hash != null) {\n        setValueByPath(toObject, ['sha256Hash'], fromSha256Hash);\n    }\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromDownloadUri = getValueByPath(fromObject, ['downloadUri']);\n    if (fromDownloadUri != null) {\n        setValueByPath(toObject, ['downloadUri'], fromDownloadUri);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], fromState);\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        setValueByPath(toObject, ['source'], fromSource);\n    }\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fileStatusToMldev(fromError));\n    }\n    return toObject;\n}\nfunction getFileParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'file'], tFileName(fromName));\n    }\n    return toObject;\n}\nfunction listFilesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    return toObject;\n}\nfunction listFilesParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listFilesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listFilesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromFiles = getValueByPath(fromObject, ['files']);\n    if (fromFiles != null) {\n        let transformedList = fromFiles;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return fileFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['files'], transformedList);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Files extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Lists all current project files from the service.\n         *\n         * @param params - The parameters for the list request\n         * @return The paginated results of the list of files\n         *\n         * @example\n         * The following code prints the names of all files from the service, the\n         * size of each page is 10.\n         *\n         * ```ts\n         * const listResponse = await ai.files.list({config: {'pageSize': 10}});\n         * for await (const file of listResponse) {\n         *   console.log(file.name);\n         * }\n         * ```\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_FILES, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n    }\n    /**\n     * Uploads a file asynchronously to the Gemini API.\n     * This method is not available in Vertex AI.\n     * Supported upload sources:\n     * - Node.js: File path (string) or Blob object.\n     * - Browser: Blob object (e.g., File).\n     *\n     * @remarks\n     * The `mimeType` can be specified in the `config` parameter. If omitted:\n     *  - For file path (string) inputs, the `mimeType` will be inferred from the\n     *     file extension.\n     *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`\n     *     property.\n     * Somex eamples for file extension to mimeType mapping:\n     * .txt -> text/plain\n     * .json -> application/json\n     * .jpg  -> image/jpeg\n     * .png -> image/png\n     * .mp3 -> audio/mpeg\n     * .mp4 -> video/mp4\n     *\n     * This section can contain multiple paragraphs and code examples.\n     *\n     * @param params - Optional parameters specified in the\n     *        `types.UploadFileParameters` interface.\n     *         @see {@link types.UploadFileParameters#config} for the optional\n     *         config in the parameters.\n     * @return A promise that resolves to a `types.File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     * the `mimeType` can be provided in the `params.config` parameter.\n     * @throws An error occurs if a suitable upload location cannot be established.\n     *\n     * @example\n     * The following code uploads a file to Gemini API.\n     *\n     * ```ts\n     * const file = await ai.files.upload({file: 'file.txt', config: {\n     *   mimeType: 'text/plain',\n     * }});\n     * console.log(file.name);\n     * ```\n     */\n    async upload(params) {\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Vertex AI does not support uploading files. You can share files through a GCS bucket.');\n        }\n        return this.apiClient\n            .uploadFile(params.file, params.config)\n            .then((response) => {\n            const file = fileFromMldev(response);\n            return file;\n        });\n    }\n    /**\n     * Downloads a remotely stored file asynchronously to a location specified in\n     * the `params` object. This method only works on Node environment, to\n     * download files in the browser, use a browser compliant method like an <a>\n     * tag.\n     *\n     * @param params - The parameters for the download request.\n     *\n     * @example\n     * The following code downloads an example file named \"files/mehozpxf877d\" as\n     * \"file.txt\".\n     *\n     * ```ts\n     * await ai.files.download({file: file.name, downloadPath: 'file.txt'});\n     * ```\n     */\n    async download(params) {\n        await this.apiClient.downloadFile(params);\n    }\n    async listInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = listFilesParametersToMldev(params);\n            path = formatMap('files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listFilesResponseFromMldev(apiResponse);\n                const typedResp = new ListFilesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async createInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createFileParametersToMldev(params);\n            path = formatMap('upload/v1beta/files', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = createFileResponseFromMldev(apiResponse);\n                const typedResp = new CreateFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Retrieves the file information from the service.\n     *\n     * @param params - The parameters for the get request\n     * @return The Promise that resolves to the types.File object requested.\n     *\n     * @example\n     * ```ts\n     * const config: GetFileParameters = {\n     *   name: fileName,\n     * };\n     * file = await ai.files.get(config);\n     * console.log(file.name);\n     * ```\n     */\n    async get(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = getFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = fileFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a remotely stored file.\n     *\n     * @param params - The parameters for the delete request.\n     * @return The DeleteFileResponse, the response for the delete method.\n     *\n     * @example\n     * The following code deletes an example file named \"files/mehozpxf877d\".\n     *\n     * ```ts\n     * await ai.files.delete({name: file.name});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = deleteFileParametersToMldev(params);\n            path = formatMap('files/{file}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteFileResponseFromMldev(apiResponse);\n                const typedResp = new DeleteFileResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction activityEndToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityEndToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityStartToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction activityStartToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction apiKeyConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, ['apiKeyString']);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, ['apiKeyString'], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction audioChunkFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    const fromSourceMetadata = getValueByPath(fromObject, [\n        'sourceMetadata',\n    ]);\n    if (fromSourceMetadata != null) {\n        setValueByPath(toObject, ['sourceMetadata'], liveMusicSourceMetadataFromMldev(fromSourceMetadata));\n    }\n    return toObject;\n}\nfunction audioTranscriptionConfigToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction audioTranscriptionConfigToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction authConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, ['apiKeyConfig']);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, ['apiKeyConfig'], apiKeyConfigToVertex$1(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, ['authType']);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, ['authType'], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        'googleServiceAccountConfig',\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, ['googleServiceAccountConfig'], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        'httpBasicAuthConfig',\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, ['httpBasicAuthConfig'], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, ['oauthConfig']);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, ['oauthConfig'], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, ['oidcConfig']);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, ['oidcConfig'], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, ['disabled']);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, ['disabled'], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        'startOfSpeechSensitivity',\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, ['startOfSpeechSensitivity'], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        'endOfSpeechSensitivity',\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, ['endOfSpeechSensitivity'], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        'prefixPaddingMs',\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, ['prefixPaddingMs'], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        'silenceDurationMs',\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, ['silenceDurationMs'], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToVertex(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, ['disabled']);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, ['disabled'], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        'startOfSpeechSensitivity',\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, ['startOfSpeechSensitivity'], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        'endOfSpeechSensitivity',\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, ['endOfSpeechSensitivity'], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        'prefixPaddingMs',\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, ['prefixPaddingMs'], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        'silenceDurationMs',\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, ['silenceDurationMs'], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction blobFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$2(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction computerUseToVertex$1(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentToMldev$2(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        'triggerTokens',\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, ['triggerTokens'], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        'slidingWindow',\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, ['slidingWindow'], slidingWindowToMldev$1(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        'triggerTokens',\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, ['triggerTokens'], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        'slidingWindow',\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, ['slidingWindow'], slidingWindowToVertex(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        'excludeDomains',\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, ['excludeDomains'], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$2(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$2(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToVertex$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$2(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, ['behavior']);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, ['behavior'], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction googleMapsToVertex$1(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, ['authConfig']);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, ['authConfig'], authConfigToVertex$1(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToMldev$2(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToVertex$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$2(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToMldev$2(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction googleSearchToVertex$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToVertex$1(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        'excludeDomains',\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, ['excludeDomains'], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction intervalToMldev$2(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev$1(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], speechConfigToMldev$2(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], thinkingConfigToMldev$2(fromThinkingConfig));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev$2(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$2(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev$1(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], audioTranscriptionConfigToMldev$1());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], audioTranscriptionConfigToMldev$1());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], realtimeInputConfigToMldev$1(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], contextWindowCompressionConfigToMldev$1(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], proactivityConfigToMldev$1(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], speechConfigToVertex$1(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], thinkingConfigToVertex$1(fromThinkingConfig));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToVertex$1(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToVertex(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], audioTranscriptionConfigToVertex());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], audioTranscriptionConfigToVertex());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], realtimeInputConfigToVertex(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], contextWindowCompressionConfigToVertex(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], proactivityConfigToVertex(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev$1(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveConnectParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToVertex(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction liveMusicClientContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        'weightedPrompts',\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return weightedPromptFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['weightedPrompts'], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicClientContentToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        'weightedPrompts',\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['weightedPrompts'], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicClientMessageToMldev(fromObject) {\n    const toObject = {};\n    const fromSetup = getValueByPath(fromObject, ['setup']);\n    if (fromSetup != null) {\n        setValueByPath(toObject, ['setup'], liveMusicClientSetupToMldev(fromSetup));\n    }\n    const fromClientContent = getValueByPath(fromObject, [\n        'clientContent',\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, ['clientContent'], liveMusicClientContentToMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        'musicGenerationConfig',\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, ['musicGenerationConfig'], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    const fromPlaybackControl = getValueByPath(fromObject, [\n        'playbackControl',\n    ]);\n    if (fromPlaybackControl != null) {\n        setValueByPath(toObject, ['playbackControl'], fromPlaybackControl);\n    }\n    return toObject;\n}\nfunction liveMusicClientSetupToMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    return toObject;\n}\nfunction liveMusicFilteredPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromFilteredReason = getValueByPath(fromObject, [\n        'filteredReason',\n    ]);\n    if (fromFilteredReason != null) {\n        setValueByPath(toObject, ['filteredReason'], fromFilteredReason);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigFromMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, ['guidance']);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, ['guidance'], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, ['bpm']);\n    if (fromBpm != null) {\n        setValueByPath(toObject, ['bpm'], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, ['density']);\n    if (fromDensity != null) {\n        setValueByPath(toObject, ['density'], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, ['brightness']);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, ['brightness'], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, ['scale']);\n    if (fromScale != null) {\n        setValueByPath(toObject, ['scale'], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, ['muteBass']);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, ['muteBass'], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, ['muteDrums']);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, ['muteDrums'], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        'onlyBassAndDrums',\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, ['onlyBassAndDrums'], fromOnlyBassAndDrums);\n    }\n    const fromMusicGenerationMode = getValueByPath(fromObject, [\n        'musicGenerationMode',\n    ]);\n    if (fromMusicGenerationMode != null) {\n        setValueByPath(toObject, ['musicGenerationMode'], fromMusicGenerationMode);\n    }\n    return toObject;\n}\nfunction liveMusicGenerationConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromGuidance = getValueByPath(fromObject, ['guidance']);\n    if (fromGuidance != null) {\n        setValueByPath(toObject, ['guidance'], fromGuidance);\n    }\n    const fromBpm = getValueByPath(fromObject, ['bpm']);\n    if (fromBpm != null) {\n        setValueByPath(toObject, ['bpm'], fromBpm);\n    }\n    const fromDensity = getValueByPath(fromObject, ['density']);\n    if (fromDensity != null) {\n        setValueByPath(toObject, ['density'], fromDensity);\n    }\n    const fromBrightness = getValueByPath(fromObject, ['brightness']);\n    if (fromBrightness != null) {\n        setValueByPath(toObject, ['brightness'], fromBrightness);\n    }\n    const fromScale = getValueByPath(fromObject, ['scale']);\n    if (fromScale != null) {\n        setValueByPath(toObject, ['scale'], fromScale);\n    }\n    const fromMuteBass = getValueByPath(fromObject, ['muteBass']);\n    if (fromMuteBass != null) {\n        setValueByPath(toObject, ['muteBass'], fromMuteBass);\n    }\n    const fromMuteDrums = getValueByPath(fromObject, ['muteDrums']);\n    if (fromMuteDrums != null) {\n        setValueByPath(toObject, ['muteDrums'], fromMuteDrums);\n    }\n    const fromOnlyBassAndDrums = getValueByPath(fromObject, [\n        'onlyBassAndDrums',\n    ]);\n    if (fromOnlyBassAndDrums != null) {\n        setValueByPath(toObject, ['onlyBassAndDrums'], fromOnlyBassAndDrums);\n    }\n    const fromMusicGenerationMode = getValueByPath(fromObject, [\n        'musicGenerationMode',\n    ]);\n    if (fromMusicGenerationMode != null) {\n        setValueByPath(toObject, ['musicGenerationMode'], fromMusicGenerationMode);\n    }\n    return toObject;\n}\nfunction liveMusicServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromAudioChunks = getValueByPath(fromObject, ['audioChunks']);\n    if (fromAudioChunks != null) {\n        let transformedList = fromAudioChunks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return audioChunkFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['audioChunks'], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        'setupComplete',\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, ['setupComplete'], liveMusicServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        'serverContent',\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, ['serverContent'], liveMusicServerContentFromMldev(fromServerContent));\n    }\n    const fromFilteredPrompt = getValueByPath(fromObject, [\n        'filteredPrompt',\n    ]);\n    if (fromFilteredPrompt != null) {\n        setValueByPath(toObject, ['filteredPrompt'], liveMusicFilteredPromptFromMldev(fromFilteredPrompt));\n    }\n    return toObject;\n}\nfunction liveMusicServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveMusicSetConfigParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        'musicGenerationConfig',\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, ['musicGenerationConfig'], liveMusicGenerationConfigToMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction liveMusicSetWeightedPromptsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromWeightedPrompts = getValueByPath(fromObject, [\n        'weightedPrompts',\n    ]);\n    if (fromWeightedPrompts != null) {\n        let transformedList = fromWeightedPrompts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return weightedPromptToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['weightedPrompts'], transformedList);\n    }\n    return toObject;\n}\nfunction liveMusicSourceMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromClientContent = getValueByPath(fromObject, [\n        'clientContent',\n    ]);\n    if (fromClientContent != null) {\n        setValueByPath(toObject, ['clientContent'], liveMusicClientContentFromMldev(fromClientContent));\n    }\n    const fromMusicGenerationConfig = getValueByPath(fromObject, [\n        'musicGenerationConfig',\n    ]);\n    if (fromMusicGenerationConfig != null) {\n        setValueByPath(toObject, ['musicGenerationConfig'], liveMusicGenerationConfigFromMldev(fromMusicGenerationConfig));\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], activityStartToMldev());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], activityEndToMldev());\n    }\n    return toObject;\n}\nfunction liveSendRealtimeInputParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromMedia = getValueByPath(fromObject, ['media']);\n    if (fromMedia != null) {\n        let transformedList = tBlobs(fromMedia);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return item;\n            });\n        }\n        setValueByPath(toObject, ['mediaChunks'], transformedList);\n    }\n    const fromAudio = getValueByPath(fromObject, ['audio']);\n    if (fromAudio != null) {\n        setValueByPath(toObject, ['audio'], tAudioBlob(fromAudio));\n    }\n    const fromAudioStreamEnd = getValueByPath(fromObject, [\n        'audioStreamEnd',\n    ]);\n    if (fromAudioStreamEnd != null) {\n        setValueByPath(toObject, ['audioStreamEnd'], fromAudioStreamEnd);\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], tImageBlob(fromVideo));\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromActivityStart = getValueByPath(fromObject, [\n        'activityStart',\n    ]);\n    if (fromActivityStart != null) {\n        setValueByPath(toObject, ['activityStart'], activityStartToVertex());\n    }\n    const fromActivityEnd = getValueByPath(fromObject, ['activityEnd']);\n    if (fromActivityEnd != null) {\n        setValueByPath(toObject, ['activityEnd'], activityEndToVertex());\n    }\n    return toObject;\n}\nfunction liveServerContentFromMldev(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, ['modelTurn']);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, ['modelTurn'], contentFromMldev$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, ['turnComplete']);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, ['turnComplete'], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, ['interrupted']);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, ['interrupted'], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        'generationComplete',\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, ['generationComplete'], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        'inputTranscription',\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, ['inputTranscription'], transcriptionFromMldev(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        'outputTranscription',\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, ['outputTranscription'], transcriptionFromMldev(fromOutputTranscription));\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], urlContextMetadataFromMldev$1(fromUrlContextMetadata));\n    }\n    const fromTurnCompleteReason = getValueByPath(fromObject, [\n        'turnCompleteReason',\n    ]);\n    if (fromTurnCompleteReason != null) {\n        setValueByPath(toObject, ['turnCompleteReason'], fromTurnCompleteReason);\n    }\n    const fromWaitingForInput = getValueByPath(fromObject, [\n        'waitingForInput',\n    ]);\n    if (fromWaitingForInput != null) {\n        setValueByPath(toObject, ['waitingForInput'], fromWaitingForInput);\n    }\n    return toObject;\n}\nfunction liveServerContentFromVertex(fromObject) {\n    const toObject = {};\n    const fromModelTurn = getValueByPath(fromObject, ['modelTurn']);\n    if (fromModelTurn != null) {\n        setValueByPath(toObject, ['modelTurn'], contentFromVertex$1(fromModelTurn));\n    }\n    const fromTurnComplete = getValueByPath(fromObject, ['turnComplete']);\n    if (fromTurnComplete != null) {\n        setValueByPath(toObject, ['turnComplete'], fromTurnComplete);\n    }\n    const fromInterrupted = getValueByPath(fromObject, ['interrupted']);\n    if (fromInterrupted != null) {\n        setValueByPath(toObject, ['interrupted'], fromInterrupted);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromGenerationComplete = getValueByPath(fromObject, [\n        'generationComplete',\n    ]);\n    if (fromGenerationComplete != null) {\n        setValueByPath(toObject, ['generationComplete'], fromGenerationComplete);\n    }\n    const fromInputTranscription = getValueByPath(fromObject, [\n        'inputTranscription',\n    ]);\n    if (fromInputTranscription != null) {\n        setValueByPath(toObject, ['inputTranscription'], transcriptionFromVertex(fromInputTranscription));\n    }\n    const fromOutputTranscription = getValueByPath(fromObject, [\n        'outputTranscription',\n    ]);\n    if (fromOutputTranscription != null) {\n        setValueByPath(toObject, ['outputTranscription'], transcriptionFromVertex(fromOutputTranscription));\n    }\n    const fromTurnCompleteReason = getValueByPath(fromObject, [\n        'turnCompleteReason',\n    ]);\n    if (fromTurnCompleteReason != null) {\n        setValueByPath(toObject, ['turnCompleteReason'], fromTurnCompleteReason);\n    }\n    const fromWaitingForInput = getValueByPath(fromObject, [\n        'waitingForInput',\n    ]);\n    if (fromWaitingForInput != null) {\n        setValueByPath(toObject, ['waitingForInput'], fromWaitingForInput);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromMldev(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, ['timeLeft']);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, ['timeLeft'], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerGoAwayFromVertex(fromObject) {\n    const toObject = {};\n    const fromTimeLeft = getValueByPath(fromObject, ['timeLeft']);\n    if (fromTimeLeft != null) {\n        setValueByPath(toObject, ['timeLeft'], fromTimeLeft);\n    }\n    return toObject;\n}\nfunction liveServerMessageFromMldev(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        'setupComplete',\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, ['setupComplete'], liveServerSetupCompleteFromMldev());\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        'serverContent',\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, ['serverContent'], liveServerContentFromMldev(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, ['toolCall']);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, ['toolCall'], liveServerToolCallFromMldev(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        'toolCallCancellation',\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, ['toolCallCancellation'], liveServerToolCallCancellationFromMldev(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], usageMetadataFromMldev(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, ['goAway']);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, ['goAway'], liveServerGoAwayFromMldev(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        'sessionResumptionUpdate',\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, ['sessionResumptionUpdate'], liveServerSessionResumptionUpdateFromMldev(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveServerMessageFromVertex(fromObject) {\n    const toObject = {};\n    const fromSetupComplete = getValueByPath(fromObject, [\n        'setupComplete',\n    ]);\n    if (fromSetupComplete != null) {\n        setValueByPath(toObject, ['setupComplete'], liveServerSetupCompleteFromVertex(fromSetupComplete));\n    }\n    const fromServerContent = getValueByPath(fromObject, [\n        'serverContent',\n    ]);\n    if (fromServerContent != null) {\n        setValueByPath(toObject, ['serverContent'], liveServerContentFromVertex(fromServerContent));\n    }\n    const fromToolCall = getValueByPath(fromObject, ['toolCall']);\n    if (fromToolCall != null) {\n        setValueByPath(toObject, ['toolCall'], liveServerToolCallFromVertex(fromToolCall));\n    }\n    const fromToolCallCancellation = getValueByPath(fromObject, [\n        'toolCallCancellation',\n    ]);\n    if (fromToolCallCancellation != null) {\n        setValueByPath(toObject, ['toolCallCancellation'], liveServerToolCallCancellationFromVertex(fromToolCallCancellation));\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], usageMetadataFromVertex(fromUsageMetadata));\n    }\n    const fromGoAway = getValueByPath(fromObject, ['goAway']);\n    if (fromGoAway != null) {\n        setValueByPath(toObject, ['goAway'], liveServerGoAwayFromVertex(fromGoAway));\n    }\n    const fromSessionResumptionUpdate = getValueByPath(fromObject, [\n        'sessionResumptionUpdate',\n    ]);\n    if (fromSessionResumptionUpdate != null) {\n        setValueByPath(toObject, ['sessionResumptionUpdate'], liveServerSessionResumptionUpdateFromVertex(fromSessionResumptionUpdate));\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromMldev(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, ['newHandle']);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, ['newHandle'], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, ['resumable']);\n    if (fromResumable != null) {\n        setValueByPath(toObject, ['resumable'], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        'lastConsumedClientMessageIndex',\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, ['lastConsumedClientMessageIndex'], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerSessionResumptionUpdateFromVertex(fromObject) {\n    const toObject = {};\n    const fromNewHandle = getValueByPath(fromObject, ['newHandle']);\n    if (fromNewHandle != null) {\n        setValueByPath(toObject, ['newHandle'], fromNewHandle);\n    }\n    const fromResumable = getValueByPath(fromObject, ['resumable']);\n    if (fromResumable != null) {\n        setValueByPath(toObject, ['resumable'], fromResumable);\n    }\n    const fromLastConsumedClientMessageIndex = getValueByPath(fromObject, [\n        'lastConsumedClientMessageIndex',\n    ]);\n    if (fromLastConsumedClientMessageIndex != null) {\n        setValueByPath(toObject, ['lastConsumedClientMessageIndex'], fromLastConsumedClientMessageIndex);\n    }\n    return toObject;\n}\nfunction liveServerSetupCompleteFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction liveServerSetupCompleteFromVertex(fromObject) {\n    const toObject = {};\n    const fromSessionId = getValueByPath(fromObject, ['sessionId']);\n    if (fromSessionId != null) {\n        setValueByPath(toObject, ['sessionId'], fromSessionId);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromMldev(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, ['ids']);\n    if (fromIds != null) {\n        setValueByPath(toObject, ['ids'], fromIds);\n    }\n    return toObject;\n}\nfunction liveServerToolCallCancellationFromVertex(fromObject) {\n    const toObject = {};\n    const fromIds = getValueByPath(fromObject, ['ids']);\n    if (fromIds != null) {\n        setValueByPath(toObject, ['ids'], fromIds);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        'functionCalls',\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionCallFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionCalls'], transformedList);\n    }\n    return toObject;\n}\nfunction liveServerToolCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCalls = getValueByPath(fromObject, [\n        'functionCalls',\n    ]);\n    if (fromFunctionCalls != null) {\n        let transformedList = fromFunctionCalls;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionCallFromVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionCalls'], transformedList);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromMldev(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, ['modality']);\n    if (fromModality != null) {\n        setValueByPath(toObject, ['modality'], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction modalityTokenCountFromVertex(fromObject) {\n    const toObject = {};\n    const fromModality = getValueByPath(fromObject, ['modality']);\n    if (fromModality != null) {\n        setValueByPath(toObject, ['modality'], fromModality);\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        'speakerVoiceConfigs',\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return speakerVoiceConfigToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['speakerVoiceConfigs'], transformedList);\n    }\n    return toObject;\n}\nfunction partFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataFromMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobFromMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataFromMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallFromMldev$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataFromVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobFromVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataFromVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallFromVertex$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToMldev$2(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$2(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$2(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$2(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToVertex$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToVertex$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToVertex$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToVertex$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, ['voiceName']);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, ['voiceName'], fromVoiceName);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, ['voiceName']);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, ['voiceName'], fromVoiceName);\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        'proactiveAudio',\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, ['proactiveAudio'], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction proactivityConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        'proactiveAudio',\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, ['proactiveAudio'], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        'automaticActivityDetection',\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, ['automaticActivityDetection'], automaticActivityDetectionToMldev$1(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        'activityHandling',\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, ['activityHandling'], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, ['turnCoverage']);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, ['turnCoverage'], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        'automaticActivityDetection',\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, ['automaticActivityDetection'], automaticActivityDetectionToVertex(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        'activityHandling',\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, ['activityHandling'], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, ['turnCoverage']);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, ['turnCoverage'], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    const fromTransparent = getValueByPath(fromObject, ['transparent']);\n    if (fromTransparent != null) {\n        setValueByPath(toObject, ['transparent'], fromTransparent);\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, ['targetTokens']);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, ['targetTokens'], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction slidingWindowToVertex(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, ['targetTokens']);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, ['targetTokens'], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, ['speaker']);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, ['speaker'], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev$2(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        'multiSpeakerVoiceConfig',\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, ['multiSpeakerVoiceConfig'], multiSpeakerVoiceConfigToMldev$2(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction speechConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToVertex$1(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, ['multiSpeakerVoiceConfig']) !== undefined) {\n        throw new Error('multiSpeakerVoiceConfig parameter is not supported in Vertex AI.');\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        'includeThoughts',\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        'thinkingBudget',\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, ['thinkingBudget'], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        'includeThoughts',\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        'thinkingBudget',\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, ['thinkingBudget'], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToMldev$2(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$2(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToMldev$2(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['googleMaps']) !== undefined) {\n        throw new Error('googleMaps parameter is not supported in Gemini API.');\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToMldev$2());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToMldev$2(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToVertex$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToVertex$1(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], enterpriseWebSearchToVertex$1(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToVertex$1(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToVertex$1());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToVertex$1(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction transcriptionFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, ['finished']);\n    if (fromFinished != null) {\n        setValueByPath(toObject, ['finished'], fromFinished);\n    }\n    return toObject;\n}\nfunction transcriptionFromVertex(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromFinished = getValueByPath(fromObject, ['finished']);\n    if (fromFinished != null) {\n        setValueByPath(toObject, ['finished'], fromFinished);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, ['urlMetadata']);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return urlMetadataFromMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['urlMetadata'], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$2() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, ['retrievedUrl']);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, ['retrievedUrl'], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        'urlRetrievalStatus',\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, ['urlRetrievalStatus'], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction usageMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        'promptTokenCount',\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, ['promptTokenCount'], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        'responseTokenCount',\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, ['responseTokenCount'], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        'toolUsePromptTokenCount',\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, ['toolUsePromptTokenCount'], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        'thoughtsTokenCount',\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, ['thoughtsTokenCount'], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        'totalTokenCount',\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, ['totalTokenCount'], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        'promptTokensDetails',\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['promptTokensDetails'], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        'cacheTokensDetails',\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['cacheTokensDetails'], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        'responseTokensDetails',\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['responseTokensDetails'], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        'toolUsePromptTokensDetails',\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['toolUsePromptTokensDetails'], transformedList);\n    }\n    return toObject;\n}\nfunction usageMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromPromptTokenCount = getValueByPath(fromObject, [\n        'promptTokenCount',\n    ]);\n    if (fromPromptTokenCount != null) {\n        setValueByPath(toObject, ['promptTokenCount'], fromPromptTokenCount);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    const fromResponseTokenCount = getValueByPath(fromObject, [\n        'candidatesTokenCount',\n    ]);\n    if (fromResponseTokenCount != null) {\n        setValueByPath(toObject, ['responseTokenCount'], fromResponseTokenCount);\n    }\n    const fromToolUsePromptTokenCount = getValueByPath(fromObject, [\n        'toolUsePromptTokenCount',\n    ]);\n    if (fromToolUsePromptTokenCount != null) {\n        setValueByPath(toObject, ['toolUsePromptTokenCount'], fromToolUsePromptTokenCount);\n    }\n    const fromThoughtsTokenCount = getValueByPath(fromObject, [\n        'thoughtsTokenCount',\n    ]);\n    if (fromThoughtsTokenCount != null) {\n        setValueByPath(toObject, ['thoughtsTokenCount'], fromThoughtsTokenCount);\n    }\n    const fromTotalTokenCount = getValueByPath(fromObject, [\n        'totalTokenCount',\n    ]);\n    if (fromTotalTokenCount != null) {\n        setValueByPath(toObject, ['totalTokenCount'], fromTotalTokenCount);\n    }\n    const fromPromptTokensDetails = getValueByPath(fromObject, [\n        'promptTokensDetails',\n    ]);\n    if (fromPromptTokensDetails != null) {\n        let transformedList = fromPromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['promptTokensDetails'], transformedList);\n    }\n    const fromCacheTokensDetails = getValueByPath(fromObject, [\n        'cacheTokensDetails',\n    ]);\n    if (fromCacheTokensDetails != null) {\n        let transformedList = fromCacheTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['cacheTokensDetails'], transformedList);\n    }\n    const fromResponseTokensDetails = getValueByPath(fromObject, [\n        'candidatesTokensDetails',\n    ]);\n    if (fromResponseTokensDetails != null) {\n        let transformedList = fromResponseTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['responseTokensDetails'], transformedList);\n    }\n    const fromToolUsePromptTokensDetails = getValueByPath(fromObject, [\n        'toolUsePromptTokensDetails',\n    ]);\n    if (fromToolUsePromptTokensDetails != null) {\n        let transformedList = fromToolUsePromptTokensDetails;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modalityTokenCountFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['toolUsePromptTokensDetails'], transformedList);\n    }\n    const fromTrafficType = getValueByPath(fromObject, ['trafficType']);\n    if (fromTrafficType != null) {\n        setValueByPath(toObject, ['trafficType'], fromTrafficType);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$2(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$2(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        'prebuiltVoiceConfig',\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, ['prebuiltVoiceConfig'], prebuiltVoiceConfigToMldev$2(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        'prebuiltVoiceConfig',\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, ['prebuiltVoiceConfig'], prebuiltVoiceConfigToVertex$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction weightedPromptFromMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, ['weight']);\n    if (fromWeight != null) {\n        setValueByPath(toObject, ['weight'], fromWeight);\n    }\n    return toObject;\n}\nfunction weightedPromptToMldev(fromObject) {\n    const toObject = {};\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    const fromWeight = getValueByPath(fromObject, ['weight']);\n    if (fromWeight != null) {\n        setValueByPath(toObject, ['weight'], fromWeight);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction apiKeyConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyString = getValueByPath(fromObject, ['apiKeyString']);\n    if (fromApiKeyString != null) {\n        setValueByPath(toObject, ['apiKeyString'], fromApiKeyString);\n    }\n    return toObject;\n}\nfunction authConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromApiKeyConfig = getValueByPath(fromObject, ['apiKeyConfig']);\n    if (fromApiKeyConfig != null) {\n        setValueByPath(toObject, ['apiKeyConfig'], apiKeyConfigToVertex(fromApiKeyConfig));\n    }\n    const fromAuthType = getValueByPath(fromObject, ['authType']);\n    if (fromAuthType != null) {\n        setValueByPath(toObject, ['authType'], fromAuthType);\n    }\n    const fromGoogleServiceAccountConfig = getValueByPath(fromObject, [\n        'googleServiceAccountConfig',\n    ]);\n    if (fromGoogleServiceAccountConfig != null) {\n        setValueByPath(toObject, ['googleServiceAccountConfig'], fromGoogleServiceAccountConfig);\n    }\n    const fromHttpBasicAuthConfig = getValueByPath(fromObject, [\n        'httpBasicAuthConfig',\n    ]);\n    if (fromHttpBasicAuthConfig != null) {\n        setValueByPath(toObject, ['httpBasicAuthConfig'], fromHttpBasicAuthConfig);\n    }\n    const fromOauthConfig = getValueByPath(fromObject, ['oauthConfig']);\n    if (fromOauthConfig != null) {\n        setValueByPath(toObject, ['oauthConfig'], fromOauthConfig);\n    }\n    const fromOidcConfig = getValueByPath(fromObject, ['oidcConfig']);\n    if (fromOidcConfig != null) {\n        setValueByPath(toObject, ['oidcConfig'], fromOidcConfig);\n    }\n    return toObject;\n}\nfunction blobFromMldev(fromObject) {\n    const toObject = {};\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction blobToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction candidateFromMldev(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], contentFromMldev(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromMldev(fromCitationMetadata));\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['tokenCount']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], urlContextMetadataFromMldev(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction candidateFromVertex(fromObject) {\n    const toObject = {};\n    const fromContent = getValueByPath(fromObject, ['content']);\n    if (fromContent != null) {\n        setValueByPath(toObject, ['content'], contentFromVertex(fromContent));\n    }\n    const fromCitationMetadata = getValueByPath(fromObject, [\n        'citationMetadata',\n    ]);\n    if (fromCitationMetadata != null) {\n        setValueByPath(toObject, ['citationMetadata'], citationMetadataFromVertex(fromCitationMetadata));\n    }\n    const fromFinishMessage = getValueByPath(fromObject, [\n        'finishMessage',\n    ]);\n    if (fromFinishMessage != null) {\n        setValueByPath(toObject, ['finishMessage'], fromFinishMessage);\n    }\n    const fromFinishReason = getValueByPath(fromObject, ['finishReason']);\n    if (fromFinishReason != null) {\n        setValueByPath(toObject, ['finishReason'], fromFinishReason);\n    }\n    const fromUrlContextMetadata = getValueByPath(fromObject, [\n        'urlContextMetadata',\n    ]);\n    if (fromUrlContextMetadata != null) {\n        setValueByPath(toObject, ['urlContextMetadata'], urlContextMetadataFromVertex(fromUrlContextMetadata));\n    }\n    const fromAvgLogprobs = getValueByPath(fromObject, ['avgLogprobs']);\n    if (fromAvgLogprobs != null) {\n        setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);\n    }\n    const fromGroundingMetadata = getValueByPath(fromObject, [\n        'groundingMetadata',\n    ]);\n    if (fromGroundingMetadata != null) {\n        setValueByPath(toObject, ['groundingMetadata'], fromGroundingMetadata);\n    }\n    const fromIndex = getValueByPath(fromObject, ['index']);\n    if (fromIndex != null) {\n        setValueByPath(toObject, ['index'], fromIndex);\n    }\n    const fromLogprobsResult = getValueByPath(fromObject, [\n        'logprobsResult',\n    ]);\n    if (fromLogprobsResult != null) {\n        setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);\n    }\n    const fromSafetyRatings = getValueByPath(fromObject, [\n        'safetyRatings',\n    ]);\n    if (fromSafetyRatings != null) {\n        setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);\n    }\n    return toObject;\n}\nfunction checkpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, ['checkpointId']);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, ['checkpointId'], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, ['epoch']);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, ['epoch'], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, ['step']);\n    if (fromStep != null) {\n        setValueByPath(toObject, ['step'], fromStep);\n    }\n    return toObject;\n}\nfunction citationMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citationSources']);\n    if (fromCitations != null) {\n        setValueByPath(toObject, ['citations'], fromCitations);\n    }\n    return toObject;\n}\nfunction citationMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromCitations = getValueByPath(fromObject, ['citations']);\n    if (fromCitations != null) {\n        setValueByPath(toObject, ['citations'], fromCitations);\n    }\n    return toObject;\n}\nfunction computeTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    return toObject;\n}\nfunction computeTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTokensInfo = getValueByPath(fromObject, ['tokensInfo']);\n    if (fromTokensInfo != null) {\n        setValueByPath(toObject, ['tokensInfo'], fromTokensInfo);\n    }\n    return toObject;\n}\nfunction computerUseToMldev$1(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction computerUseToVertex(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromMldev(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, ['values']);\n    if (fromValues != null) {\n        setValueByPath(toObject, ['values'], fromValues);\n    }\n    return toObject;\n}\nfunction contentEmbeddingFromVertex(fromObject) {\n    const toObject = {};\n    const fromValues = getValueByPath(fromObject, ['values']);\n    if (fromValues != null) {\n        setValueByPath(toObject, ['values'], fromValues);\n    }\n    const fromStatistics = getValueByPath(fromObject, ['statistics']);\n    if (fromStatistics != null) {\n        setValueByPath(toObject, ['statistics'], contentEmbeddingStatisticsFromVertex(fromStatistics));\n    }\n    return toObject;\n}\nfunction contentEmbeddingStatisticsFromVertex(fromObject) {\n    const toObject = {};\n    const fromTruncated = getValueByPath(fromObject, ['truncated']);\n    if (fromTruncated != null) {\n        setValueByPath(toObject, ['truncated'], fromTruncated);\n    }\n    const fromTokenCount = getValueByPath(fromObject, ['token_count']);\n    if (fromTokenCount != null) {\n        setValueByPath(toObject, ['tokenCount'], fromTokenCount);\n    }\n    return toObject;\n}\nfunction contentFromMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentFromVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentToMldev$1(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contentToVertex(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction controlReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromControlType = getValueByPath(fromObject, ['controlType']);\n    if (fromControlType != null) {\n        setValueByPath(toObject, ['controlType'], fromControlType);\n    }\n    const fromEnableControlImageComputation = getValueByPath(fromObject, [\n        'enableControlImageComputation',\n    ]);\n    if (fromEnableControlImageComputation != null) {\n        setValueByPath(toObject, ['computeControl'], fromEnableControlImageComputation);\n    }\n    return toObject;\n}\nfunction countTokensConfigToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['systemInstruction']) !== undefined) {\n        throw new Error('systemInstruction parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['tools']) !== undefined) {\n        throw new Error('tools parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['generationConfig']) !== undefined) {\n        throw new Error('generationConfig parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction countTokensConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = fromTools;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['generationConfig'], fromGenerationConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToMldev(fromConfig);\n    }\n    return toObject;\n}\nfunction countTokensParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        countTokensConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    const fromCachedContentTokenCount = getValueByPath(fromObject, [\n        'cachedContentTokenCount',\n    ]);\n    if (fromCachedContentTokenCount != null) {\n        setValueByPath(toObject, ['cachedContentTokenCount'], fromCachedContentTokenCount);\n    }\n    return toObject;\n}\nfunction countTokensResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromTotalTokens = getValueByPath(fromObject, ['totalTokens']);\n    if (fromTotalTokens != null) {\n        setValueByPath(toObject, ['totalTokens'], fromTotalTokens);\n    }\n    return toObject;\n}\nfunction deleteModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction deleteModelResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction editImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromEditMode = getValueByPath(fromObject, ['editMode']);\n    if (parentObject !== undefined && fromEditMode != null) {\n        setValueByPath(parentObject, ['parameters', 'editMode'], fromEditMode);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'editConfig', 'baseSteps'], fromBaseSteps);\n    }\n    return toObject;\n}\nfunction editImageParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return referenceImageAPIInternalToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        editImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction editImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction embedContentConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['requests[]', 'taskType'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['requests[]', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    if (getValueByPath(fromObject, ['mimeType']) !== undefined) {\n        throw new Error('mimeType parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['autoTruncate']) !== undefined) {\n        throw new Error('autoTruncate parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction embedContentConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromTaskType = getValueByPath(fromObject, ['taskType']);\n    if (parentObject !== undefined && fromTaskType != null) {\n        setValueByPath(parentObject, ['instances[]', 'task_type'], fromTaskType);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (parentObject !== undefined && fromTitle != null) {\n        setValueByPath(parentObject, ['instances[]', 'title'], fromTitle);\n    }\n    const fromOutputDimensionality = getValueByPath(fromObject, [\n        'outputDimensionality',\n    ]);\n    if (parentObject !== undefined && fromOutputDimensionality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputDimensionality'], fromOutputDimensionality);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (parentObject !== undefined && fromMimeType != null) {\n        setValueByPath(parentObject, ['instances[]', 'mimeType'], fromMimeType);\n    }\n    const fromAutoTruncate = getValueByPath(fromObject, ['autoTruncate']);\n    if (parentObject !== undefined && fromAutoTruncate != null) {\n        setValueByPath(parentObject, ['parameters', 'autoTruncate'], fromAutoTruncate);\n    }\n    return toObject;\n}\nfunction embedContentMetadataFromMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction embedContentMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromBillableCharacterCount = getValueByPath(fromObject, [\n        'billableCharacterCount',\n    ]);\n    if (fromBillableCharacterCount != null) {\n        setValueByPath(toObject, ['billableCharacterCount'], fromBillableCharacterCount);\n    }\n    return toObject;\n}\nfunction embedContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        setValueByPath(toObject, ['requests[]', 'content'], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToMldev(fromConfig, toObject);\n    }\n    const fromModelForEmbedContent = getValueByPath(fromObject, ['model']);\n    if (fromModelForEmbedContent !== undefined) {\n        setValueByPath(toObject, ['requests[]', 'model'], tModel(apiClient, fromModelForEmbedContent));\n    }\n    return toObject;\n}\nfunction embedContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        setValueByPath(toObject, ['instances[]', 'content'], tContentsForEmbed(apiClient, fromContents));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        embedContentConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction embedContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, ['embeddings']);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentEmbeddingFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], embedContentMetadataFromMldev());\n    }\n    return toObject;\n}\nfunction embedContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromEmbeddings = getValueByPath(fromObject, [\n        'predictions[]',\n        'embeddings',\n    ]);\n    if (fromEmbeddings != null) {\n        let transformedList = fromEmbeddings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentEmbeddingFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['embeddings'], transformedList);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], embedContentMetadataFromVertex(fromMetadata));\n    }\n    return toObject;\n}\nfunction endpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['endpoint']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDeployedModelId = getValueByPath(fromObject, [\n        'deployedModelId',\n    ]);\n    if (fromDeployedModelId != null) {\n        setValueByPath(toObject, ['deployedModelId'], fromDeployedModelId);\n    }\n    return toObject;\n}\nfunction enterpriseWebSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        'excludeDomains',\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, ['excludeDomains'], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction entityLabelFromVertex(fromObject) {\n    const toObject = {};\n    const fromLabel = getValueByPath(fromObject, ['label']);\n    if (fromLabel != null) {\n        setValueByPath(toObject, ['label'], fromLabel);\n    }\n    const fromScore = getValueByPath(fromObject, ['score']);\n    if (fromScore != null) {\n        setValueByPath(toObject, ['score'], fromScore);\n    }\n    return toObject;\n}\nfunction fileDataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataFromVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToMldev$1(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction fileDataToVertex(fromObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallFromMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallFromVertex(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToMldev$1(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallToVertex(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionCallingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromAllowedFunctionNames = getValueByPath(fromObject, [\n        'allowedFunctionNames',\n    ]);\n    if (fromAllowedFunctionNames != null) {\n        setValueByPath(toObject, ['allowedFunctionNames'], fromAllowedFunctionNames);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev$1(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, ['behavior']);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, ['behavior'], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction functionDeclarationToVertex(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['behavior']) !== undefined) {\n        throw new Error('behavior parameter is not supported in Vertex AI.');\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction generateContentConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToMldev$1(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], schemaToMldev(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    if (getValueByPath(fromObject, ['routingConfig']) !== undefined) {\n        throw new Error('routingConfig parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['modelSelectionConfig']) !== undefined) {\n        throw new Error('modelSelectionConfig parameter is not supported in Gemini API.');\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToMldev(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev$1(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToMldev(fromToolConfig));\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToMldev$1(tSpeechConfig(fromSpeechConfig)));\n    }\n    if (getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {\n        throw new Error('audioTimestamp parameter is not supported in Gemini API.');\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], thinkingConfigToMldev$1(fromThinkingConfig));\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToMldev(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['systemInstruction'], contentToVertex(tContent(fromSystemInstruction)));\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (fromTemperature != null) {\n        setValueByPath(toObject, ['temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (fromTopP != null) {\n        setValueByPath(toObject, ['topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (fromTopK != null) {\n        setValueByPath(toObject, ['topK'], fromTopK);\n    }\n    const fromCandidateCount = getValueByPath(fromObject, [\n        'candidateCount',\n    ]);\n    if (fromCandidateCount != null) {\n        setValueByPath(toObject, ['candidateCount'], fromCandidateCount);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (fromMaxOutputTokens != null) {\n        setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromStopSequences = getValueByPath(fromObject, [\n        'stopSequences',\n    ]);\n    if (fromStopSequences != null) {\n        setValueByPath(toObject, ['stopSequences'], fromStopSequences);\n    }\n    const fromResponseLogprobs = getValueByPath(fromObject, [\n        'responseLogprobs',\n    ]);\n    if (fromResponseLogprobs != null) {\n        setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);\n    }\n    const fromLogprobs = getValueByPath(fromObject, ['logprobs']);\n    if (fromLogprobs != null) {\n        setValueByPath(toObject, ['logprobs'], fromLogprobs);\n    }\n    const fromPresencePenalty = getValueByPath(fromObject, [\n        'presencePenalty',\n    ]);\n    if (fromPresencePenalty != null) {\n        setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);\n    }\n    const fromFrequencyPenalty = getValueByPath(fromObject, [\n        'frequencyPenalty',\n    ]);\n    if (fromFrequencyPenalty != null) {\n        setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (fromSeed != null) {\n        setValueByPath(toObject, ['seed'], fromSeed);\n    }\n    const fromResponseMimeType = getValueByPath(fromObject, [\n        'responseMimeType',\n    ]);\n    if (fromResponseMimeType != null) {\n        setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);\n    }\n    const fromResponseSchema = getValueByPath(fromObject, [\n        'responseSchema',\n    ]);\n    if (fromResponseSchema != null) {\n        setValueByPath(toObject, ['responseSchema'], schemaToVertex(tSchema(fromResponseSchema)));\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    const fromRoutingConfig = getValueByPath(fromObject, [\n        'routingConfig',\n    ]);\n    if (fromRoutingConfig != null) {\n        setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);\n    }\n    const fromModelSelectionConfig = getValueByPath(fromObject, [\n        'modelSelectionConfig',\n    ]);\n    if (fromModelSelectionConfig != null) {\n        setValueByPath(toObject, ['modelConfig'], modelSelectionConfigToVertex(fromModelSelectionConfig));\n    }\n    const fromSafetySettings = getValueByPath(fromObject, [\n        'safetySettings',\n    ]);\n    if (parentObject !== undefined && fromSafetySettings != null) {\n        let transformedList = fromSafetySettings;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return safetySettingToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['safetySettings'], transformedList);\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToVertex(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['tools'], transformedList);\n    }\n    const fromToolConfig = getValueByPath(fromObject, ['toolConfig']);\n    if (parentObject !== undefined && fromToolConfig != null) {\n        setValueByPath(parentObject, ['toolConfig'], toolConfigToVertex(fromToolConfig));\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    const fromCachedContent = getValueByPath(fromObject, [\n        'cachedContent',\n    ]);\n    if (parentObject !== undefined && fromCachedContent != null) {\n        setValueByPath(parentObject, ['cachedContent'], tCachedContentName(apiClient, fromCachedContent));\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (fromResponseModalities != null) {\n        setValueByPath(toObject, ['responseModalities'], fromResponseModalities);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (fromMediaResolution != null) {\n        setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (fromSpeechConfig != null) {\n        setValueByPath(toObject, ['speechConfig'], speechConfigToVertex(tSpeechConfig(fromSpeechConfig)));\n    }\n    const fromAudioTimestamp = getValueByPath(fromObject, [\n        'audioTimestamp',\n    ]);\n    if (fromAudioTimestamp != null) {\n        setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (fromThinkingConfig != null) {\n        setValueByPath(toObject, ['thinkingConfig'], thinkingConfigToVertex(fromThinkingConfig));\n    }\n    const fromImageConfig = getValueByPath(fromObject, ['imageConfig']);\n    if (fromImageConfig != null) {\n        setValueByPath(toObject, ['imageConfig'], imageConfigToVertex(fromImageConfig));\n    }\n    return toObject;\n}\nfunction generateContentParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromContents = getValueByPath(fromObject, ['contents']);\n    if (fromContents != null) {\n        let transformedList = tContents(fromContents);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return contentToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['contents'], transformedList);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['generationConfig'], generateContentConfigToVertex(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction generateContentResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateContentResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromCandidates = getValueByPath(fromObject, ['candidates']);\n    if (fromCandidates != null) {\n        let transformedList = fromCandidates;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return candidateFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['candidates'], transformedList);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromModelVersion = getValueByPath(fromObject, ['modelVersion']);\n    if (fromModelVersion != null) {\n        setValueByPath(toObject, ['modelVersion'], fromModelVersion);\n    }\n    const fromPromptFeedback = getValueByPath(fromObject, [\n        'promptFeedback',\n    ]);\n    if (fromPromptFeedback != null) {\n        setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);\n    }\n    const fromResponseId = getValueByPath(fromObject, ['responseId']);\n    if (fromResponseId != null) {\n        setValueByPath(toObject, ['responseId'], fromResponseId);\n    }\n    const fromUsageMetadata = getValueByPath(fromObject, [\n        'usageMetadata',\n    ]);\n    if (fromUsageMetadata != null) {\n        setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);\n    }\n    return toObject;\n}\nfunction generateImagesConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['negativePrompt']) !== undefined) {\n        throw new Error('negativePrompt parameter is not supported in Gemini API.');\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    if (getValueByPath(fromObject, ['addWatermark']) !== undefined) {\n        throw new Error('addWatermark parameter is not supported in Gemini API.');\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    if (getValueByPath(fromObject, ['enhancePrompt']) !== undefined) {\n        throw new Error('enhancePrompt parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateImagesConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromGuidanceScale = getValueByPath(fromObject, [\n        'guidanceScale',\n    ]);\n    if (parentObject !== undefined && fromGuidanceScale != null) {\n        setValueByPath(parentObject, ['parameters', 'guidanceScale'], fromGuidanceScale);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromIncludeSafetyAttributes = getValueByPath(fromObject, [\n        'includeSafetyAttributes',\n    ]);\n    if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {\n        setValueByPath(parentObject, ['parameters', 'includeSafetyAttributes'], fromIncludeSafetyAttributes);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromLanguage = getValueByPath(fromObject, ['language']);\n    if (parentObject !== undefined && fromLanguage != null) {\n        setValueByPath(parentObject, ['parameters', 'language'], fromLanguage);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromImageSize = getValueByPath(fromObject, ['imageSize']);\n    if (parentObject !== undefined && fromImageSize != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleImageSize'], fromImageSize);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateImagesConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromMldev(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateImagesResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    const fromPositivePromptSafetyAttributes = getValueByPath(fromObject, [\n        'positivePromptSafetyAttributes',\n    ]);\n    if (fromPositivePromptSafetyAttributes != null) {\n        setValueByPath(toObject, ['positivePromptSafetyAttributes'], safetyAttributesFromVertex(fromPositivePromptSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generateVideosConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    if (getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {\n        throw new Error('outputGcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['fps']) !== undefined) {\n        throw new Error('fps parameter is not supported in Gemini API.');\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    if (getValueByPath(fromObject, ['seed']) !== undefined) {\n        throw new Error('seed parameter is not supported in Gemini API.');\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    if (getValueByPath(fromObject, ['pubsubTopic']) !== undefined) {\n        throw new Error('pubsubTopic parameter is not supported in Gemini API.');\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    if (getValueByPath(fromObject, ['generateAudio']) !== undefined) {\n        throw new Error('generateAudio parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['lastFrame']) !== undefined) {\n        throw new Error('lastFrame parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['referenceImages']) !== undefined) {\n        throw new Error('referenceImages parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['mask']) !== undefined) {\n        throw new Error('mask parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['compressionQuality']) !== undefined) {\n        throw new Error('compressionQuality parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateVideosConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfVideos = getValueByPath(fromObject, [\n        'numberOfVideos',\n    ]);\n    if (parentObject !== undefined && fromNumberOfVideos != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfVideos);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (parentObject !== undefined && fromFps != null) {\n        setValueByPath(parentObject, ['parameters', 'fps'], fromFps);\n    }\n    const fromDurationSeconds = getValueByPath(fromObject, [\n        'durationSeconds',\n    ]);\n    if (parentObject !== undefined && fromDurationSeconds != null) {\n        setValueByPath(parentObject, ['parameters', 'durationSeconds'], fromDurationSeconds);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (parentObject !== undefined && fromAspectRatio != null) {\n        setValueByPath(parentObject, ['parameters', 'aspectRatio'], fromAspectRatio);\n    }\n    const fromResolution = getValueByPath(fromObject, ['resolution']);\n    if (parentObject !== undefined && fromResolution != null) {\n        setValueByPath(parentObject, ['parameters', 'resolution'], fromResolution);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromPubsubTopic = getValueByPath(fromObject, ['pubsubTopic']);\n    if (parentObject !== undefined && fromPubsubTopic != null) {\n        setValueByPath(parentObject, ['parameters', 'pubsubTopic'], fromPubsubTopic);\n    }\n    const fromNegativePrompt = getValueByPath(fromObject, [\n        'negativePrompt',\n    ]);\n    if (parentObject !== undefined && fromNegativePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'negativePrompt'], fromNegativePrompt);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    const fromGenerateAudio = getValueByPath(fromObject, [\n        'generateAudio',\n    ]);\n    if (parentObject !== undefined && fromGenerateAudio != null) {\n        setValueByPath(parentObject, ['parameters', 'generateAudio'], fromGenerateAudio);\n    }\n    const fromLastFrame = getValueByPath(fromObject, ['lastFrame']);\n    if (parentObject !== undefined && fromLastFrame != null) {\n        setValueByPath(parentObject, ['instances[0]', 'lastFrame'], imageToVertex(fromLastFrame));\n    }\n    const fromReferenceImages = getValueByPath(fromObject, [\n        'referenceImages',\n    ]);\n    if (parentObject !== undefined && fromReferenceImages != null) {\n        let transformedList = fromReferenceImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return videoGenerationReferenceImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'referenceImages'], transformedList);\n    }\n    const fromMask = getValueByPath(fromObject, ['mask']);\n    if (parentObject !== undefined && fromMask != null) {\n        setValueByPath(parentObject, ['instances[0]', 'mask'], videoGenerationMaskToVertex(fromMask));\n    }\n    const fromCompressionQuality = getValueByPath(fromObject, [\n        'compressionQuality',\n    ]);\n    if (parentObject !== undefined && fromCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'compressionQuality'], fromCompressionQuality);\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, [\n        'response',\n        'generateVideoResponse',\n    ]);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromMldev(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosOperationFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], generateVideosResponseFromVertex(fromResponse));\n    }\n    return toObject;\n}\nfunction generateVideosParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    if (getValueByPath(fromObject, ['video']) !== undefined) {\n        throw new Error('video parameter is not supported in Gemini API.');\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToMldev(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromPrompt != null) {\n        setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        generateVideosSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        generateVideosConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, [\n        'generatedSamples',\n    ]);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedVideos = getValueByPath(fromObject, ['videos']);\n    if (fromGeneratedVideos != null) {\n        let transformedList = fromGeneratedVideos;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedVideoFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedVideos'], transformedList);\n    }\n    const fromRaiMediaFilteredCount = getValueByPath(fromObject, [\n        'raiMediaFilteredCount',\n    ]);\n    if (fromRaiMediaFilteredCount != null) {\n        setValueByPath(toObject, ['raiMediaFilteredCount'], fromRaiMediaFilteredCount);\n    }\n    const fromRaiMediaFilteredReasons = getValueByPath(fromObject, [\n        'raiMediaFilteredReasons',\n    ]);\n    if (fromRaiMediaFilteredReasons != null) {\n        setValueByPath(toObject, ['raiMediaFilteredReasons'], fromRaiMediaFilteredReasons);\n    }\n    return toObject;\n}\nfunction generateVideosSourceToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToMldev(fromImage));\n    }\n    if (getValueByPath(fromObject, ['video']) !== undefined) {\n        throw new Error('video parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction generateVideosSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromVideo = getValueByPath(fromObject, ['video']);\n    if (parentObject !== undefined && fromVideo != null) {\n        setValueByPath(parentObject, ['instances[0]', 'video'], videoToVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedImageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromMldev(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromMldev(fromSafetyAttributes));\n    }\n    return toObject;\n}\nfunction generatedImageFromVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['_self']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageFromVertex(fromImage));\n    }\n    const fromRaiFilteredReason = getValueByPath(fromObject, [\n        'raiFilteredReason',\n    ]);\n    if (fromRaiFilteredReason != null) {\n        setValueByPath(toObject, ['raiFilteredReason'], fromRaiFilteredReason);\n    }\n    const fromSafetyAttributes = getValueByPath(fromObject, ['_self']);\n    if (fromSafetyAttributes != null) {\n        setValueByPath(toObject, ['safetyAttributes'], safetyAttributesFromVertex(fromSafetyAttributes));\n    }\n    const fromEnhancedPrompt = getValueByPath(fromObject, ['prompt']);\n    if (fromEnhancedPrompt != null) {\n        setValueByPath(toObject, ['enhancedPrompt'], fromEnhancedPrompt);\n    }\n    return toObject;\n}\nfunction generatedImageMaskFromVertex(fromObject) {\n    const toObject = {};\n    const fromMask = getValueByPath(fromObject, ['_self']);\n    if (fromMask != null) {\n        setValueByPath(toObject, ['mask'], imageFromVertex(fromMask));\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        let transformedList = fromLabels;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return entityLabelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['labels'], transformedList);\n    }\n    return toObject;\n}\nfunction generatedVideoFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromMldev(fromVideo));\n    }\n    return toObject;\n}\nfunction generatedVideoFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideo = getValueByPath(fromObject, ['_self']);\n    if (fromVideo != null) {\n        setValueByPath(toObject, ['video'], videoFromVertex(fromVideo));\n    }\n    return toObject;\n}\nfunction getModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction getModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    return toObject;\n}\nfunction googleMapsToVertex(fromObject) {\n    const toObject = {};\n    const fromAuthConfig = getValueByPath(fromObject, ['authConfig']);\n    if (fromAuthConfig != null) {\n        setValueByPath(toObject, ['authConfig'], authConfigToVertex(fromAuthConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToMldev$1(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToVertex(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToVertex(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev$1(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToMldev$1(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction googleSearchToVertex(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToVertex(fromTimeRangeFilter));\n    }\n    const fromExcludeDomains = getValueByPath(fromObject, [\n        'excludeDomains',\n    ]);\n    if (fromExcludeDomains != null) {\n        setValueByPath(toObject, ['excludeDomains'], fromExcludeDomains);\n    }\n    return toObject;\n}\nfunction imageConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    return toObject;\n}\nfunction imageConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromAspectRatio = getValueByPath(fromObject, ['aspectRatio']);\n    if (fromAspectRatio != null) {\n        setValueByPath(toObject, ['aspectRatio'], fromAspectRatio);\n    }\n    return toObject;\n}\nfunction imageFromMldev(fromObject) {\n    const toObject = {};\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageFromVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['imageBytes'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction imageToVertex(fromObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromGcsUri);\n    }\n    const fromImageBytes = getValueByPath(fromObject, ['imageBytes']);\n    if (fromImageBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromImageBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction intervalToMldev$1(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction intervalToVertex(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction latLngToMldev(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, ['latitude']);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, ['latitude'], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, ['longitude']);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, ['longitude'], fromLongitude);\n    }\n    return toObject;\n}\nfunction latLngToVertex(fromObject) {\n    const toObject = {};\n    const fromLatitude = getValueByPath(fromObject, ['latitude']);\n    if (fromLatitude != null) {\n        setValueByPath(toObject, ['latitude'], fromLatitude);\n    }\n    const fromLongitude = getValueByPath(fromObject, ['longitude']);\n    if (fromLongitude != null) {\n        setValueByPath(toObject, ['longitude'], fromLongitude);\n    }\n    return toObject;\n}\nfunction listModelsConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsConfigToVertex(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    const fromQueryBase = getValueByPath(fromObject, ['queryBase']);\n    if (parentObject !== undefined && fromQueryBase != null) {\n        setValueByPath(parentObject, ['_url', 'models_url'], tModelsUrl(apiClient, fromQueryBase));\n    }\n    return toObject;\n}\nfunction listModelsParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToMldev(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listModelsConfigToVertex(apiClient, fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction listModelsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromModels = getValueByPath(fromObject, ['_self']);\n    if (fromModels != null) {\n        let transformedList = tExtractModels(fromModels);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return modelFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['models'], transformedList);\n    }\n    return toObject;\n}\nfunction maskReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    const fromSegmentationClasses = getValueByPath(fromObject, [\n        'segmentationClasses',\n    ]);\n    if (fromSegmentationClasses != null) {\n        setValueByPath(toObject, ['maskClasses'], fromSegmentationClasses);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (fromMaskDilation != null) {\n        setValueByPath(toObject, ['dilation'], fromMaskDilation);\n    }\n    return toObject;\n}\nfunction modelFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['version']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromMldev(fromTunedModelInfo));\n    }\n    const fromInputTokenLimit = getValueByPath(fromObject, [\n        'inputTokenLimit',\n    ]);\n    if (fromInputTokenLimit != null) {\n        setValueByPath(toObject, ['inputTokenLimit'], fromInputTokenLimit);\n    }\n    const fromOutputTokenLimit = getValueByPath(fromObject, [\n        'outputTokenLimit',\n    ]);\n    if (fromOutputTokenLimit != null) {\n        setValueByPath(toObject, ['outputTokenLimit'], fromOutputTokenLimit);\n    }\n    const fromSupportedActions = getValueByPath(fromObject, [\n        'supportedGenerationMethods',\n    ]);\n    if (fromSupportedActions != null) {\n        setValueByPath(toObject, ['supportedActions'], fromSupportedActions);\n    }\n    return toObject;\n}\nfunction modelFromVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (fromDisplayName != null) {\n        setValueByPath(toObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromVersion = getValueByPath(fromObject, ['versionId']);\n    if (fromVersion != null) {\n        setValueByPath(toObject, ['version'], fromVersion);\n    }\n    const fromEndpoints = getValueByPath(fromObject, ['deployedModels']);\n    if (fromEndpoints != null) {\n        let transformedList = fromEndpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return endpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['endpoints'], transformedList);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromTunedModelInfo = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModelInfo != null) {\n        setValueByPath(toObject, ['tunedModelInfo'], tunedModelInfoFromVertex(fromTunedModelInfo));\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (fromDefaultCheckpointId != null) {\n        setValueByPath(toObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, ['checkpoints']);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return checkpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['checkpoints'], transformedList);\n    }\n    return toObject;\n}\nfunction modelSelectionConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFeatureSelectionPreference = getValueByPath(fromObject, [\n        'featureSelectionPreference',\n    ]);\n    if (fromFeatureSelectionPreference != null) {\n        setValueByPath(toObject, ['featureSelectionPreference'], fromFeatureSelectionPreference);\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        'speakerVoiceConfigs',\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return speakerVoiceConfigToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['speakerVoiceConfigs'], transformedList);\n    }\n    return toObject;\n}\nfunction partFromMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataFromMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobFromMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataFromMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallFromMldev(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partFromVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataFromVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobFromVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataFromVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallFromVertex(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToMldev$1(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev$1(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev$1(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev$1(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction partToVertex(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToVertex(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToVertex(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToVertex(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToVertex(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, ['voiceName']);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, ['voiceName'], fromVoiceName);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, ['voiceName']);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, ['voiceName'], fromVoiceName);\n    }\n    return toObject;\n}\nfunction productImageToVertex(fromObject) {\n    const toObject = {};\n    const fromProductImage = getValueByPath(fromObject, ['productImage']);\n    if (fromProductImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromProductImage));\n    }\n    return toObject;\n}\nfunction recontextImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromBaseSteps = getValueByPath(fromObject, ['baseSteps']);\n    if (parentObject !== undefined && fromBaseSteps != null) {\n        setValueByPath(parentObject, ['parameters', 'editConfig', 'baseSteps'], fromBaseSteps);\n    }\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);\n    }\n    const fromSafetyFilterLevel = getValueByPath(fromObject, [\n        'safetyFilterLevel',\n    ]);\n    if (parentObject !== undefined && fromSafetyFilterLevel != null) {\n        setValueByPath(parentObject, ['parameters', 'safetySetting'], fromSafetyFilterLevel);\n    }\n    const fromPersonGeneration = getValueByPath(fromObject, [\n        'personGeneration',\n    ]);\n    if (parentObject !== undefined && fromPersonGeneration != null) {\n        setValueByPath(parentObject, ['parameters', 'personGeneration'], fromPersonGeneration);\n    }\n    const fromAddWatermark = getValueByPath(fromObject, ['addWatermark']);\n    if (parentObject !== undefined && fromAddWatermark != null) {\n        setValueByPath(parentObject, ['parameters', 'addWatermark'], fromAddWatermark);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhancePrompt = getValueByPath(fromObject, [\n        'enhancePrompt',\n    ]);\n    if (parentObject !== undefined && fromEnhancePrompt != null) {\n        setValueByPath(parentObject, ['parameters', 'enhancePrompt'], fromEnhancePrompt);\n    }\n    return toObject;\n}\nfunction recontextImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        recontextImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        recontextImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction recontextImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction recontextImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromPersonImage = getValueByPath(fromObject, ['personImage']);\n    if (parentObject !== undefined && fromPersonImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'personImage', 'image'], imageToVertex(fromPersonImage));\n    }\n    const fromProductImages = getValueByPath(fromObject, [\n        'productImages',\n    ]);\n    if (parentObject !== undefined && fromProductImages != null) {\n        let transformedList = fromProductImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return productImageToVertex(item);\n            });\n        }\n        setValueByPath(parentObject, ['instances[0]', 'productImages'], transformedList);\n    }\n    return toObject;\n}\nfunction referenceImageAPIInternalToVertex(fromObject) {\n    const toObject = {};\n    const fromReferenceImage = getValueByPath(fromObject, [\n        'referenceImage',\n    ]);\n    if (fromReferenceImage != null) {\n        setValueByPath(toObject, ['referenceImage'], imageToVertex(fromReferenceImage));\n    }\n    const fromReferenceId = getValueByPath(fromObject, ['referenceId']);\n    if (fromReferenceId != null) {\n        setValueByPath(toObject, ['referenceId'], fromReferenceId);\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    const fromMaskImageConfig = getValueByPath(fromObject, [\n        'maskImageConfig',\n    ]);\n    if (fromMaskImageConfig != null) {\n        setValueByPath(toObject, ['maskImageConfig'], maskReferenceConfigToVertex(fromMaskImageConfig));\n    }\n    const fromControlImageConfig = getValueByPath(fromObject, [\n        'controlImageConfig',\n    ]);\n    if (fromControlImageConfig != null) {\n        setValueByPath(toObject, ['controlImageConfig'], controlReferenceConfigToVertex(fromControlImageConfig));\n    }\n    const fromStyleImageConfig = getValueByPath(fromObject, [\n        'styleImageConfig',\n    ]);\n    if (fromStyleImageConfig != null) {\n        setValueByPath(toObject, ['styleImageConfig'], styleReferenceConfigToVertex(fromStyleImageConfig));\n    }\n    const fromSubjectImageConfig = getValueByPath(fromObject, [\n        'subjectImageConfig',\n    ]);\n    if (fromSubjectImageConfig != null) {\n        setValueByPath(toObject, ['subjectImageConfig'], subjectReferenceConfigToVertex(fromSubjectImageConfig));\n    }\n    return toObject;\n}\nfunction retrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, ['latLng']);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, ['latLng'], latLngToMldev(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction retrievalConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromLatLng = getValueByPath(fromObject, ['latLng']);\n    if (fromLatLng != null) {\n        setValueByPath(toObject, ['latLng'], latLngToVertex(fromLatLng));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromMldev(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetyAttributesFromVertex(fromObject) {\n    const toObject = {};\n    const fromCategories = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'categories',\n    ]);\n    if (fromCategories != null) {\n        setValueByPath(toObject, ['categories'], fromCategories);\n    }\n    const fromScores = getValueByPath(fromObject, [\n        'safetyAttributes',\n        'scores',\n    ]);\n    if (fromScores != null) {\n        setValueByPath(toObject, ['scores'], fromScores);\n    }\n    const fromContentType = getValueByPath(fromObject, ['contentType']);\n    if (fromContentType != null) {\n        setValueByPath(toObject, ['contentType'], fromContentType);\n    }\n    return toObject;\n}\nfunction safetySettingToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['method']) !== undefined) {\n        throw new Error('method parameter is not supported in Gemini API.');\n    }\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction safetySettingToVertex(fromObject) {\n    const toObject = {};\n    const fromMethod = getValueByPath(fromObject, ['method']);\n    if (fromMethod != null) {\n        setValueByPath(toObject, ['method'], fromMethod);\n    }\n    const fromCategory = getValueByPath(fromObject, ['category']);\n    if (fromCategory != null) {\n        setValueByPath(toObject, ['category'], fromCategory);\n    }\n    const fromThreshold = getValueByPath(fromObject, ['threshold']);\n    if (fromThreshold != null) {\n        setValueByPath(toObject, ['threshold'], fromThreshold);\n    }\n    return toObject;\n}\nfunction schemaToMldev(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, ['anyOf']);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, ['anyOf'], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, ['default']);\n    if (fromDefault != null) {\n        setValueByPath(toObject, ['default'], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, ['enum']);\n    if (fromEnum != null) {\n        setValueByPath(toObject, ['enum'], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, ['example']);\n    if (fromExample != null) {\n        setValueByPath(toObject, ['example'], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, ['items']);\n    if (fromItems != null) {\n        setValueByPath(toObject, ['items'], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, ['maxItems']);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, ['maxItems'], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, ['maxLength']);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, ['maxLength'], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        'maxProperties',\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, ['maxProperties'], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, ['maximum']);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, ['maximum'], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, ['minItems']);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, ['minItems'], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, ['minLength']);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, ['minLength'], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        'minProperties',\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, ['minProperties'], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, ['minimum']);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, ['minimum'], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, ['nullable']);\n    if (fromNullable != null) {\n        setValueByPath(toObject, ['nullable'], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, ['pattern']);\n    if (fromPattern != null) {\n        setValueByPath(toObject, ['pattern'], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, ['properties']);\n    if (fromProperties != null) {\n        setValueByPath(toObject, ['properties'], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        'propertyOrdering',\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, ['propertyOrdering'], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, ['required']);\n    if (fromRequired != null) {\n        setValueByPath(toObject, ['required'], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (fromTitle != null) {\n        setValueByPath(toObject, ['title'], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, ['type']);\n    if (fromType != null) {\n        setValueByPath(toObject, ['type'], fromType);\n    }\n    return toObject;\n}\nfunction schemaToVertex(fromObject) {\n    const toObject = {};\n    const fromAnyOf = getValueByPath(fromObject, ['anyOf']);\n    if (fromAnyOf != null) {\n        setValueByPath(toObject, ['anyOf'], fromAnyOf);\n    }\n    const fromDefault = getValueByPath(fromObject, ['default']);\n    if (fromDefault != null) {\n        setValueByPath(toObject, ['default'], fromDefault);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromEnum = getValueByPath(fromObject, ['enum']);\n    if (fromEnum != null) {\n        setValueByPath(toObject, ['enum'], fromEnum);\n    }\n    const fromExample = getValueByPath(fromObject, ['example']);\n    if (fromExample != null) {\n        setValueByPath(toObject, ['example'], fromExample);\n    }\n    const fromFormat = getValueByPath(fromObject, ['format']);\n    if (fromFormat != null) {\n        setValueByPath(toObject, ['format'], fromFormat);\n    }\n    const fromItems = getValueByPath(fromObject, ['items']);\n    if (fromItems != null) {\n        setValueByPath(toObject, ['items'], fromItems);\n    }\n    const fromMaxItems = getValueByPath(fromObject, ['maxItems']);\n    if (fromMaxItems != null) {\n        setValueByPath(toObject, ['maxItems'], fromMaxItems);\n    }\n    const fromMaxLength = getValueByPath(fromObject, ['maxLength']);\n    if (fromMaxLength != null) {\n        setValueByPath(toObject, ['maxLength'], fromMaxLength);\n    }\n    const fromMaxProperties = getValueByPath(fromObject, [\n        'maxProperties',\n    ]);\n    if (fromMaxProperties != null) {\n        setValueByPath(toObject, ['maxProperties'], fromMaxProperties);\n    }\n    const fromMaximum = getValueByPath(fromObject, ['maximum']);\n    if (fromMaximum != null) {\n        setValueByPath(toObject, ['maximum'], fromMaximum);\n    }\n    const fromMinItems = getValueByPath(fromObject, ['minItems']);\n    if (fromMinItems != null) {\n        setValueByPath(toObject, ['minItems'], fromMinItems);\n    }\n    const fromMinLength = getValueByPath(fromObject, ['minLength']);\n    if (fromMinLength != null) {\n        setValueByPath(toObject, ['minLength'], fromMinLength);\n    }\n    const fromMinProperties = getValueByPath(fromObject, [\n        'minProperties',\n    ]);\n    if (fromMinProperties != null) {\n        setValueByPath(toObject, ['minProperties'], fromMinProperties);\n    }\n    const fromMinimum = getValueByPath(fromObject, ['minimum']);\n    if (fromMinimum != null) {\n        setValueByPath(toObject, ['minimum'], fromMinimum);\n    }\n    const fromNullable = getValueByPath(fromObject, ['nullable']);\n    if (fromNullable != null) {\n        setValueByPath(toObject, ['nullable'], fromNullable);\n    }\n    const fromPattern = getValueByPath(fromObject, ['pattern']);\n    if (fromPattern != null) {\n        setValueByPath(toObject, ['pattern'], fromPattern);\n    }\n    const fromProperties = getValueByPath(fromObject, ['properties']);\n    if (fromProperties != null) {\n        setValueByPath(toObject, ['properties'], fromProperties);\n    }\n    const fromPropertyOrdering = getValueByPath(fromObject, [\n        'propertyOrdering',\n    ]);\n    if (fromPropertyOrdering != null) {\n        setValueByPath(toObject, ['propertyOrdering'], fromPropertyOrdering);\n    }\n    const fromRequired = getValueByPath(fromObject, ['required']);\n    if (fromRequired != null) {\n        setValueByPath(toObject, ['required'], fromRequired);\n    }\n    const fromTitle = getValueByPath(fromObject, ['title']);\n    if (fromTitle != null) {\n        setValueByPath(toObject, ['title'], fromTitle);\n    }\n    const fromType = getValueByPath(fromObject, ['type']);\n    if (fromType != null) {\n        setValueByPath(toObject, ['type'], fromType);\n    }\n    return toObject;\n}\nfunction scribbleImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    return toObject;\n}\nfunction segmentImageConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    const fromMaxPredictions = getValueByPath(fromObject, [\n        'maxPredictions',\n    ]);\n    if (parentObject !== undefined && fromMaxPredictions != null) {\n        setValueByPath(parentObject, ['parameters', 'maxPredictions'], fromMaxPredictions);\n    }\n    const fromConfidenceThreshold = getValueByPath(fromObject, [\n        'confidenceThreshold',\n    ]);\n    if (parentObject !== undefined && fromConfidenceThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'confidenceThreshold'], fromConfidenceThreshold);\n    }\n    const fromMaskDilation = getValueByPath(fromObject, ['maskDilation']);\n    if (parentObject !== undefined && fromMaskDilation != null) {\n        setValueByPath(parentObject, ['parameters', 'maskDilation'], fromMaskDilation);\n    }\n    const fromBinaryColorThreshold = getValueByPath(fromObject, [\n        'binaryColorThreshold',\n    ]);\n    if (parentObject !== undefined && fromBinaryColorThreshold != null) {\n        setValueByPath(parentObject, ['parameters', 'binaryColorThreshold'], fromBinaryColorThreshold);\n    }\n    return toObject;\n}\nfunction segmentImageParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromSource = getValueByPath(fromObject, ['source']);\n    if (fromSource != null) {\n        segmentImageSourceToVertex(fromSource, toObject);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        segmentImageConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction segmentImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromGeneratedMasks = getValueByPath(fromObject, ['predictions']);\n    if (fromGeneratedMasks != null) {\n        let transformedList = fromGeneratedMasks;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageMaskFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedMasks'], transformedList);\n    }\n    return toObject;\n}\nfunction segmentImageSourceToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPrompt = getValueByPath(fromObject, ['prompt']);\n    if (parentObject !== undefined && fromPrompt != null) {\n        setValueByPath(parentObject, ['instances[0]', 'prompt'], fromPrompt);\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (parentObject !== undefined && fromImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromScribbleImage = getValueByPath(fromObject, [\n        'scribbleImage',\n    ]);\n    if (parentObject !== undefined && fromScribbleImage != null) {\n        setValueByPath(parentObject, ['instances[0]', 'scribble'], scribbleImageToVertex(fromScribbleImage));\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, ['speaker']);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, ['speaker'], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev$1(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        'multiSpeakerVoiceConfig',\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, ['multiSpeakerVoiceConfig'], multiSpeakerVoiceConfigToMldev$1(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction speechConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToVertex(fromVoiceConfig));\n    }\n    if (getValueByPath(fromObject, ['multiSpeakerVoiceConfig']) !== undefined) {\n        throw new Error('multiSpeakerVoiceConfig parameter is not supported in Vertex AI.');\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction styleReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromStyleDescription = getValueByPath(fromObject, [\n        'styleDescription',\n    ]);\n    if (fromStyleDescription != null) {\n        setValueByPath(toObject, ['styleDescription'], fromStyleDescription);\n    }\n    return toObject;\n}\nfunction subjectReferenceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromSubjectType = getValueByPath(fromObject, ['subjectType']);\n    if (fromSubjectType != null) {\n        setValueByPath(toObject, ['subjectType'], fromSubjectType);\n    }\n    const fromSubjectDescription = getValueByPath(fromObject, [\n        'subjectDescription',\n    ]);\n    if (fromSubjectDescription != null) {\n        setValueByPath(toObject, ['subjectDescription'], fromSubjectDescription);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        'includeThoughts',\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        'thinkingBudget',\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, ['thinkingBudget'], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction thinkingConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        'includeThoughts',\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        'thinkingBudget',\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, ['thinkingBudget'], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToMldev(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], retrievalConfigToMldev(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionCallingConfig = getValueByPath(fromObject, [\n        'functionCallingConfig',\n    ]);\n    if (fromFunctionCallingConfig != null) {\n        setValueByPath(toObject, ['functionCallingConfig'], functionCallingConfigToVertex(fromFunctionCallingConfig));\n    }\n    const fromRetrievalConfig = getValueByPath(fromObject, [\n        'retrievalConfig',\n    ]);\n    if (fromRetrievalConfig != null) {\n        setValueByPath(toObject, ['retrievalConfig'], retrievalConfigToVertex(fromRetrievalConfig));\n    }\n    return toObject;\n}\nfunction toolToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToMldev$1(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev$1(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToMldev$1(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['googleMaps']) !== undefined) {\n        throw new Error('googleMaps parameter is not supported in Gemini API.');\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToMldev$1());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToMldev$1(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction toolToVertex(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    const fromRetrieval = getValueByPath(fromObject, ['retrieval']);\n    if (fromRetrieval != null) {\n        setValueByPath(toObject, ['retrieval'], fromRetrieval);\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToVertex(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToVertex(fromGoogleSearchRetrieval));\n    }\n    const fromEnterpriseWebSearch = getValueByPath(fromObject, [\n        'enterpriseWebSearch',\n    ]);\n    if (fromEnterpriseWebSearch != null) {\n        setValueByPath(toObject, ['enterpriseWebSearch'], enterpriseWebSearchToVertex(fromEnterpriseWebSearch));\n    }\n    const fromGoogleMaps = getValueByPath(fromObject, ['googleMaps']);\n    if (fromGoogleMaps != null) {\n        setValueByPath(toObject, ['googleMaps'], googleMapsToVertex(fromGoogleMaps));\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToVertex());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToVertex(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction tunedModelInfoFromVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, [\n        'labels',\n        'google-vertex-llm-tuning-base-model-id',\n    ]);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    return toObject;\n}\nfunction updateModelConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromDisplayName = getValueByPath(fromObject, ['displayName']);\n    if (parentObject !== undefined && fromDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromDefaultCheckpointId = getValueByPath(fromObject, [\n        'defaultCheckpointId',\n    ]);\n    if (parentObject !== undefined && fromDefaultCheckpointId != null) {\n        setValueByPath(parentObject, ['defaultCheckpointId'], fromDefaultCheckpointId);\n    }\n    return toObject;\n}\nfunction updateModelParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'name'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction updateModelParametersToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        updateModelConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIConfigInternalToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromOutputGcsUri = getValueByPath(fromObject, ['outputGcsUri']);\n    if (parentObject !== undefined && fromOutputGcsUri != null) {\n        setValueByPath(parentObject, ['parameters', 'storageUri'], fromOutputGcsUri);\n    }\n    const fromIncludeRaiReason = getValueByPath(fromObject, [\n        'includeRaiReason',\n    ]);\n    if (parentObject !== undefined && fromIncludeRaiReason != null) {\n        setValueByPath(parentObject, ['parameters', 'includeRaiReason'], fromIncludeRaiReason);\n    }\n    const fromOutputMimeType = getValueByPath(fromObject, [\n        'outputMimeType',\n    ]);\n    if (parentObject !== undefined && fromOutputMimeType != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'mimeType'], fromOutputMimeType);\n    }\n    const fromOutputCompressionQuality = getValueByPath(fromObject, [\n        'outputCompressionQuality',\n    ]);\n    if (parentObject !== undefined && fromOutputCompressionQuality != null) {\n        setValueByPath(parentObject, ['parameters', 'outputOptions', 'compressionQuality'], fromOutputCompressionQuality);\n    }\n    const fromEnhanceInputImage = getValueByPath(fromObject, [\n        'enhanceInputImage',\n    ]);\n    if (parentObject !== undefined && fromEnhanceInputImage != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'enhanceInputImage'], fromEnhanceInputImage);\n    }\n    const fromImagePreservationFactor = getValueByPath(fromObject, [\n        'imagePreservationFactor',\n    ]);\n    if (parentObject !== undefined && fromImagePreservationFactor != null) {\n        setValueByPath(parentObject, ['parameters', 'upscaleConfig', 'imagePreservationFactor'], fromImagePreservationFactor);\n    }\n    const fromNumberOfImages = getValueByPath(fromObject, [\n        'numberOfImages',\n    ]);\n    if (parentObject !== undefined && fromNumberOfImages != null) {\n        setValueByPath(parentObject, ['parameters', 'sampleCount'], fromNumberOfImages);\n    }\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (parentObject !== undefined && fromMode != null) {\n        setValueByPath(parentObject, ['parameters', 'mode'], fromMode);\n    }\n    return toObject;\n}\nfunction upscaleImageAPIParametersInternalToVertex(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['_url', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['instances[0]', 'image'], imageToVertex(fromImage));\n    }\n    const fromUpscaleFactor = getValueByPath(fromObject, [\n        'upscaleFactor',\n    ]);\n    if (fromUpscaleFactor != null) {\n        setValueByPath(toObject, ['parameters', 'upscaleConfig', 'upscaleFactor'], fromUpscaleFactor);\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        upscaleImageAPIConfigInternalToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction upscaleImageResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromGeneratedImages = getValueByPath(fromObject, [\n        'predictions',\n    ]);\n    if (fromGeneratedImages != null) {\n        let transformedList = fromGeneratedImages;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return generatedImageFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['generatedImages'], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, ['urlMetadata']);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return urlMetadataFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['urlMetadata'], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromUrlMetadata = getValueByPath(fromObject, ['urlMetadata']);\n    if (fromUrlMetadata != null) {\n        let transformedList = fromUrlMetadata;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return urlMetadataFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['urlMetadata'], transformedList);\n    }\n    return toObject;\n}\nfunction urlContextToMldev$1() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlContextToVertex() {\n    const toObject = {};\n    return toObject;\n}\nfunction urlMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, ['retrievedUrl']);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, ['retrievedUrl'], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        'urlRetrievalStatus',\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, ['urlRetrievalStatus'], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction urlMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromRetrievedUrl = getValueByPath(fromObject, ['retrievedUrl']);\n    if (fromRetrievedUrl != null) {\n        setValueByPath(toObject, ['retrievedUrl'], fromRetrievedUrl);\n    }\n    const fromUrlRetrievalStatus = getValueByPath(fromObject, [\n        'urlRetrievalStatus',\n    ]);\n    if (fromUrlRetrievalStatus != null) {\n        setValueByPath(toObject, ['urlRetrievalStatus'], fromUrlRetrievalStatus);\n    }\n    return toObject;\n}\nfunction videoFromMldev(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['video', 'uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'video',\n        'encodedVideo',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['encoding']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoFromVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['uri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, [\n        'bytesBase64Encoded',\n    ]);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['videoBytes'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction videoGenerationMaskToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['_self'], imageToVertex(fromImage));\n    }\n    const fromMaskMode = getValueByPath(fromObject, ['maskMode']);\n    if (fromMaskMode != null) {\n        setValueByPath(toObject, ['maskMode'], fromMaskMode);\n    }\n    return toObject;\n}\nfunction videoGenerationReferenceImageToVertex(fromObject) {\n    const toObject = {};\n    const fromImage = getValueByPath(fromObject, ['image']);\n    if (fromImage != null) {\n        setValueByPath(toObject, ['image'], imageToVertex(fromImage));\n    }\n    const fromReferenceType = getValueByPath(fromObject, [\n        'referenceType',\n    ]);\n    if (fromReferenceType != null) {\n        setValueByPath(toObject, ['referenceType'], fromReferenceType);\n    }\n    return toObject;\n}\nfunction videoMetadataFromMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataFromVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToMldev$1(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoMetadataToVertex(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction videoToVertex(fromObject) {\n    const toObject = {};\n    const fromUri = getValueByPath(fromObject, ['uri']);\n    if (fromUri != null) {\n        setValueByPath(toObject, ['gcsUri'], fromUri);\n    }\n    const fromVideoBytes = getValueByPath(fromObject, ['videoBytes']);\n    if (fromVideoBytes != null) {\n        setValueByPath(toObject, ['bytesBase64Encoded'], tBytes(fromVideoBytes));\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev$1(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        'prebuiltVoiceConfig',\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, ['prebuiltVoiceConfig'], prebuiltVoiceConfigToMldev$1(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\nfunction voiceConfigToVertex(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        'prebuiltVoiceConfig',\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, ['prebuiltVoiceConfig'], prebuiltVoiceConfigToVertex(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst CONTENT_TYPE_HEADER = 'Content-Type';\nconst SERVER_TIMEOUT_HEADER = 'X-Server-Timeout';\nconst USER_AGENT_HEADER = 'User-Agent';\nconst GOOGLE_API_CLIENT_HEADER = 'x-goog-api-client';\nconst SDK_VERSION = '1.22.0'; // x-release-please-version\nconst LIBRARY_LABEL = `google-genai-sdk/${SDK_VERSION}`;\nconst VERTEX_AI_API_DEFAULT_VERSION = 'v1beta1';\nconst GOOGLE_AI_API_DEFAULT_VERSION = 'v1beta';\nconst responseLineRE = /^\\s*data: (.*)(?:\\n\\n|\\r\\r|\\r\\n\\r\\n)/;\n/**\n * The ApiClient class is used to send requests to the Gemini API or Vertex AI\n * endpoints.\n */\nclass ApiClient {\n    constructor(opts) {\n        var _a, _b;\n        this.clientOptions = Object.assign(Object.assign({}, opts), { project: opts.project, location: opts.location, apiKey: opts.apiKey, vertexai: opts.vertexai });\n        const initHttpOptions = {};\n        if (this.clientOptions.vertexai) {\n            initHttpOptions.apiVersion =\n                (_a = this.clientOptions.apiVersion) !== null && _a !== void 0 ? _a : VERTEX_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = this.baseUrlFromProjectLocation();\n            this.normalizeAuthParameters();\n        }\n        else {\n            // Gemini API\n            initHttpOptions.apiVersion =\n                (_b = this.clientOptions.apiVersion) !== null && _b !== void 0 ? _b : GOOGLE_AI_API_DEFAULT_VERSION;\n            initHttpOptions.baseUrl = `https://generativelanguage.googleapis.com/`;\n        }\n        initHttpOptions.headers = this.getDefaultHeaders();\n        this.clientOptions.httpOptions = initHttpOptions;\n        if (opts.httpOptions) {\n            this.clientOptions.httpOptions = this.patchHttpOptions(initHttpOptions, opts.httpOptions);\n        }\n    }\n    /**\n     * Determines the base URL for Vertex AI based on project and location.\n     * Uses the global endpoint if location is 'global' or if project/location\n     * are not specified (implying API key usage).\n     * @private\n     */\n    baseUrlFromProjectLocation() {\n        if (this.clientOptions.project &&\n            this.clientOptions.location &&\n            this.clientOptions.location !== 'global') {\n            // Regional endpoint\n            return `https://${this.clientOptions.location}-aiplatform.googleapis.com/`;\n        }\n        // Global endpoint (covers 'global' location and API key usage)\n        return `https://aiplatform.googleapis.com/`;\n    }\n    /**\n     * Normalizes authentication parameters for Vertex AI.\n     * If project and location are provided, API key is cleared.\n     * If project and location are not provided (implying API key usage),\n     * project and location are cleared.\n     * @private\n     */\n    normalizeAuthParameters() {\n        if (this.clientOptions.project && this.clientOptions.location) {\n            // Using project/location for auth, clear potential API key\n            this.clientOptions.apiKey = undefined;\n            return;\n        }\n        // Using API key for auth (or no auth provided yet), clear project/location\n        this.clientOptions.project = undefined;\n        this.clientOptions.location = undefined;\n    }\n    isVertexAI() {\n        var _a;\n        return (_a = this.clientOptions.vertexai) !== null && _a !== void 0 ? _a : false;\n    }\n    getProject() {\n        return this.clientOptions.project;\n    }\n    getLocation() {\n        return this.clientOptions.location;\n    }\n    getApiVersion() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.apiVersion !== undefined) {\n            return this.clientOptions.httpOptions.apiVersion;\n        }\n        throw new Error('API version is not set.');\n    }\n    getBaseUrl() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.baseUrl !== undefined) {\n            return this.clientOptions.httpOptions.baseUrl;\n        }\n        throw new Error('Base URL is not set.');\n    }\n    getRequestUrl() {\n        return this.getRequestUrlInternal(this.clientOptions.httpOptions);\n    }\n    getHeaders() {\n        if (this.clientOptions.httpOptions &&\n            this.clientOptions.httpOptions.headers !== undefined) {\n            return this.clientOptions.httpOptions.headers;\n        }\n        else {\n            throw new Error('Headers are not set.');\n        }\n    }\n    getRequestUrlInternal(httpOptions) {\n        if (!httpOptions ||\n            httpOptions.baseUrl === undefined ||\n            httpOptions.apiVersion === undefined) {\n            throw new Error('HTTP options are not correctly set.');\n        }\n        const baseUrl = httpOptions.baseUrl.endsWith('/')\n            ? httpOptions.baseUrl.slice(0, -1)\n            : httpOptions.baseUrl;\n        const urlElement = [baseUrl];\n        if (httpOptions.apiVersion && httpOptions.apiVersion !== '') {\n            urlElement.push(httpOptions.apiVersion);\n        }\n        return urlElement.join('/');\n    }\n    getBaseResourcePath() {\n        return `projects/${this.clientOptions.project}/locations/${this.clientOptions.location}`;\n    }\n    getApiKey() {\n        return this.clientOptions.apiKey;\n    }\n    getWebsocketBaseUrl() {\n        const baseUrl = this.getBaseUrl();\n        const urlParts = new URL(baseUrl);\n        urlParts.protocol = urlParts.protocol == 'http:' ? 'ws' : 'wss';\n        return urlParts.toString();\n    }\n    setBaseUrl(url) {\n        if (this.clientOptions.httpOptions) {\n            this.clientOptions.httpOptions.baseUrl = url;\n        }\n        else {\n            throw new Error('HTTP options are not correctly set.');\n        }\n    }\n    constructUrl(path, httpOptions, prependProjectLocation) {\n        const urlElement = [this.getRequestUrlInternal(httpOptions)];\n        if (prependProjectLocation) {\n            urlElement.push(this.getBaseResourcePath());\n        }\n        if (path !== '') {\n            urlElement.push(path);\n        }\n        const url = new URL(`${urlElement.join('/')}`);\n        return url;\n    }\n    shouldPrependVertexProjectPath(request) {\n        if (this.clientOptions.apiKey) {\n            return false;\n        }\n        if (!this.clientOptions.vertexai) {\n            return false;\n        }\n        if (request.path.startsWith('projects/')) {\n            // Assume the path already starts with\n            // `projects/<project>/location/<location>`.\n            return false;\n        }\n        if (request.httpMethod === 'GET' &&\n            request.path.startsWith('publishers/google/models')) {\n            // These paths are used by Vertex's models.get and models.list\n            // calls. For base models Vertex does not accept a project/location\n            // prefix (for tuned model the prefix is required).\n            return false;\n        }\n        return true;\n    }\n    async request(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (request.queryParams) {\n            for (const [key, value] of Object.entries(request.queryParams)) {\n                url.searchParams.append(key, String(value));\n            }\n        }\n        let requestInit = {};\n        if (request.httpMethod === 'GET') {\n            if (request.body && request.body !== '{}') {\n                throw new Error('Request body should be empty for GET request, but got non empty request body');\n            }\n        }\n        else {\n            requestInit.body = request.body;\n        }\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.unaryApiCall(url, requestInit, request.httpMethod);\n    }\n    patchHttpOptions(baseHttpOptions, requestHttpOptions) {\n        const patchedHttpOptions = JSON.parse(JSON.stringify(baseHttpOptions));\n        for (const [key, value] of Object.entries(requestHttpOptions)) {\n            // Records compile to objects.\n            if (typeof value === 'object') {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = Object.assign(Object.assign({}, patchedHttpOptions[key]), value);\n            }\n            else if (value !== undefined) {\n                // @ts-expect-error TS2345TS7053: Element implicitly has an 'any' type\n                // because expression of type 'string' can't be used to index type\n                // 'HttpOptions'.\n                patchedHttpOptions[key] = value;\n            }\n        }\n        return patchedHttpOptions;\n    }\n    async requestStream(request) {\n        let patchedHttpOptions = this.clientOptions.httpOptions;\n        if (request.httpOptions) {\n            patchedHttpOptions = this.patchHttpOptions(this.clientOptions.httpOptions, request.httpOptions);\n        }\n        const prependProjectLocation = this.shouldPrependVertexProjectPath(request);\n        const url = this.constructUrl(request.path, patchedHttpOptions, prependProjectLocation);\n        if (!url.searchParams.has('alt') || url.searchParams.get('alt') !== 'sse') {\n            url.searchParams.set('alt', 'sse');\n        }\n        let requestInit = {};\n        requestInit.body = request.body;\n        requestInit = await this.includeExtraHttpOptionsToRequestInit(requestInit, patchedHttpOptions, request.abortSignal);\n        return this.streamApiCall(url, requestInit, request.httpMethod);\n    }\n    async includeExtraHttpOptionsToRequestInit(requestInit, httpOptions, abortSignal) {\n        if ((httpOptions && httpOptions.timeout) || abortSignal) {\n            const abortController = new AbortController();\n            const signal = abortController.signal;\n            if (httpOptions.timeout && (httpOptions === null || httpOptions === void 0 ? void 0 : httpOptions.timeout) > 0) {\n                const timeoutHandle = setTimeout(() => abortController.abort(), httpOptions.timeout);\n                if (timeoutHandle &&\n                    typeof timeoutHandle.unref ===\n                        'function') {\n                    // call unref to prevent nodejs process from hanging, see\n                    // https://nodejs.org/api/timers.html#timeoutunref\n                    timeoutHandle.unref();\n                }\n            }\n            if (abortSignal) {\n                abortSignal.addEventListener('abort', () => {\n                    abortController.abort();\n                });\n            }\n            requestInit.signal = signal;\n        }\n        if (httpOptions && httpOptions.extraBody !== null) {\n            includeExtraBodyToRequestInit(requestInit, httpOptions.extraBody);\n        }\n        requestInit.headers = await this.getHeadersInternal(httpOptions);\n        return requestInit;\n    }\n    async unaryApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return new HttpResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    async streamApiCall(url, requestInit, httpMethod) {\n        return this.apiCall(url.toString(), Object.assign(Object.assign({}, requestInit), { method: httpMethod }))\n            .then(async (response) => {\n            await throwErrorIfNotOK(response);\n            return this.processStreamResponse(response);\n        })\n            .catch((e) => {\n            if (e instanceof Error) {\n                throw e;\n            }\n            else {\n                throw new Error(JSON.stringify(e));\n            }\n        });\n    }\n    processStreamResponse(response) {\n        var _a;\n        return __asyncGenerator(this, arguments, function* processStreamResponse_1() {\n            const reader = (_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n            const decoder = new TextDecoder('utf-8');\n            if (!reader) {\n                throw new Error('Response body is empty');\n            }\n            try {\n                let buffer = '';\n                while (true) {\n                    const { done, value } = yield __await(reader.read());\n                    if (done) {\n                        if (buffer.trim().length > 0) {\n                            throw new Error('Incomplete JSON segment at the end');\n                        }\n                        break;\n                    }\n                    const chunkString = decoder.decode(value, { stream: true });\n                    // Parse and throw an error if the chunk contains an error.\n                    try {\n                        const chunkJson = JSON.parse(chunkString);\n                        if ('error' in chunkJson) {\n                            const errorJson = JSON.parse(JSON.stringify(chunkJson['error']));\n                            const status = errorJson['status'];\n                            const code = errorJson['code'];\n                            const errorMessage = `got status: ${status}. ${JSON.stringify(chunkJson)}`;\n                            if (code >= 400 && code < 600) {\n                                const apiError = new ApiError({\n                                    message: errorMessage,\n                                    status: code,\n                                });\n                                throw apiError;\n                            }\n                        }\n                    }\n                    catch (e) {\n                        const error = e;\n                        if (error.name === 'ApiError') {\n                            throw e;\n                        }\n                    }\n                    buffer += chunkString;\n                    let match = buffer.match(responseLineRE);\n                    while (match) {\n                        const processedChunkString = match[1];\n                        try {\n                            const partialResponse = new Response(processedChunkString, {\n                                headers: response === null || response === void 0 ? void 0 : response.headers,\n                                status: response === null || response === void 0 ? void 0 : response.status,\n                                statusText: response === null || response === void 0 ? void 0 : response.statusText,\n                            });\n                            yield yield __await(new HttpResponse(partialResponse));\n                            buffer = buffer.slice(match[0].length);\n                            match = buffer.match(responseLineRE);\n                        }\n                        catch (e) {\n                            throw new Error(`exception parsing stream chunk ${processedChunkString}. ${e}`);\n                        }\n                    }\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        });\n    }\n    async apiCall(url, requestInit) {\n        return fetch(url, requestInit).catch((e) => {\n            throw new Error(`exception ${e} sending request`);\n        });\n    }\n    getDefaultHeaders() {\n        const headers = {};\n        const versionHeaderValue = LIBRARY_LABEL + ' ' + this.clientOptions.userAgentExtra;\n        headers[USER_AGENT_HEADER] = versionHeaderValue;\n        headers[GOOGLE_API_CLIENT_HEADER] = versionHeaderValue;\n        headers[CONTENT_TYPE_HEADER] = 'application/json';\n        return headers;\n    }\n    async getHeadersInternal(httpOptions) {\n        const headers = new Headers();\n        if (httpOptions && httpOptions.headers) {\n            for (const [key, value] of Object.entries(httpOptions.headers)) {\n                headers.append(key, value);\n            }\n            // Append a timeout header if it is set, note that the timeout option is\n            // in milliseconds but the header is in seconds.\n            if (httpOptions.timeout && httpOptions.timeout > 0) {\n                headers.append(SERVER_TIMEOUT_HEADER, String(Math.ceil(httpOptions.timeout / 1000)));\n            }\n        }\n        await this.clientOptions.auth.addAuthHeaders(headers);\n        return headers;\n    }\n    /**\n     * Uploads a file asynchronously using Gemini API only, this is not supported\n     * in Vertex AI.\n     *\n     * @param file The string path to the file to be uploaded or a Blob object.\n     * @param config Optional parameters specified in the `UploadFileConfig`\n     *     interface. @see {@link UploadFileConfig}\n     * @return A promise that resolves to a `File` object.\n     * @throws An error if called on a Vertex AI client.\n     * @throws An error if the `mimeType` is not provided and can not be inferred,\n     */\n    async uploadFile(file, config) {\n        var _a;\n        const fileToUpload = {};\n        if (config != null) {\n            fileToUpload.mimeType = config.mimeType;\n            fileToUpload.name = config.name;\n            fileToUpload.displayName = config.displayName;\n        }\n        if (fileToUpload.name && !fileToUpload.name.startsWith('files/')) {\n            fileToUpload.name = `files/${fileToUpload.name}`;\n        }\n        const uploader = this.clientOptions.uploader;\n        const fileStat = await uploader.stat(file);\n        fileToUpload.sizeBytes = String(fileStat.size);\n        const mimeType = (_a = config === null || config === void 0 ? void 0 : config.mimeType) !== null && _a !== void 0 ? _a : fileStat.type;\n        if (mimeType === undefined || mimeType === '') {\n            throw new Error('Can not determine mimeType. Please provide mimeType in the config.');\n        }\n        fileToUpload.mimeType = mimeType;\n        const uploadUrl = await this.fetchUploadUrl(fileToUpload, config);\n        return uploader.upload(file, uploadUrl, this);\n    }\n    /**\n     * Downloads a file asynchronously to the specified path.\n     *\n     * @params params - The parameters for the download request, see {@link\n     * DownloadFileParameters}\n     */\n    async downloadFile(params) {\n        const downloader = this.clientOptions.downloader;\n        await downloader.download(params, this);\n    }\n    async fetchUploadUrl(file, config) {\n        var _a;\n        let httpOptions = {};\n        if (config === null || config === void 0 ? void 0 : config.httpOptions) {\n            httpOptions = config.httpOptions;\n        }\n        else {\n            httpOptions = {\n                apiVersion: '',\n                headers: {\n                    'Content-Type': 'application/json',\n                    'X-Goog-Upload-Protocol': 'resumable',\n                    'X-Goog-Upload-Command': 'start',\n                    'X-Goog-Upload-Header-Content-Length': `${file.sizeBytes}`,\n                    'X-Goog-Upload-Header-Content-Type': `${file.mimeType}`,\n                },\n            };\n        }\n        const body = {\n            'file': file,\n        };\n        const httpResponse = await this.request({\n            path: formatMap('upload/v1beta/files', body['_url']),\n            body: JSON.stringify(body),\n            httpMethod: 'POST',\n            httpOptions,\n        });\n        if (!httpResponse || !(httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers)) {\n            throw new Error('Server did not return an HttpResponse or the returned HttpResponse did not have headers.');\n        }\n        const uploadUrl = (_a = httpResponse === null || httpResponse === void 0 ? void 0 : httpResponse.headers) === null || _a === void 0 ? void 0 : _a['x-goog-upload-url'];\n        if (uploadUrl === undefined) {\n            throw new Error('Failed to get upload url. Server did not return the x-google-upload-url in the headers');\n        }\n        return uploadUrl;\n    }\n}\nasync function throwErrorIfNotOK(response) {\n    var _a;\n    if (response === undefined) {\n        throw new Error('response is undefined');\n    }\n    if (!response.ok) {\n        const status = response.status;\n        let errorBody;\n        if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n            errorBody = await response.json();\n        }\n        else {\n            errorBody = {\n                error: {\n                    message: await response.text(),\n                    code: response.status,\n                    status: response.statusText,\n                },\n            };\n        }\n        const errorMessage = JSON.stringify(errorBody);\n        if (status >= 400 && status < 600) {\n            const apiError = new ApiError({\n                message: errorMessage,\n                status: status,\n            });\n            throw apiError;\n        }\n        throw new Error(errorMessage);\n    }\n}\n/**\n * Recursively updates the `requestInit.body` with values from an `extraBody` object.\n *\n * If `requestInit.body` is a string, it's assumed to be JSON and will be parsed.\n * The `extraBody` is then deeply merged into this parsed object.\n * If `requestInit.body` is a Blob, `extraBody` will be ignored, and a warning logged,\n * as merging structured data into an opaque Blob is not supported.\n *\n * The function does not enforce that updated values from `extraBody` have the\n * same type as existing values in `requestInit.body`. Type mismatches during\n * the merge will result in a warning, but the value from `extraBody` will overwrite\n * the original. `extraBody` users are responsible for ensuring `extraBody` has the correct structure.\n *\n * @param requestInit The RequestInit object whose body will be updated.\n * @param extraBody The object containing updates to be merged into `requestInit.body`.\n */\nfunction includeExtraBodyToRequestInit(requestInit, extraBody) {\n    if (!extraBody || Object.keys(extraBody).length === 0) {\n        return;\n    }\n    if (requestInit.body instanceof Blob) {\n        console.warn('includeExtraBodyToRequestInit: extraBody provided but current request body is a Blob. extraBody will be ignored as merging is not supported for Blob bodies.');\n        return;\n    }\n    let currentBodyObject = {};\n    // If adding new type to HttpRequest.body, please check the code below to\n    // see if we need to update the logic.\n    if (typeof requestInit.body === 'string' && requestInit.body.length > 0) {\n        try {\n            const parsedBody = JSON.parse(requestInit.body);\n            if (typeof parsedBody === 'object' &&\n                parsedBody !== null &&\n                !Array.isArray(parsedBody)) {\n                currentBodyObject = parsedBody;\n            }\n            else {\n                console.warn('includeExtraBodyToRequestInit: Original request body is valid JSON but not a non-array object. Skip applying extraBody to the request body.');\n                return;\n            }\n            /*  eslint-disable-next-line @typescript-eslint/no-unused-vars */\n        }\n        catch (e) {\n            console.warn('includeExtraBodyToRequestInit: Original request body is not valid JSON. Skip applying extraBody to the request body.');\n            return;\n        }\n    }\n    function deepMerge(target, source) {\n        const output = Object.assign({}, target);\n        for (const key in source) {\n            if (Object.prototype.hasOwnProperty.call(source, key)) {\n                const sourceValue = source[key];\n                const targetValue = output[key];\n                if (sourceValue &&\n                    typeof sourceValue === 'object' &&\n                    !Array.isArray(sourceValue) &&\n                    targetValue &&\n                    typeof targetValue === 'object' &&\n                    !Array.isArray(targetValue)) {\n                    output[key] = deepMerge(targetValue, sourceValue);\n                }\n                else {\n                    if (targetValue &&\n                        sourceValue &&\n                        typeof targetValue !== typeof sourceValue) {\n                        console.warn(`includeExtraBodyToRequestInit:deepMerge: Type mismatch for key \"${key}\". Original type: ${typeof targetValue}, New type: ${typeof sourceValue}. Overwriting.`);\n                    }\n                    output[key] = sourceValue;\n                }\n            }\n        }\n        return output;\n    }\n    const mergedBody = deepMerge(currentBodyObject, extraBody);\n    requestInit.body = JSON.stringify(mergedBody);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// TODO: b/416041229 - Determine how to retrieve the MCP package version.\nconst MCP_LABEL = 'mcp_used/unknown';\n// Whether MCP tool usage is detected from mcpToTool. This is used for\n// telemetry.\nlet hasMcpToolUsageFromMcpToTool = false;\n// Checks whether the list of tools contains any MCP tools.\nfunction hasMcpToolUsage(tools) {\n    for (const tool of tools) {\n        if (isMcpCallableTool(tool)) {\n            return true;\n        }\n        if (typeof tool === 'object' && 'inputSchema' in tool) {\n            return true;\n        }\n    }\n    return hasMcpToolUsageFromMcpToTool;\n}\n// Sets the MCP version label in the Google API client header.\nfunction setMcpUsageHeader(headers) {\n    var _a;\n    const existingHeader = (_a = headers[GOOGLE_API_CLIENT_HEADER]) !== null && _a !== void 0 ? _a : '';\n    headers[GOOGLE_API_CLIENT_HEADER] = (existingHeader + ` ${MCP_LABEL}`).trimStart();\n}\n// Returns true if the object is a MCP CallableTool, otherwise false.\nfunction isMcpCallableTool(object) {\n    return (object !== null &&\n        typeof object === 'object' &&\n        object instanceof McpCallableTool);\n}\n// List all tools from the MCP client.\nfunction listAllTools(mcpClient, maxTools = 100) {\n    return __asyncGenerator(this, arguments, function* listAllTools_1() {\n        let cursor = undefined;\n        let numTools = 0;\n        while (numTools < maxTools) {\n            const t = yield __await(mcpClient.listTools({ cursor }));\n            for (const tool of t.tools) {\n                yield yield __await(tool);\n                numTools++;\n            }\n            if (!t.nextCursor) {\n                break;\n            }\n            cursor = t.nextCursor;\n        }\n    });\n}\n/**\n * McpCallableTool can be used for model inference and invoking MCP clients with\n * given function call arguments.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nclass McpCallableTool {\n    constructor(mcpClients = [], config) {\n        this.mcpTools = [];\n        this.functionNameToMcpClient = {};\n        this.mcpClients = mcpClients;\n        this.config = config;\n    }\n    /**\n     * Creates a McpCallableTool.\n     */\n    static create(mcpClients, config) {\n        return new McpCallableTool(mcpClients, config);\n    }\n    /**\n     * Validates the function names are not duplicate and initialize the function\n     * name to MCP client mapping.\n     *\n     * @throws {Error} if the MCP tools from the MCP clients have duplicate tool\n     *     names.\n     */\n    async initialize() {\n        var _a, e_1, _b, _c;\n        if (this.mcpTools.length > 0) {\n            return;\n        }\n        const functionMap = {};\n        const mcpTools = [];\n        for (const mcpClient of this.mcpClients) {\n            try {\n                for (var _d = true, _e = (e_1 = void 0, __asyncValues(listAllTools(mcpClient))), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {\n                    _c = _f.value;\n                    _d = false;\n                    const mcpTool = _c;\n                    mcpTools.push(mcpTool);\n                    const mcpToolName = mcpTool.name;\n                    if (functionMap[mcpToolName]) {\n                        throw new Error(`Duplicate function name ${mcpToolName} found in MCP tools. Please ensure function names are unique.`);\n                    }\n                    functionMap[mcpToolName] = mcpClient;\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        this.mcpTools = mcpTools;\n        this.functionNameToMcpClient = functionMap;\n    }\n    async tool() {\n        await this.initialize();\n        return mcpToolsToGeminiTool(this.mcpTools, this.config);\n    }\n    async callTool(functionCalls) {\n        await this.initialize();\n        const functionCallResponseParts = [];\n        for (const functionCall of functionCalls) {\n            if (functionCall.name in this.functionNameToMcpClient) {\n                const mcpClient = this.functionNameToMcpClient[functionCall.name];\n                let requestOptions = undefined;\n                // TODO: b/424238654 - Add support for finer grained timeout control.\n                if (this.config.timeout) {\n                    requestOptions = {\n                        timeout: this.config.timeout,\n                    };\n                }\n                const callToolResponse = await mcpClient.callTool({\n                    name: functionCall.name,\n                    arguments: functionCall.args,\n                }, \n                // Set the result schema to undefined to allow MCP to rely on the\n                // default schema.\n                undefined, requestOptions);\n                functionCallResponseParts.push({\n                    functionResponse: {\n                        name: functionCall.name,\n                        response: callToolResponse.isError\n                            ? { error: callToolResponse }\n                            : callToolResponse,\n                    },\n                });\n            }\n        }\n        return functionCallResponseParts;\n    }\n}\nfunction isMcpClient(client) {\n    return (client !== null &&\n        typeof client === 'object' &&\n        'listTools' in client &&\n        typeof client.listTools === 'function');\n}\n/**\n * Creates a McpCallableTool from MCP clients and an optional config.\n *\n * The callable tool can invoke the MCP clients with given function call\n * arguments. (often for automatic function calling).\n * Use the config to modify tool parameters such as behavior.\n *\n * @experimental Built-in MCP support is an experimental feature, may change in future\n * versions.\n */\nfunction mcpToTool(...args) {\n    // Set MCP usage for telemetry.\n    hasMcpToolUsageFromMcpToTool = true;\n    if (args.length === 0) {\n        throw new Error('No MCP clients provided');\n    }\n    const maybeConfig = args[args.length - 1];\n    if (isMcpClient(maybeConfig)) {\n        return McpCallableTool.create(args, {});\n    }\n    return McpCallableTool.create(args.slice(0, args.length - 1), maybeConfig);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveMusicServerMessage, and then calling the onmessage callback.\n * Note that the first message which is received from the server is a\n * setupComplete message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage$1(apiClient, onmessage, event) {\n    const serverMessage = new LiveMusicServerMessage();\n    let data;\n    if (event.data instanceof Blob) {\n        data = JSON.parse(await event.data.text());\n    }\n    else {\n        data = JSON.parse(event.data);\n    }\n    const response = liveMusicServerMessageFromMldev(data);\n    Object.assign(serverMessage, response);\n    onmessage(serverMessage);\n}\n/**\n   LiveMusic class encapsulates the configuration for live music\n   generation via Lyria Live models.\n\n   @experimental\n  */\nclass LiveMusic {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n    }\n    /**\n       Establishes a connection to the specified model and returns a\n       LiveMusicSession object representing that connection.\n  \n       @experimental\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model = 'models/lyria-realtime-exp';\n       const session = await ai.live.music.connect({\n         model: model,\n         callbacks: {\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b;\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('Live music is not supported for Vertex AI.');\n        }\n        console.warn('Live music generation is experimental and may change in future versions.');\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        const headers = mapToHeaders$1(this.apiClient.getDefaultHeaders());\n        const apiKey = this.apiClient.getApiKey();\n        const url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.BidiGenerateMusic?key=${apiKey}`;\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage$1(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap$1(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        const model = tModel(this.apiClient, params.model);\n        const setup = liveMusicClientSetupToMldev({\n            model,\n        });\n        const clientMessage = liveMusicClientMessageToMldev({ setup });\n        conn.send(JSON.stringify(clientMessage));\n        return new LiveMusicSession(conn, this.apiClient);\n    }\n}\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass LiveMusicSession {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    /**\n      Sets inputs to steer music generation. Updates the session's current\n      weighted prompts.\n  \n      @param params - Contains one property, `weightedPrompts`.\n  \n        - `weightedPrompts` to send to the model; weights are normalized to\n          sum to 1.0.\n  \n      @experimental\n     */\n    async setWeightedPrompts(params) {\n        if (!params.weightedPrompts ||\n            Object.keys(params.weightedPrompts).length === 0) {\n            throw new Error('Weighted prompts must be set and contain at least one entry.');\n        }\n        const setWeightedPromptsParameters = liveMusicSetWeightedPromptsParametersToMldev(params);\n        const clientContent = liveMusicClientContentToMldev(setWeightedPromptsParameters);\n        this.conn.send(JSON.stringify({ clientContent }));\n    }\n    /**\n      Sets a configuration to the model. Updates the session's current\n      music generation config.\n  \n      @param params - Contains one property, `musicGenerationConfig`.\n  \n        - `musicGenerationConfig` to set in the model. Passing an empty or\n      undefined config to the model will reset the config to defaults.\n  \n      @experimental\n     */\n    async setMusicGenerationConfig(params) {\n        if (!params.musicGenerationConfig) {\n            params.musicGenerationConfig = {};\n        }\n        const setConfigParameters = liveMusicSetConfigParametersToMldev(params);\n        const clientMessage = liveMusicClientMessageToMldev(setConfigParameters);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    sendPlaybackControl(playbackControl) {\n        const clientMessage = liveMusicClientMessageToMldev({\n            playbackControl,\n        });\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n     * Start the music stream.\n     *\n     * @experimental\n     */\n    play() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PLAY);\n    }\n    /**\n     * Temporarily halt the music stream. Use `play` to resume from the current\n     * position.\n     *\n     * @experimental\n     */\n    pause() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.PAUSE);\n    }\n    /**\n     * Stop the music stream and reset the state. Retains the current prompts\n     * and config.\n     *\n     * @experimental\n     */\n    stop() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.STOP);\n    }\n    /**\n     * Resets the context of the music generation without stopping it.\n     * Retains the current prompts and config.\n     *\n     * @experimental\n     */\n    resetContext() {\n        this.sendPlaybackControl(LiveMusicPlaybackControl.RESET_CONTEXT);\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap$1(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders$1(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst FUNCTION_RESPONSE_REQUIRES_ID = 'FunctionResponse request must have an `id` field from the response of a ToolCall.FunctionalCalls in Google AI.';\n/**\n * Handles incoming messages from the WebSocket.\n *\n * @remarks\n * This function is responsible for parsing incoming messages, transforming them\n * into LiveServerMessages, and then calling the onmessage callback. Note that\n * the first message which is received from the server is a setupComplete\n * message.\n *\n * @param apiClient The ApiClient instance.\n * @param onmessage The user-provided onmessage callback (if any).\n * @param event The MessageEvent from the WebSocket.\n */\nasync function handleWebSocketMessage(apiClient, onmessage, event) {\n    const serverMessage = new LiveServerMessage();\n    let jsonData;\n    if (event.data instanceof Blob) {\n        jsonData = await event.data.text();\n    }\n    else if (event.data instanceof ArrayBuffer) {\n        jsonData = new TextDecoder().decode(event.data);\n    }\n    else {\n        jsonData = event.data;\n    }\n    const data = JSON.parse(jsonData);\n    if (apiClient.isVertexAI()) {\n        const resp = liveServerMessageFromVertex(data);\n        Object.assign(serverMessage, resp);\n    }\n    else {\n        const resp = liveServerMessageFromMldev(data);\n        Object.assign(serverMessage, resp);\n    }\n    onmessage(serverMessage);\n}\n/**\n   Live class encapsulates the configuration for live interaction with the\n   Generative Language API. It embeds ApiClient for general API settings.\n\n   @experimental\n  */\nclass Live {\n    constructor(apiClient, auth, webSocketFactory) {\n        this.apiClient = apiClient;\n        this.auth = auth;\n        this.webSocketFactory = webSocketFactory;\n        this.music = new LiveMusic(this.apiClient, this.auth, this.webSocketFactory);\n    }\n    /**\n       Establishes a connection to the specified model with the given\n       configuration and returns a Session object representing that connection.\n  \n       @experimental Built-in MCP support is an experimental feature, may change in\n       future versions.\n  \n       @remarks\n  \n       @param params - The parameters for establishing a connection to the model.\n       @return A live session.\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         },\n         callbacks: {\n           onopen: () => {\n             console.log('Connected to the socket.');\n           },\n           onmessage: (e: MessageEvent) => {\n             console.log('Received message from the server: %s\\n', debug(e.data));\n           },\n           onerror: (e: ErrorEvent) => {\n             console.log('Error occurred: %s\\n', debug(e.error));\n           },\n           onclose: (e: CloseEvent) => {\n             console.log('Connection closed.');\n           },\n         },\n       });\n       ```\n      */\n    async connect(params) {\n        var _a, _b, _c, _d, _e, _f;\n        // TODO: b/404946746 - Support per request HTTP options.\n        if (params.config && params.config.httpOptions) {\n            throw new Error('The Live module does not support httpOptions at request-level in' +\n                ' LiveConnectConfig yet. Please use the client-level httpOptions' +\n                ' configuration instead.');\n        }\n        const websocketBaseUrl = this.apiClient.getWebsocketBaseUrl();\n        const apiVersion = this.apiClient.getApiVersion();\n        let url;\n        const clientHeaders = this.apiClient.getHeaders();\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            setMcpUsageHeader(clientHeaders);\n        }\n        const headers = mapToHeaders(clientHeaders);\n        if (this.apiClient.isVertexAI()) {\n            url = `${websocketBaseUrl}/ws/google.cloud.aiplatform.${apiVersion}.LlmBidiService/BidiGenerateContent`;\n            await this.auth.addAuthHeaders(headers);\n        }\n        else {\n            const apiKey = this.apiClient.getApiKey();\n            let method = 'BidiGenerateContent';\n            let keyName = 'key';\n            if (apiKey === null || apiKey === void 0 ? void 0 : apiKey.startsWith('auth_tokens/')) {\n                console.warn('Warning: Ephemeral token support is experimental and may change in future versions.');\n                if (apiVersion !== 'v1alpha') {\n                    console.warn(\"Warning: The SDK's ephemeral token support is in v1alpha only. Please use const ai = new GoogleGenAI({apiKey: token.name, httpOptions: { apiVersion: 'v1alpha' }}); before session connection.\");\n                }\n                method = 'BidiGenerateContentConstrained';\n                keyName = 'access_token';\n            }\n            url = `${websocketBaseUrl}/ws/google.ai.generativelanguage.${apiVersion}.GenerativeService.${method}?${keyName}=${apiKey}`;\n        }\n        let onopenResolve = () => { };\n        const onopenPromise = new Promise((resolve) => {\n            onopenResolve = resolve;\n        });\n        const callbacks = params.callbacks;\n        const onopenAwaitedCallback = function () {\n            var _a;\n            (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onopen) === null || _a === void 0 ? void 0 : _a.call(callbacks);\n            onopenResolve({});\n        };\n        const apiClient = this.apiClient;\n        const websocketCallbacks = {\n            onopen: onopenAwaitedCallback,\n            onmessage: (event) => {\n                void handleWebSocketMessage(apiClient, callbacks.onmessage, event);\n            },\n            onerror: (_a = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onerror) !== null && _a !== void 0 ? _a : function (e) {\n            },\n            onclose: (_b = callbacks === null || callbacks === void 0 ? void 0 : callbacks.onclose) !== null && _b !== void 0 ? _b : function (e) {\n            },\n        };\n        const conn = this.webSocketFactory.create(url, headersToMap(headers), websocketCallbacks);\n        conn.connect();\n        // Wait for the websocket to open before sending requests.\n        await onopenPromise;\n        let transformedModel = tModel(this.apiClient, params.model);\n        if (this.apiClient.isVertexAI() &&\n            transformedModel.startsWith('publishers/')) {\n            const project = this.apiClient.getProject();\n            const location = this.apiClient.getLocation();\n            transformedModel =\n                `projects/${project}/locations/${location}/` + transformedModel;\n        }\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI() &&\n            ((_c = params.config) === null || _c === void 0 ? void 0 : _c.responseModalities) === undefined) {\n            // Set default to AUDIO to align with MLDev API.\n            if (params.config === undefined) {\n                params.config = { responseModalities: [Modality.AUDIO] };\n            }\n            else {\n                params.config.responseModalities = [Modality.AUDIO];\n            }\n        }\n        if ((_d = params.config) === null || _d === void 0 ? void 0 : _d.generationConfig) {\n            // Raise deprecation warning for generationConfig.\n            console.warn('Setting `LiveConnectConfig.generation_config` is deprecated, please set the fields on `LiveConnectConfig` directly. This will become an error in a future version (not before Q3 2025).');\n        }\n        const inputTools = (_f = (_e = params.config) === null || _e === void 0 ? void 0 : _e.tools) !== null && _f !== void 0 ? _f : [];\n        const convertedTools = [];\n        for (const tool of inputTools) {\n            if (this.isCallableTool(tool)) {\n                const callableTool = tool;\n                convertedTools.push(await callableTool.tool());\n            }\n            else {\n                convertedTools.push(tool);\n            }\n        }\n        if (convertedTools.length > 0) {\n            params.config.tools = convertedTools;\n        }\n        const liveConnectParameters = {\n            model: transformedModel,\n            config: params.config,\n            callbacks: params.callbacks,\n        };\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = liveConnectParametersToVertex(this.apiClient, liveConnectParameters);\n        }\n        else {\n            clientMessage = liveConnectParametersToMldev(this.apiClient, liveConnectParameters);\n        }\n        delete clientMessage['config'];\n        conn.send(JSON.stringify(clientMessage));\n        return new Session(conn, this.apiClient);\n    }\n    // TODO: b/416041229 - Abstract this method to a common place.\n    isCallableTool(tool) {\n        return 'callTool' in tool && typeof tool.callTool === 'function';\n    }\n}\nconst defaultLiveSendClientContentParamerters = {\n    turnComplete: true,\n};\n/**\n   Represents a connection to the API.\n\n   @experimental\n  */\nclass Session {\n    constructor(conn, apiClient) {\n        this.conn = conn;\n        this.apiClient = apiClient;\n    }\n    tLiveClientContent(apiClient, params) {\n        if (params.turns !== null && params.turns !== undefined) {\n            let contents = [];\n            try {\n                contents = tContents(params.turns);\n                if (apiClient.isVertexAI()) {\n                    contents = contents.map((item) => contentToVertex(item));\n                }\n                else {\n                    contents = contents.map((item) => contentToMldev$1(item));\n                }\n            }\n            catch (_a) {\n                throw new Error(`Failed to parse client content \"turns\", type: '${typeof params.turns}'`);\n            }\n            return {\n                clientContent: { turns: contents, turnComplete: params.turnComplete },\n            };\n        }\n        return {\n            clientContent: { turnComplete: params.turnComplete },\n        };\n    }\n    tLiveClienttToolResponse(apiClient, params) {\n        let functionResponses = [];\n        if (params.functionResponses == null) {\n            throw new Error('functionResponses is required.');\n        }\n        if (!Array.isArray(params.functionResponses)) {\n            functionResponses = [params.functionResponses];\n        }\n        else {\n            functionResponses = params.functionResponses;\n        }\n        if (functionResponses.length === 0) {\n            throw new Error('functionResponses is required.');\n        }\n        for (const functionResponse of functionResponses) {\n            if (typeof functionResponse !== 'object' ||\n                functionResponse === null ||\n                !('name' in functionResponse) ||\n                !('response' in functionResponse)) {\n                throw new Error(`Could not parse function response, type '${typeof functionResponse}'.`);\n            }\n            if (!apiClient.isVertexAI() && !('id' in functionResponse)) {\n                throw new Error(FUNCTION_RESPONSE_REQUIRES_ID);\n            }\n        }\n        const clientMessage = {\n            toolResponse: { functionResponses: functionResponses },\n        };\n        return clientMessage;\n    }\n    /**\n      Send a message over the established connection.\n  \n      @param params - Contains two **optional** properties, `turns` and\n          `turnComplete`.\n  \n        - `turns` will be converted to a `Content[]`\n        - `turnComplete: true` [default] indicates that you are done sending\n          content and expect a response. If `turnComplete: false`, the server\n          will wait for additional messages before starting generation.\n  \n      @experimental\n  \n      @remarks\n      There are two ways to send messages to the live API:\n      `sendClientContent` and `sendRealtimeInput`.\n  \n      `sendClientContent` messages are added to the model context **in order**.\n      Having a conversation using `sendClientContent` messages is roughly\n      equivalent to using the `Chat.sendMessageStream`, except that the state of\n      the `chat` history is stored on the API server instead of locally.\n  \n      Because of `sendClientContent`'s order guarantee, the model cannot respons\n      as quickly to `sendClientContent` messages as to `sendRealtimeInput`\n      messages. This makes the biggest difference when sending objects that have\n      significant preprocessing time (typically images).\n  \n      The `sendClientContent` message sends a `Content[]`\n      which has more options than the `Blob` sent by `sendRealtimeInput`.\n  \n      So the main use-cases for `sendClientContent` over `sendRealtimeInput` are:\n  \n      - Sending anything that can't be represented as a `Blob` (text,\n      `sendClientContent({turns=\"Hello?\"}`)).\n      - Managing turns when not using audio input and voice activity detection.\n        (`sendClientContent({turnComplete:true})` or the short form\n      `sendClientContent()`)\n      - Prefilling a conversation context\n        ```\n        sendClientContent({\n            turns: [\n              Content({role:user, parts:...}),\n              Content({role:user, parts:...}),\n              ...\n            ]\n        })\n        ```\n      @experimental\n     */\n    sendClientContent(params) {\n        params = Object.assign(Object.assign({}, defaultLiveSendClientContentParamerters), params);\n        const clientMessage = this.tLiveClientContent(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a realtime message over the established connection.\n  \n      @param params - Contains one property, `media`.\n  \n        - `media` will be converted to a `Blob`\n  \n      @experimental\n  \n      @remarks\n      Use `sendRealtimeInput` for realtime audio chunks and video frames (images).\n  \n      With `sendRealtimeInput` the api will respond to audio automatically\n      based on voice activity detection (VAD).\n  \n      `sendRealtimeInput` is optimized for responsivness at the expense of\n      deterministic ordering guarantees. Audio and video tokens are to the\n      context when they become available.\n  \n      Note: The Call signature expects a `Blob` object, but only a subset\n      of audio and image mimetypes are allowed.\n     */\n    sendRealtimeInput(params) {\n        let clientMessage = {};\n        if (this.apiClient.isVertexAI()) {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToVertex(params),\n            };\n        }\n        else {\n            clientMessage = {\n                'realtimeInput': liveSendRealtimeInputParametersToMldev(params),\n            };\n        }\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n      Send a function response message over the established connection.\n  \n      @param params - Contains property `functionResponses`.\n  \n        - `functionResponses` will be converted to a `functionResponses[]`\n  \n      @remarks\n      Use `sendFunctionResponse` to reply to `LiveServerToolCall` from the server.\n  \n      Use {@link types.LiveConnectConfig#tools} to configure the callable functions.\n  \n      @experimental\n     */\n    sendToolResponse(params) {\n        if (params.functionResponses == null) {\n            throw new Error('Tool response parameters are required.');\n        }\n        const clientMessage = this.tLiveClienttToolResponse(this.apiClient, params);\n        this.conn.send(JSON.stringify(clientMessage));\n    }\n    /**\n       Terminates the WebSocket connection.\n  \n       @experimental\n  \n       @example\n       ```ts\n       let model: string;\n       if (GOOGLE_GENAI_USE_VERTEXAI) {\n         model = 'gemini-2.0-flash-live-preview-04-09';\n       } else {\n         model = 'gemini-live-2.5-flash-preview';\n       }\n       const session = await ai.live.connect({\n         model: model,\n         config: {\n           responseModalities: [Modality.AUDIO],\n         }\n       });\n  \n       session.close();\n       ```\n     */\n    close() {\n        this.conn.close();\n    }\n}\n// Converts an headers object to a \"map\" object as expected by the WebSocket\n// constructor. We use this as the Auth interface works with Headers objects\n// while the WebSocket constructor takes a map.\nfunction headersToMap(headers) {\n    const headerMap = {};\n    headers.forEach((value, key) => {\n        headerMap[key] = value;\n    });\n    return headerMap;\n}\n// Converts a \"map\" object to a headers object. We use this as the Auth\n// interface works with Headers objects while the API client default headers\n// returns a map.\nfunction mapToHeaders(map) {\n    const headers = new Headers();\n    for (const [key, value] of Object.entries(map)) {\n        headers.append(key, value);\n    }\n    return headers;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst DEFAULT_MAX_REMOTE_CALLS = 10;\n/** Returns whether automatic function calling is disabled. */\nfunction shouldDisableAfc(config) {\n    var _a, _b, _c;\n    if ((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.disable) {\n        return true;\n    }\n    let callableToolsPresent = false;\n    for (const tool of (_b = config === null || config === void 0 ? void 0 : config.tools) !== null && _b !== void 0 ? _b : []) {\n        if (isCallableTool(tool)) {\n            callableToolsPresent = true;\n            break;\n        }\n    }\n    if (!callableToolsPresent) {\n        return true;\n    }\n    const maxCalls = (_c = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _c === void 0 ? void 0 : _c.maximumRemoteCalls;\n    if ((maxCalls && (maxCalls < 0 || !Number.isInteger(maxCalls))) ||\n        maxCalls == 0) {\n        console.warn('Invalid maximumRemoteCalls value provided for automatic function calling. Disabled automatic function calling. Please provide a valid integer value greater than 0. maximumRemoteCalls provided:', maxCalls);\n        return true;\n    }\n    return false;\n}\nfunction isCallableTool(tool) {\n    return 'callTool' in tool && typeof tool.callTool === 'function';\n}\n// Checks whether the list of tools contains any CallableTools. Will return true\n// if there is at least one CallableTool.\nfunction hasCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n// Checks whether the list of tools contains any non-callable tools. Will return\n// true if there is at least one non-Callable tool.\nfunction hasNonCallableTools(params) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) === null || _b === void 0 ? void 0 : _b.some((tool) => !isCallableTool(tool))) !== null && _c !== void 0 ? _c : false;\n}\n/**\n * Returns whether to append automatic function calling history to the\n * response.\n */\nfunction shouldAppendAfcHistory(config) {\n    var _a;\n    return !((_a = config === null || config === void 0 ? void 0 : config.automaticFunctionCalling) === null || _a === void 0 ? void 0 : _a.ignoreCallHistory);\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Models extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Makes an API request to generate content with a given model.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         * 'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContent({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     candidateCount: 2,\n         *   }\n         * });\n         * console.log(response);\n         * ```\n         */\n        this.generateContent = async (params) => {\n            var _a, _b, _c, _d, _e;\n            const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n            this.maybeMoveToResponseJsonSchem(params);\n            if (!hasCallableTools(params) || shouldDisableAfc(params.config)) {\n                return await this.generateContentInternal(transformedParams);\n            }\n            if (hasNonCallableTools(params)) {\n                throw new Error('Automatic function calling with CallableTools and Tools is not yet supported.');\n            }\n            let response;\n            let functionResponseContent;\n            const automaticFunctionCallingHistory = tContents(transformedParams.contents);\n            const maxRemoteCalls = (_c = (_b = (_a = transformedParams.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n            let remoteCalls = 0;\n            while (remoteCalls < maxRemoteCalls) {\n                response = await this.generateContentInternal(transformedParams);\n                if (!response.functionCalls || response.functionCalls.length === 0) {\n                    break;\n                }\n                const responseContent = response.candidates[0].content;\n                const functionResponseParts = [];\n                for (const tool of (_e = (_d = params.config) === null || _d === void 0 ? void 0 : _d.tools) !== null && _e !== void 0 ? _e : []) {\n                    if (isCallableTool(tool)) {\n                        const callableTool = tool;\n                        const parts = await callableTool.callTool(response.functionCalls);\n                        functionResponseParts.push(...parts);\n                    }\n                }\n                remoteCalls++;\n                functionResponseContent = {\n                    role: 'user',\n                    parts: functionResponseParts,\n                };\n                transformedParams.contents = tContents(transformedParams.contents);\n                transformedParams.contents.push(responseContent);\n                transformedParams.contents.push(functionResponseContent);\n                if (shouldAppendAfcHistory(transformedParams.config)) {\n                    automaticFunctionCallingHistory.push(responseContent);\n                    automaticFunctionCallingHistory.push(functionResponseContent);\n                }\n            }\n            if (shouldAppendAfcHistory(transformedParams.config)) {\n                response.automaticFunctionCallingHistory =\n                    automaticFunctionCallingHistory;\n            }\n            return response;\n        };\n        /**\n         * Makes an API request to generate content with a given model and yields the\n         * response in chunks.\n         *\n         * For the `model` parameter, supported formats for Vertex AI API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The full resource name starts with 'projects/', for example:\n         *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'\n         * - The partial resource name with 'publishers/', for example:\n         *  'publishers/google/models/gemini-2.0-flash' or\n         *  'publishers/meta/models/llama-3.1-405b-instruct-maas'\n         * - `/` separated publisher and model name, for example:\n         * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'\n         *\n         * For the `model` parameter, supported formats for Gemini API include:\n         * - The Gemini model ID, for example: 'gemini-2.0-flash'\n         * - The model name starts with 'models/', for example:\n         *  'models/gemini-2.0-flash'\n         * - For tuned models, the model name starts with 'tunedModels/',\n         * for example:\n         *  'tunedModels/1234567890123456789'\n         *\n         * Some models support multimodal input and output.\n         *\n         * @param params - The parameters for generating content with streaming response.\n         * @return The response from generating content.\n         *\n         * @example\n         * ```ts\n         * const response = await ai.models.generateContentStream({\n         *   model: 'gemini-2.0-flash',\n         *   contents: 'why is the sky blue?',\n         *   config: {\n         *     maxOutputTokens: 200,\n         *   }\n         * });\n         * for await (const chunk of response) {\n         *   console.log(chunk);\n         * }\n         * ```\n         */\n        this.generateContentStream = async (params) => {\n            this.maybeMoveToResponseJsonSchem(params);\n            if (shouldDisableAfc(params.config)) {\n                const transformedParams = await this.processParamsMaybeAddMcpUsage(params);\n                return await this.generateContentStreamInternal(transformedParams);\n            }\n            else {\n                return await this.processAfcStream(params);\n            }\n        };\n        /**\n         * Generates an image based on a text description and configuration.\n         *\n         * @param params - The parameters for generating images.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.generateImages({\n         *  model: 'imagen-3.0-generate-002',\n         *  prompt: 'Robot holding a red skateboard',\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.generateImages = async (params) => {\n            return await this.generateImagesInternal(params).then((apiResponse) => {\n                var _a;\n                let positivePromptSafetyAttributes;\n                const generatedImages = [];\n                if (apiResponse === null || apiResponse === void 0 ? void 0 : apiResponse.generatedImages) {\n                    for (const generatedImage of apiResponse.generatedImages) {\n                        if (generatedImage &&\n                            (generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) &&\n                            ((_a = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes) === null || _a === void 0 ? void 0 : _a.contentType) === 'Positive Prompt') {\n                            positivePromptSafetyAttributes = generatedImage === null || generatedImage === void 0 ? void 0 : generatedImage.safetyAttributes;\n                        }\n                        else {\n                            generatedImages.push(generatedImage);\n                        }\n                    }\n                }\n                let response;\n                if (positivePromptSafetyAttributes) {\n                    response = {\n                        generatedImages: generatedImages,\n                        positivePromptSafetyAttributes: positivePromptSafetyAttributes,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                else {\n                    response = {\n                        generatedImages: generatedImages,\n                        sdkHttpResponse: apiResponse.sdkHttpResponse,\n                    };\n                }\n                return response;\n            });\n        };\n        this.list = async (params) => {\n            var _a;\n            const defaultConfig = {\n                queryBase: true,\n            };\n            const actualConfig = Object.assign(Object.assign({}, defaultConfig), params === null || params === void 0 ? void 0 : params.config);\n            const actualParams = {\n                config: actualConfig,\n            };\n            if (this.apiClient.isVertexAI()) {\n                if (!actualParams.config.queryBase) {\n                    if ((_a = actualParams.config) === null || _a === void 0 ? void 0 : _a.filter) {\n                        throw new Error('Filtering tuned models list for Vertex AI is not currently supported');\n                    }\n                    else {\n                        actualParams.config.filter = 'labels.tune-type:*';\n                    }\n                }\n            }\n            return new Pager(PagedItem.PAGED_ITEM_MODELS, (x) => this.listInternal(x), await this.listInternal(actualParams), actualParams);\n        };\n        /**\n         * Edits an image based on a prompt, list of reference images, and configuration.\n         *\n         * @param params - The parameters for editing an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.editImage({\n         *  model: 'imagen-3.0-capability-001',\n         *  prompt: 'Generate an image containing a mug with the product logo [1] visible on the side of the mug.',\n         *  referenceImages: [subjectReferenceImage]\n         *  config: {\n         *    numberOfImages: 1,\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.editImage = async (params) => {\n            const paramsInternal = {\n                model: params.model,\n                prompt: params.prompt,\n                referenceImages: [],\n                config: params.config,\n            };\n            if (params.referenceImages) {\n                if (params.referenceImages) {\n                    paramsInternal.referenceImages = params.referenceImages.map((img) => img.toReferenceImageAPI());\n                }\n            }\n            return await this.editImageInternal(paramsInternal);\n        };\n        /**\n         * Upscales an image based on an image, upscale factor, and configuration.\n         * Only supported in Vertex AI currently.\n         *\n         * @param params - The parameters for upscaling an image.\n         * @return The response from the API.\n         *\n         * @example\n         * ```ts\n         * const response = await client.models.upscaleImage({\n         *  model: 'imagen-3.0-generate-002',\n         *  image: image,\n         *  upscaleFactor: 'x2',\n         *  config: {\n         *    includeRaiReason: true,\n         *  },\n         * });\n         * console.log(response?.generatedImages?.[0]?.image?.imageBytes);\n         * ```\n         */\n        this.upscaleImage = async (params) => {\n            let apiConfig = {\n                numberOfImages: 1,\n                mode: 'upscale',\n            };\n            if (params.config) {\n                apiConfig = Object.assign(Object.assign({}, apiConfig), params.config);\n            }\n            const apiParams = {\n                model: params.model,\n                image: params.image,\n                upscaleFactor: params.upscaleFactor,\n                config: apiConfig,\n            };\n            return await this.upscaleImageInternal(apiParams);\n        };\n        /**\n         *  Generates videos based on a text description and configuration.\n         *\n         * @param params - The parameters for generating videos.\n         * @return A Promise<GenerateVideosOperation> which allows you to track the progress and eventually retrieve the generated videos using the operations.get method.\n         *\n         * @example\n         * ```ts\n         * const operation = await ai.models.generateVideos({\n         *  model: 'veo-2.0-generate-001',\n         *  source: {\n         *    prompt: 'A neon hologram of a cat driving at top speed',\n         *  },\n         *  config: {\n         *    numberOfVideos: 1\n         * });\n         *\n         * while (!operation.done) {\n         *   await new Promise(resolve => setTimeout(resolve, 10000));\n         *   operation = await ai.operations.getVideosOperation({operation: operation});\n         * }\n         *\n         * console.log(operation.response?.generatedVideos?.[0]?.video?.uri);\n         * ```\n         */\n        this.generateVideos = async (params) => {\n            if ((params.prompt || params.image || params.video) && params.source) {\n                throw new Error('Source and prompt/image/video are mutually exclusive. Please only use source.');\n            }\n            return await this.generateVideosInternal(params);\n        };\n    }\n    /**\n     * This logic is needed for GenerateContentConfig only.\n     * Previously we made GenerateContentConfig.responseSchema field to accept\n     * unknown. Since v1.9.0, we switch to use backend JSON schema support.\n     * To maintain backward compatibility, we move the data that was treated as\n     * JSON schema from the responseSchema field to the responseJsonSchema field.\n     */\n    maybeMoveToResponseJsonSchem(params) {\n        if (params.config && params.config.responseSchema) {\n            if (!params.config.responseJsonSchema) {\n                if (Object.keys(params.config.responseSchema).includes('$schema')) {\n                    params.config.responseJsonSchema = params.config.responseSchema;\n                    delete params.config.responseSchema;\n                }\n            }\n        }\n        return;\n    }\n    /**\n     * Transforms the CallableTools in the parameters to be simply Tools, it\n     * copies the params into a new object and replaces the tools, it does not\n     * modify the original params. Also sets the MCP usage header if there are\n     * MCP tools in the parameters.\n     */\n    async processParamsMaybeAddMcpUsage(params) {\n        var _a, _b, _c;\n        const tools = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools;\n        if (!tools) {\n            return params;\n        }\n        const transformedTools = await Promise.all(tools.map(async (tool) => {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                return await callableTool.tool();\n            }\n            return tool;\n        }));\n        const newParams = {\n            model: params.model,\n            contents: params.contents,\n            config: Object.assign(Object.assign({}, params.config), { tools: transformedTools }),\n        };\n        newParams.config.tools = transformedTools;\n        if (params.config &&\n            params.config.tools &&\n            hasMcpToolUsage(params.config.tools)) {\n            const headers = (_c = (_b = params.config.httpOptions) === null || _b === void 0 ? void 0 : _b.headers) !== null && _c !== void 0 ? _c : {};\n            let newHeaders = Object.assign({}, headers);\n            if (Object.keys(newHeaders).length === 0) {\n                newHeaders = this.apiClient.getDefaultHeaders();\n            }\n            setMcpUsageHeader(newHeaders);\n            newParams.config.httpOptions = Object.assign(Object.assign({}, params.config.httpOptions), { headers: newHeaders });\n        }\n        return newParams;\n    }\n    async initAfcToolsMap(params) {\n        var _a, _b, _c;\n        const afcTools = new Map();\n        for (const tool of (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.tools) !== null && _b !== void 0 ? _b : []) {\n            if (isCallableTool(tool)) {\n                const callableTool = tool;\n                const toolDeclaration = await callableTool.tool();\n                for (const declaration of (_c = toolDeclaration.functionDeclarations) !== null && _c !== void 0 ? _c : []) {\n                    if (!declaration.name) {\n                        throw new Error('Function declaration name is required.');\n                    }\n                    if (afcTools.has(declaration.name)) {\n                        throw new Error(`Duplicate tool declaration name: ${declaration.name}`);\n                    }\n                    afcTools.set(declaration.name, callableTool);\n                }\n            }\n        }\n        return afcTools;\n    }\n    async processAfcStream(params) {\n        var _a, _b, _c;\n        const maxRemoteCalls = (_c = (_b = (_a = params.config) === null || _a === void 0 ? void 0 : _a.automaticFunctionCalling) === null || _b === void 0 ? void 0 : _b.maximumRemoteCalls) !== null && _c !== void 0 ? _c : DEFAULT_MAX_REMOTE_CALLS;\n        let wereFunctionsCalled = false;\n        let remoteCallCount = 0;\n        const afcToolsMap = await this.initAfcToolsMap(params);\n        return (function (models, afcTools, params) {\n            var _a, _b;\n            return __asyncGenerator(this, arguments, function* () {\n                var _c, e_1, _d, _e;\n                while (remoteCallCount < maxRemoteCalls) {\n                    if (wereFunctionsCalled) {\n                        remoteCallCount++;\n                        wereFunctionsCalled = false;\n                    }\n                    const transformedParams = yield __await(models.processParamsMaybeAddMcpUsage(params));\n                    const response = yield __await(models.generateContentStreamInternal(transformedParams));\n                    const functionResponses = [];\n                    const responseContents = [];\n                    try {\n                        for (var _f = true, response_1 = (e_1 = void 0, __asyncValues(response)), response_1_1; response_1_1 = yield __await(response_1.next()), _c = response_1_1.done, !_c; _f = true) {\n                            _e = response_1_1.value;\n                            _f = false;\n                            const chunk = _e;\n                            yield yield __await(chunk);\n                            if (chunk.candidates && ((_a = chunk.candidates[0]) === null || _a === void 0 ? void 0 : _a.content)) {\n                                responseContents.push(chunk.candidates[0].content);\n                                for (const part of (_b = chunk.candidates[0].content.parts) !== null && _b !== void 0 ? _b : []) {\n                                    if (remoteCallCount < maxRemoteCalls && part.functionCall) {\n                                        if (!part.functionCall.name) {\n                                            throw new Error('Function call name was not returned by the model.');\n                                        }\n                                        if (!afcTools.has(part.functionCall.name)) {\n                                            throw new Error(`Automatic function calling was requested, but not all the tools the model used implement the CallableTool interface. Available tools: ${afcTools.keys()}, mising tool: ${part.functionCall.name}`);\n                                        }\n                                        else {\n                                            const responseParts = yield __await(afcTools\n                                                .get(part.functionCall.name)\n                                                .callTool([part.functionCall]));\n                                            functionResponses.push(...responseParts);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n                    finally {\n                        try {\n                            if (!_f && !_c && (_d = response_1.return)) yield __await(_d.call(response_1));\n                        }\n                        finally { if (e_1) throw e_1.error; }\n                    }\n                    if (functionResponses.length > 0) {\n                        wereFunctionsCalled = true;\n                        const typedResponseChunk = new GenerateContentResponse();\n                        typedResponseChunk.candidates = [\n                            {\n                                content: {\n                                    role: 'user',\n                                    parts: functionResponses,\n                                },\n                            },\n                        ];\n                        yield yield __await(typedResponseChunk);\n                        const newContents = [];\n                        newContents.push(...responseContents);\n                        newContents.push({\n                            role: 'user',\n                            parts: functionResponses,\n                        });\n                        const updatedContents = tContents(params.contents).concat(newContents);\n                        params.contents = updatedContents;\n                    }\n                    else {\n                        break;\n                    }\n                }\n            });\n        })(this, afcToolsMap, params);\n    }\n    async generateContentInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromVertex(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:generateContent', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateContentResponseFromMldev(apiResponse);\n                const typedResp = new GenerateContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    async generateContentStreamInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_2, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_1 = __asyncValues(apiResponse), apiResponse_1_1; apiResponse_1_1 = yield __await(apiResponse_1.next()), _a = apiResponse_1_1.done, !_a; _d = true) {\n                            _c = apiResponse_1_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromVertex((yield __await(chunk.json())));\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_1.return)) yield __await(_b.call(apiResponse_1));\n                        }\n                        finally { if (e_2) throw e_2.error; }\n                    }\n                });\n            });\n        }\n        else {\n            const body = generateContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:streamGenerateContent?alt=sse', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            const apiClient = this.apiClient;\n            response = apiClient.requestStream({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n            return response.then(function (apiResponse) {\n                return __asyncGenerator(this, arguments, function* () {\n                    var _a, e_3, _b, _c;\n                    try {\n                        for (var _d = true, apiResponse_2 = __asyncValues(apiResponse), apiResponse_2_1; apiResponse_2_1 = yield __await(apiResponse_2.next()), _a = apiResponse_2_1.done, !_a; _d = true) {\n                            _c = apiResponse_2_1.value;\n                            _d = false;\n                            const chunk = _c;\n                            const resp = generateContentResponseFromMldev((yield __await(chunk.json())));\n                            resp['sdkHttpResponse'] = {\n                                headers: chunk.headers,\n                            };\n                            const typedResp = new GenerateContentResponse();\n                            Object.assign(typedResp, resp);\n                            yield yield __await(typedResp);\n                        }\n                    }\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\n                    finally {\n                        try {\n                            if (!_d && !_a && (_b = apiResponse_2.return)) yield __await(_b.call(apiResponse_2));\n                        }\n                        finally { if (e_3) throw e_3.error; }\n                    }\n                });\n            });\n        }\n    }\n    /**\n     * Calculates embeddings for the given contents. Only text is supported.\n     *\n     * @param params - The parameters for embedding contents.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.embedContent({\n     *  model: 'text-embedding-004',\n     *  contents: [\n     *    'What is your name?',\n     *    'What is your favorite color?',\n     *  ],\n     *  config: {\n     *    outputDimensionality: 64,\n     *  },\n     * });\n     * console.log(response);\n     * ```\n     */\n    async embedContent(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = embedContentParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromVertex(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = embedContentParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:batchEmbedContents', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = embedContentResponseFromMldev(apiResponse);\n                const typedResp = new EmbedContentResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for generating images.\n     */\n    async generateImagesInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateImagesParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromVertex(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateImagesParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = generateImagesResponseFromMldev(apiResponse);\n                const typedResp = new GenerateImagesResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Private method for editing an image.\n     */\n    async editImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = editImageParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = editImageResponseFromVertex(apiResponse);\n                const typedResp = new EditImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for upscaling an image.\n     */\n    async upscaleImageInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = upscaleImageAPIParametersInternalToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = upscaleImageResponseFromVertex(apiResponse);\n                const typedResp = new UpscaleImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Recontextualizes an image.\n     *\n     * There are two types of recontextualization currently supported:\n     * 1) Imagen Product Recontext - Generate images of products in new scenes\n     *    and contexts.\n     * 2) Virtual Try-On: Generate images of persons modeling fashion products.\n     *\n     * @param params - The parameters for recontextualizing an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response1 = await ai.models.recontextImage({\n     *  model: 'imagen-product-recontext-preview-06-30',\n     *  source: {\n     *    prompt: 'In a modern kitchen setting.',\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response1?.generatedImages?.[0]?.image?.imageBytes);\n     *\n     * const response2 = await ai.models.recontextImage({\n     *  model: 'virtual-try-on-preview-08-04',\n     *  source: {\n     *    personImage: personImage,\n     *    productImages: [productImage],\n     *  },\n     *  config: {\n     *    numberOfImages: 1,\n     *  },\n     * });\n     * console.log(response2?.generatedImages?.[0]?.image?.imageBytes);\n     * ```\n     */\n    async recontextImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = recontextImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = recontextImageResponseFromVertex(apiResponse);\n                const typedResp = new RecontextImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Segments an image, creating a mask of a specified area.\n     *\n     * @param params - The parameters for segmenting an image.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.segmentImage({\n     *  model: 'image-segmentation-001',\n     *  source: {\n     *    image: image,\n     *  },\n     *  config: {\n     *    mode: 'foreground',\n     *  },\n     * });\n     * console.log(response?.generatedMasks?.[0]?.mask?.imageBytes);\n     * ```\n     */\n    async segmentImage(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = segmentImageParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predict', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = segmentImageResponseFromVertex(apiResponse);\n                const typedResp = new SegmentImageResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Fetches information about a model by name.\n     *\n     * @example\n     * ```ts\n     * const modelInfo = await ai.models.get({model: 'gemini-2.0-flash'});\n     * ```\n     */\n    async get(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listModelsParametersToVertex(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromVertex(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listModelsParametersToMldev(this.apiClient, params);\n            path = formatMap('{models_url}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listModelsResponseFromMldev(apiResponse);\n                const typedResp = new ListModelsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Updates a tuned model by its name.\n     *\n     * @param params - The parameters for updating the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.update({\n     *   model: 'tuned-model-name',\n     *   config: {\n     *     displayName: 'New display name',\n     *     description: 'New description',\n     *   },\n     * });\n     * ```\n     */\n    async update(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = updateModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = updateModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'PATCH',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = modelFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    /**\n     * Deletes a tuned model by its name.\n     *\n     * @param params - The parameters for deleting the model.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.delete({model: 'tuned-model-name'});\n     * ```\n     */\n    async delete(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = deleteModelParametersToVertex(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromVertex(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = deleteModelParametersToMldev(this.apiClient, params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'DELETE',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = deleteModelResponseFromMldev(apiResponse);\n                const typedResp = new DeleteModelResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Counts the number of tokens in the given contents. Multimodal input is\n     * supported for Gemini models.\n     *\n     * @param params - The parameters for counting tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.countTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'The quick brown fox jumps over the lazy dog.'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async countTokens(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = countTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromVertex(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = countTokensParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:countTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = countTokensResponseFromMldev(apiResponse);\n                const typedResp = new CountTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Given a list of contents, returns a corresponding TokensInfo containing\n     * the list of tokens and list of token ids.\n     *\n     * This method is not supported by the Gemini Developer API.\n     *\n     * @param params - The parameters for computing tokens.\n     * @return The response from the API.\n     *\n     * @example\n     * ```ts\n     * const response = await ai.models.computeTokens({\n     *  model: 'gemini-2.0-flash',\n     *  contents: 'What is your name?'\n     * });\n     * console.log(response);\n     * ```\n     */\n    async computeTokens(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = computeTokensParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:computeTokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = computeTokensResponseFromVertex(apiResponse);\n                const typedResp = new ComputeTokensResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    /**\n     * Private method for generating videos.\n     */\n    async generateVideosInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = generateVideosParametersToVertex(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromVertex(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = generateVideosParametersToMldev(this.apiClient, params);\n            path = formatMap('{model}:predictLongRunning', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = generateVideosOperationFromMldev(apiResponse);\n                const typedResp = new GenerateVideosOperation();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Operations extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async getVideosOperation(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false,\n            });\n        }\n    }\n    /**\n     * Gets the status of a long-running operation.\n     *\n     * @param parameters The parameters for the get operation request.\n     * @return The updated Operation object, with the latest status or result.\n     */\n    async get(parameters) {\n        const operation = parameters.operation;\n        const config = parameters.config;\n        if (operation.name === undefined || operation.name === '') {\n            throw new Error('Operation name is required.');\n        }\n        if (this.apiClient.isVertexAI()) {\n            const resourceName = operation.name.split('/operations/')[0];\n            let httpOptions = undefined;\n            if (config && 'httpOptions' in config) {\n                httpOptions = config.httpOptions;\n            }\n            const rawOperation = await this.fetchPredictVideosOperationInternal({\n                operationName: operation.name,\n                resourceName: resourceName,\n                config: { httpOptions: httpOptions },\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: true,\n            });\n        }\n        else {\n            const rawOperation = await this.getVideosOperationInternal({\n                operationName: operation.name,\n                config: config,\n            });\n            return operation._fromAPIResponse({\n                apiResponse: rawOperation,\n                isVertexAI: false,\n            });\n        }\n    }\n    async getVideosOperationInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getOperationParametersToVertex(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            const body = getOperationParametersToMldev(params);\n            path = formatMap('{operationName}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n    }\n    async fetchPredictVideosOperationInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = fetchPredictOperationParametersToVertex(params);\n            path = formatMap('{resourceName}:fetchPredictOperation', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response;\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nfunction audioTranscriptionConfigToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction authTokenFromMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction automaticActivityDetectionToMldev(fromObject) {\n    const toObject = {};\n    const fromDisabled = getValueByPath(fromObject, ['disabled']);\n    if (fromDisabled != null) {\n        setValueByPath(toObject, ['disabled'], fromDisabled);\n    }\n    const fromStartOfSpeechSensitivity = getValueByPath(fromObject, [\n        'startOfSpeechSensitivity',\n    ]);\n    if (fromStartOfSpeechSensitivity != null) {\n        setValueByPath(toObject, ['startOfSpeechSensitivity'], fromStartOfSpeechSensitivity);\n    }\n    const fromEndOfSpeechSensitivity = getValueByPath(fromObject, [\n        'endOfSpeechSensitivity',\n    ]);\n    if (fromEndOfSpeechSensitivity != null) {\n        setValueByPath(toObject, ['endOfSpeechSensitivity'], fromEndOfSpeechSensitivity);\n    }\n    const fromPrefixPaddingMs = getValueByPath(fromObject, [\n        'prefixPaddingMs',\n    ]);\n    if (fromPrefixPaddingMs != null) {\n        setValueByPath(toObject, ['prefixPaddingMs'], fromPrefixPaddingMs);\n    }\n    const fromSilenceDurationMs = getValueByPath(fromObject, [\n        'silenceDurationMs',\n    ]);\n    if (fromSilenceDurationMs != null) {\n        setValueByPath(toObject, ['silenceDurationMs'], fromSilenceDurationMs);\n    }\n    return toObject;\n}\nfunction blobToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromData = getValueByPath(fromObject, ['data']);\n    if (fromData != null) {\n        setValueByPath(toObject, ['data'], fromData);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction computerUseToMldev(fromObject) {\n    const toObject = {};\n    const fromEnvironment = getValueByPath(fromObject, ['environment']);\n    if (fromEnvironment != null) {\n        setValueByPath(toObject, ['environment'], fromEnvironment);\n    }\n    const fromExcludedPredefinedFunctions = getValueByPath(fromObject, [\n        'excludedPredefinedFunctions',\n    ]);\n    if (fromExcludedPredefinedFunctions != null) {\n        setValueByPath(toObject, ['excludedPredefinedFunctions'], fromExcludedPredefinedFunctions);\n    }\n    return toObject;\n}\nfunction contentToMldev(fromObject) {\n    const toObject = {};\n    const fromParts = getValueByPath(fromObject, ['parts']);\n    if (fromParts != null) {\n        let transformedList = fromParts;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return partToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['parts'], transformedList);\n    }\n    const fromRole = getValueByPath(fromObject, ['role']);\n    if (fromRole != null) {\n        setValueByPath(toObject, ['role'], fromRole);\n    }\n    return toObject;\n}\nfunction contextWindowCompressionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromTriggerTokens = getValueByPath(fromObject, [\n        'triggerTokens',\n    ]);\n    if (fromTriggerTokens != null) {\n        setValueByPath(toObject, ['triggerTokens'], fromTriggerTokens);\n    }\n    const fromSlidingWindow = getValueByPath(fromObject, [\n        'slidingWindow',\n    ]);\n    if (fromSlidingWindow != null) {\n        setValueByPath(toObject, ['slidingWindow'], slidingWindowToMldev(fromSlidingWindow));\n    }\n    return toObject;\n}\nfunction createAuthTokenConfigToMldev(apiClient, fromObject, parentObject) {\n    const toObject = {};\n    const fromExpireTime = getValueByPath(fromObject, ['expireTime']);\n    if (parentObject !== undefined && fromExpireTime != null) {\n        setValueByPath(parentObject, ['expireTime'], fromExpireTime);\n    }\n    const fromNewSessionExpireTime = getValueByPath(fromObject, [\n        'newSessionExpireTime',\n    ]);\n    if (parentObject !== undefined && fromNewSessionExpireTime != null) {\n        setValueByPath(parentObject, ['newSessionExpireTime'], fromNewSessionExpireTime);\n    }\n    const fromUses = getValueByPath(fromObject, ['uses']);\n    if (parentObject !== undefined && fromUses != null) {\n        setValueByPath(parentObject, ['uses'], fromUses);\n    }\n    const fromLiveConnectConstraints = getValueByPath(fromObject, [\n        'liveConnectConstraints',\n    ]);\n    if (parentObject !== undefined && fromLiveConnectConstraints != null) {\n        setValueByPath(parentObject, ['bidiGenerateContentSetup'], liveConnectConstraintsToMldev(apiClient, fromLiveConnectConstraints));\n    }\n    const fromLockAdditionalFields = getValueByPath(fromObject, [\n        'lockAdditionalFields',\n    ]);\n    if (parentObject !== undefined && fromLockAdditionalFields != null) {\n        setValueByPath(parentObject, ['fieldMask'], fromLockAdditionalFields);\n    }\n    return toObject;\n}\nfunction createAuthTokenParametersToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], createAuthTokenConfigToMldev(apiClient, fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction dynamicRetrievalConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromMode = getValueByPath(fromObject, ['mode']);\n    if (fromMode != null) {\n        setValueByPath(toObject, ['mode'], fromMode);\n    }\n    const fromDynamicThreshold = getValueByPath(fromObject, [\n        'dynamicThreshold',\n    ]);\n    if (fromDynamicThreshold != null) {\n        setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);\n    }\n    return toObject;\n}\nfunction fileDataToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['displayName']) !== undefined) {\n        throw new Error('displayName parameter is not supported in Gemini API.');\n    }\n    const fromFileUri = getValueByPath(fromObject, ['fileUri']);\n    if (fromFileUri != null) {\n        setValueByPath(toObject, ['fileUri'], fromFileUri);\n    }\n    const fromMimeType = getValueByPath(fromObject, ['mimeType']);\n    if (fromMimeType != null) {\n        setValueByPath(toObject, ['mimeType'], fromMimeType);\n    }\n    return toObject;\n}\nfunction functionCallToMldev(fromObject) {\n    const toObject = {};\n    const fromId = getValueByPath(fromObject, ['id']);\n    if (fromId != null) {\n        setValueByPath(toObject, ['id'], fromId);\n    }\n    const fromArgs = getValueByPath(fromObject, ['args']);\n    if (fromArgs != null) {\n        setValueByPath(toObject, ['args'], fromArgs);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    return toObject;\n}\nfunction functionDeclarationToMldev(fromObject) {\n    const toObject = {};\n    const fromBehavior = getValueByPath(fromObject, ['behavior']);\n    if (fromBehavior != null) {\n        setValueByPath(toObject, ['behavior'], fromBehavior);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromParameters = getValueByPath(fromObject, ['parameters']);\n    if (fromParameters != null) {\n        setValueByPath(toObject, ['parameters'], fromParameters);\n    }\n    const fromParametersJsonSchema = getValueByPath(fromObject, [\n        'parametersJsonSchema',\n    ]);\n    if (fromParametersJsonSchema != null) {\n        setValueByPath(toObject, ['parametersJsonSchema'], fromParametersJsonSchema);\n    }\n    const fromResponse = getValueByPath(fromObject, ['response']);\n    if (fromResponse != null) {\n        setValueByPath(toObject, ['response'], fromResponse);\n    }\n    const fromResponseJsonSchema = getValueByPath(fromObject, [\n        'responseJsonSchema',\n    ]);\n    if (fromResponseJsonSchema != null) {\n        setValueByPath(toObject, ['responseJsonSchema'], fromResponseJsonSchema);\n    }\n    return toObject;\n}\nfunction googleSearchRetrievalToMldev(fromObject) {\n    const toObject = {};\n    const fromDynamicRetrievalConfig = getValueByPath(fromObject, [\n        'dynamicRetrievalConfig',\n    ]);\n    if (fromDynamicRetrievalConfig != null) {\n        setValueByPath(toObject, ['dynamicRetrievalConfig'], dynamicRetrievalConfigToMldev(fromDynamicRetrievalConfig));\n    }\n    return toObject;\n}\nfunction googleSearchToMldev(fromObject) {\n    const toObject = {};\n    const fromTimeRangeFilter = getValueByPath(fromObject, [\n        'timeRangeFilter',\n    ]);\n    if (fromTimeRangeFilter != null) {\n        setValueByPath(toObject, ['timeRangeFilter'], intervalToMldev(fromTimeRangeFilter));\n    }\n    if (getValueByPath(fromObject, ['excludeDomains']) !== undefined) {\n        throw new Error('excludeDomains parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction intervalToMldev(fromObject) {\n    const toObject = {};\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    return toObject;\n}\nfunction liveConnectConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromGenerationConfig = getValueByPath(fromObject, [\n        'generationConfig',\n    ]);\n    if (parentObject !== undefined && fromGenerationConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig'], fromGenerationConfig);\n    }\n    const fromResponseModalities = getValueByPath(fromObject, [\n        'responseModalities',\n    ]);\n    if (parentObject !== undefined && fromResponseModalities != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'responseModalities'], fromResponseModalities);\n    }\n    const fromTemperature = getValueByPath(fromObject, ['temperature']);\n    if (parentObject !== undefined && fromTemperature != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'temperature'], fromTemperature);\n    }\n    const fromTopP = getValueByPath(fromObject, ['topP']);\n    if (parentObject !== undefined && fromTopP != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topP'], fromTopP);\n    }\n    const fromTopK = getValueByPath(fromObject, ['topK']);\n    if (parentObject !== undefined && fromTopK != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'topK'], fromTopK);\n    }\n    const fromMaxOutputTokens = getValueByPath(fromObject, [\n        'maxOutputTokens',\n    ]);\n    if (parentObject !== undefined && fromMaxOutputTokens != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'maxOutputTokens'], fromMaxOutputTokens);\n    }\n    const fromMediaResolution = getValueByPath(fromObject, [\n        'mediaResolution',\n    ]);\n    if (parentObject !== undefined && fromMediaResolution != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'mediaResolution'], fromMediaResolution);\n    }\n    const fromSeed = getValueByPath(fromObject, ['seed']);\n    if (parentObject !== undefined && fromSeed != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'seed'], fromSeed);\n    }\n    const fromSpeechConfig = getValueByPath(fromObject, ['speechConfig']);\n    if (parentObject !== undefined && fromSpeechConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'speechConfig'], speechConfigToMldev(tLiveSpeechConfig(fromSpeechConfig)));\n    }\n    const fromThinkingConfig = getValueByPath(fromObject, [\n        'thinkingConfig',\n    ]);\n    if (parentObject !== undefined && fromThinkingConfig != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'thinkingConfig'], thinkingConfigToMldev(fromThinkingConfig));\n    }\n    const fromEnableAffectiveDialog = getValueByPath(fromObject, [\n        'enableAffectiveDialog',\n    ]);\n    if (parentObject !== undefined && fromEnableAffectiveDialog != null) {\n        setValueByPath(parentObject, ['setup', 'generationConfig', 'enableAffectiveDialog'], fromEnableAffectiveDialog);\n    }\n    const fromSystemInstruction = getValueByPath(fromObject, [\n        'systemInstruction',\n    ]);\n    if (parentObject !== undefined && fromSystemInstruction != null) {\n        setValueByPath(parentObject, ['setup', 'systemInstruction'], contentToMldev(tContent(fromSystemInstruction)));\n    }\n    const fromTools = getValueByPath(fromObject, ['tools']);\n    if (parentObject !== undefined && fromTools != null) {\n        let transformedList = tTools(fromTools);\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return toolToMldev(tTool(item));\n            });\n        }\n        setValueByPath(parentObject, ['setup', 'tools'], transformedList);\n    }\n    const fromSessionResumption = getValueByPath(fromObject, [\n        'sessionResumption',\n    ]);\n    if (parentObject !== undefined && fromSessionResumption != null) {\n        setValueByPath(parentObject, ['setup', 'sessionResumption'], sessionResumptionConfigToMldev(fromSessionResumption));\n    }\n    const fromInputAudioTranscription = getValueByPath(fromObject, [\n        'inputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromInputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'inputAudioTranscription'], audioTranscriptionConfigToMldev());\n    }\n    const fromOutputAudioTranscription = getValueByPath(fromObject, [\n        'outputAudioTranscription',\n    ]);\n    if (parentObject !== undefined && fromOutputAudioTranscription != null) {\n        setValueByPath(parentObject, ['setup', 'outputAudioTranscription'], audioTranscriptionConfigToMldev());\n    }\n    const fromRealtimeInputConfig = getValueByPath(fromObject, [\n        'realtimeInputConfig',\n    ]);\n    if (parentObject !== undefined && fromRealtimeInputConfig != null) {\n        setValueByPath(parentObject, ['setup', 'realtimeInputConfig'], realtimeInputConfigToMldev(fromRealtimeInputConfig));\n    }\n    const fromContextWindowCompression = getValueByPath(fromObject, [\n        'contextWindowCompression',\n    ]);\n    if (parentObject !== undefined && fromContextWindowCompression != null) {\n        setValueByPath(parentObject, ['setup', 'contextWindowCompression'], contextWindowCompressionConfigToMldev(fromContextWindowCompression));\n    }\n    const fromProactivity = getValueByPath(fromObject, ['proactivity']);\n    if (parentObject !== undefined && fromProactivity != null) {\n        setValueByPath(parentObject, ['setup', 'proactivity'], proactivityConfigToMldev(fromProactivity));\n    }\n    return toObject;\n}\nfunction liveConnectConstraintsToMldev(apiClient, fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['setup', 'model'], tModel(apiClient, fromModel));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        setValueByPath(toObject, ['config'], liveConnectConfigToMldev(fromConfig, toObject));\n    }\n    return toObject;\n}\nfunction multiSpeakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeakerVoiceConfigs = getValueByPath(fromObject, [\n        'speakerVoiceConfigs',\n    ]);\n    if (fromSpeakerVoiceConfigs != null) {\n        let transformedList = fromSpeakerVoiceConfigs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return speakerVoiceConfigToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['speakerVoiceConfigs'], transformedList);\n    }\n    return toObject;\n}\nfunction partToMldev(fromObject) {\n    const toObject = {};\n    const fromVideoMetadata = getValueByPath(fromObject, [\n        'videoMetadata',\n    ]);\n    if (fromVideoMetadata != null) {\n        setValueByPath(toObject, ['videoMetadata'], videoMetadataToMldev(fromVideoMetadata));\n    }\n    const fromThought = getValueByPath(fromObject, ['thought']);\n    if (fromThought != null) {\n        setValueByPath(toObject, ['thought'], fromThought);\n    }\n    const fromInlineData = getValueByPath(fromObject, ['inlineData']);\n    if (fromInlineData != null) {\n        setValueByPath(toObject, ['inlineData'], blobToMldev(fromInlineData));\n    }\n    const fromFileData = getValueByPath(fromObject, ['fileData']);\n    if (fromFileData != null) {\n        setValueByPath(toObject, ['fileData'], fileDataToMldev(fromFileData));\n    }\n    const fromThoughtSignature = getValueByPath(fromObject, [\n        'thoughtSignature',\n    ]);\n    if (fromThoughtSignature != null) {\n        setValueByPath(toObject, ['thoughtSignature'], fromThoughtSignature);\n    }\n    const fromFunctionCall = getValueByPath(fromObject, ['functionCall']);\n    if (fromFunctionCall != null) {\n        setValueByPath(toObject, ['functionCall'], functionCallToMldev(fromFunctionCall));\n    }\n    const fromCodeExecutionResult = getValueByPath(fromObject, [\n        'codeExecutionResult',\n    ]);\n    if (fromCodeExecutionResult != null) {\n        setValueByPath(toObject, ['codeExecutionResult'], fromCodeExecutionResult);\n    }\n    const fromExecutableCode = getValueByPath(fromObject, [\n        'executableCode',\n    ]);\n    if (fromExecutableCode != null) {\n        setValueByPath(toObject, ['executableCode'], fromExecutableCode);\n    }\n    const fromFunctionResponse = getValueByPath(fromObject, [\n        'functionResponse',\n    ]);\n    if (fromFunctionResponse != null) {\n        setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);\n    }\n    const fromText = getValueByPath(fromObject, ['text']);\n    if (fromText != null) {\n        setValueByPath(toObject, ['text'], fromText);\n    }\n    return toObject;\n}\nfunction prebuiltVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceName = getValueByPath(fromObject, ['voiceName']);\n    if (fromVoiceName != null) {\n        setValueByPath(toObject, ['voiceName'], fromVoiceName);\n    }\n    return toObject;\n}\nfunction proactivityConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromProactiveAudio = getValueByPath(fromObject, [\n        'proactiveAudio',\n    ]);\n    if (fromProactiveAudio != null) {\n        setValueByPath(toObject, ['proactiveAudio'], fromProactiveAudio);\n    }\n    return toObject;\n}\nfunction realtimeInputConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromAutomaticActivityDetection = getValueByPath(fromObject, [\n        'automaticActivityDetection',\n    ]);\n    if (fromAutomaticActivityDetection != null) {\n        setValueByPath(toObject, ['automaticActivityDetection'], automaticActivityDetectionToMldev(fromAutomaticActivityDetection));\n    }\n    const fromActivityHandling = getValueByPath(fromObject, [\n        'activityHandling',\n    ]);\n    if (fromActivityHandling != null) {\n        setValueByPath(toObject, ['activityHandling'], fromActivityHandling);\n    }\n    const fromTurnCoverage = getValueByPath(fromObject, ['turnCoverage']);\n    if (fromTurnCoverage != null) {\n        setValueByPath(toObject, ['turnCoverage'], fromTurnCoverage);\n    }\n    return toObject;\n}\nfunction sessionResumptionConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromHandle = getValueByPath(fromObject, ['handle']);\n    if (fromHandle != null) {\n        setValueByPath(toObject, ['handle'], fromHandle);\n    }\n    if (getValueByPath(fromObject, ['transparent']) !== undefined) {\n        throw new Error('transparent parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction slidingWindowToMldev(fromObject) {\n    const toObject = {};\n    const fromTargetTokens = getValueByPath(fromObject, ['targetTokens']);\n    if (fromTargetTokens != null) {\n        setValueByPath(toObject, ['targetTokens'], fromTargetTokens);\n    }\n    return toObject;\n}\nfunction speakerVoiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromSpeaker = getValueByPath(fromObject, ['speaker']);\n    if (fromSpeaker != null) {\n        setValueByPath(toObject, ['speaker'], fromSpeaker);\n    }\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev(fromVoiceConfig));\n    }\n    return toObject;\n}\nfunction speechConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromVoiceConfig = getValueByPath(fromObject, ['voiceConfig']);\n    if (fromVoiceConfig != null) {\n        setValueByPath(toObject, ['voiceConfig'], voiceConfigToMldev(fromVoiceConfig));\n    }\n    const fromMultiSpeakerVoiceConfig = getValueByPath(fromObject, [\n        'multiSpeakerVoiceConfig',\n    ]);\n    if (fromMultiSpeakerVoiceConfig != null) {\n        setValueByPath(toObject, ['multiSpeakerVoiceConfig'], multiSpeakerVoiceConfigToMldev(fromMultiSpeakerVoiceConfig));\n    }\n    const fromLanguageCode = getValueByPath(fromObject, ['languageCode']);\n    if (fromLanguageCode != null) {\n        setValueByPath(toObject, ['languageCode'], fromLanguageCode);\n    }\n    return toObject;\n}\nfunction thinkingConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromIncludeThoughts = getValueByPath(fromObject, [\n        'includeThoughts',\n    ]);\n    if (fromIncludeThoughts != null) {\n        setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);\n    }\n    const fromThinkingBudget = getValueByPath(fromObject, [\n        'thinkingBudget',\n    ]);\n    if (fromThinkingBudget != null) {\n        setValueByPath(toObject, ['thinkingBudget'], fromThinkingBudget);\n    }\n    return toObject;\n}\nfunction toolToMldev(fromObject) {\n    const toObject = {};\n    const fromFunctionDeclarations = getValueByPath(fromObject, [\n        'functionDeclarations',\n    ]);\n    if (fromFunctionDeclarations != null) {\n        let transformedList = fromFunctionDeclarations;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return functionDeclarationToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['functionDeclarations'], transformedList);\n    }\n    if (getValueByPath(fromObject, ['retrieval']) !== undefined) {\n        throw new Error('retrieval parameter is not supported in Gemini API.');\n    }\n    const fromGoogleSearch = getValueByPath(fromObject, ['googleSearch']);\n    if (fromGoogleSearch != null) {\n        setValueByPath(toObject, ['googleSearch'], googleSearchToMldev(fromGoogleSearch));\n    }\n    const fromGoogleSearchRetrieval = getValueByPath(fromObject, [\n        'googleSearchRetrieval',\n    ]);\n    if (fromGoogleSearchRetrieval != null) {\n        setValueByPath(toObject, ['googleSearchRetrieval'], googleSearchRetrievalToMldev(fromGoogleSearchRetrieval));\n    }\n    if (getValueByPath(fromObject, ['enterpriseWebSearch']) !== undefined) {\n        throw new Error('enterpriseWebSearch parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['googleMaps']) !== undefined) {\n        throw new Error('googleMaps parameter is not supported in Gemini API.');\n    }\n    const fromUrlContext = getValueByPath(fromObject, ['urlContext']);\n    if (fromUrlContext != null) {\n        setValueByPath(toObject, ['urlContext'], urlContextToMldev());\n    }\n    const fromComputerUse = getValueByPath(fromObject, ['computerUse']);\n    if (fromComputerUse != null) {\n        setValueByPath(toObject, ['computerUse'], computerUseToMldev(fromComputerUse));\n    }\n    const fromCodeExecution = getValueByPath(fromObject, [\n        'codeExecution',\n    ]);\n    if (fromCodeExecution != null) {\n        setValueByPath(toObject, ['codeExecution'], fromCodeExecution);\n    }\n    return toObject;\n}\nfunction urlContextToMldev() {\n    const toObject = {};\n    return toObject;\n}\nfunction videoMetadataToMldev(fromObject) {\n    const toObject = {};\n    const fromFps = getValueByPath(fromObject, ['fps']);\n    if (fromFps != null) {\n        setValueByPath(toObject, ['fps'], fromFps);\n    }\n    const fromEndOffset = getValueByPath(fromObject, ['endOffset']);\n    if (fromEndOffset != null) {\n        setValueByPath(toObject, ['endOffset'], fromEndOffset);\n    }\n    const fromStartOffset = getValueByPath(fromObject, ['startOffset']);\n    if (fromStartOffset != null) {\n        setValueByPath(toObject, ['startOffset'], fromStartOffset);\n    }\n    return toObject;\n}\nfunction voiceConfigToMldev(fromObject) {\n    const toObject = {};\n    const fromPrebuiltVoiceConfig = getValueByPath(fromObject, [\n        'prebuiltVoiceConfig',\n    ]);\n    if (fromPrebuiltVoiceConfig != null) {\n        setValueByPath(toObject, ['prebuiltVoiceConfig'], prebuiltVoiceConfigToMldev(fromPrebuiltVoiceConfig));\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Returns a comma-separated list of field masks from a given object.\n *\n * @param setup The object to extract field masks from.\n * @return A comma-separated list of field masks.\n */\nfunction getFieldMasks(setup) {\n    const fields = [];\n    for (const key in setup) {\n        if (Object.prototype.hasOwnProperty.call(setup, key)) {\n            const value = setup[key];\n            // 2nd layer, recursively get field masks see TODO(b/418290100)\n            if (typeof value === 'object' &&\n                value != null &&\n                Object.keys(value).length > 0) {\n                const field = Object.keys(value).map((kk) => `${key}.${kk}`);\n                fields.push(...field);\n            }\n            else {\n                fields.push(key); // 1st layer\n            }\n        }\n    }\n    return fields.join(',');\n}\n/**\n * Converts bidiGenerateContentSetup.\n * @param requestDict - The request dictionary.\n * @param config - The configuration object.\n * @return - The modified request dictionary.\n */\nfunction convertBidiSetupToTokenSetup(requestDict, config) {\n    // Convert bidiGenerateContentSetup from bidiGenerateContentSetup.setup.\n    let setupForMaskGeneration = null;\n    const bidiGenerateContentSetupValue = requestDict['bidiGenerateContentSetup'];\n    if (typeof bidiGenerateContentSetupValue === 'object' &&\n        bidiGenerateContentSetupValue !== null &&\n        'setup' in bidiGenerateContentSetupValue) {\n        // Now we know bidiGenerateContentSetupValue is an object and has a 'setup'\n        // property.\n        const innerSetup = bidiGenerateContentSetupValue\n            .setup;\n        if (typeof innerSetup === 'object' && innerSetup !== null) {\n            // Valid inner setup found.\n            requestDict['bidiGenerateContentSetup'] = innerSetup;\n            setupForMaskGeneration = innerSetup;\n        }\n        else {\n            // `bidiGenerateContentSetupValue.setup` is not a valid object; treat as\n            // if bidiGenerateContentSetup is invalid.\n            delete requestDict['bidiGenerateContentSetup'];\n        }\n    }\n    else if (bidiGenerateContentSetupValue !== undefined) {\n        // `bidiGenerateContentSetup` exists but not in the expected\n        // shape {setup: {...}}; treat as invalid.\n        delete requestDict['bidiGenerateContentSetup'];\n    }\n    const preExistingFieldMask = requestDict['fieldMask'];\n    // Handle mask generation setup.\n    if (setupForMaskGeneration) {\n        const generatedMaskFromBidi = getFieldMasks(setupForMaskGeneration);\n        if (Array.isArray(config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            (config === null || config === void 0 ? void 0 : config.lockAdditionalFields.length) === 0) {\n            // Case 1: lockAdditionalFields is an empty array. Lock only fields from\n            // bidi setup.\n            if (generatedMaskFromBidi) {\n                // Only assign if mask is not empty\n                requestDict['fieldMask'] = generatedMaskFromBidi;\n            }\n            else {\n                delete requestDict['fieldMask']; // If mask is empty, effectively no\n                // specific fields locked by bidi\n            }\n        }\n        else if ((config === null || config === void 0 ? void 0 : config.lockAdditionalFields) &&\n            config.lockAdditionalFields.length > 0 &&\n            preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // Case 2: Lock fields from bidi setup + additional fields\n            // (preExistingFieldMask).\n            const generationConfigFields = [\n                'temperature',\n                'topK',\n                'topP',\n                'maxOutputTokens',\n                'responseModalities',\n                'seed',\n                'speechConfig',\n            ];\n            let mappedFieldsFromPreExisting = [];\n            if (preExistingFieldMask.length > 0) {\n                mappedFieldsFromPreExisting = preExistingFieldMask.map((field) => {\n                    if (generationConfigFields.includes(field)) {\n                        return `generationConfig.${field}`;\n                    }\n                    return field; // Keep original field name if not in\n                    // generationConfigFields\n                });\n            }\n            const finalMaskParts = [];\n            if (generatedMaskFromBidi) {\n                finalMaskParts.push(generatedMaskFromBidi);\n            }\n            if (mappedFieldsFromPreExisting.length > 0) {\n                finalMaskParts.push(...mappedFieldsFromPreExisting);\n            }\n            if (finalMaskParts.length > 0) {\n                requestDict['fieldMask'] = finalMaskParts.join(',');\n            }\n            else {\n                // If no fields from bidi and no valid additional fields from\n                // pre-existing mask.\n                delete requestDict['fieldMask'];\n            }\n        }\n        else {\n            // Case 3: \"Lock all fields\" (meaning, don't send a field_mask, let server\n            // defaults apply or all are mutable). This is hit if:\n            //  - `config.lockAdditionalFields` is undefined.\n            //  - `config.lockAdditionalFields` is non-empty, BUT\n            //  `preExistingFieldMask` is null, not a string, or an empty string.\n            delete requestDict['fieldMask'];\n        }\n    }\n    else {\n        // No valid `bidiGenerateContentSetup` was found or extracted.\n        // \"Lock additional null fields if any\".\n        if (preExistingFieldMask !== null &&\n            Array.isArray(preExistingFieldMask) &&\n            preExistingFieldMask.length > 0) {\n            // If there's a pre-existing field mask, it's a string, and it's not\n            // empty, then we should lock all fields.\n            requestDict['fieldMask'] = preExistingFieldMask.join(',');\n        }\n        else {\n            delete requestDict['fieldMask'];\n        }\n    }\n    return requestDict;\n}\nclass Tokens extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n    }\n    /**\n     * Creates an ephemeral auth token resource.\n     *\n     * @experimental\n     *\n     * @remarks\n     * Ephemeral auth tokens is only supported in the Gemini Developer API.\n     * It can be used for the session connection to the Live constrained API.\n     * Support in v1alpha only.\n     *\n     * @param params - The parameters for the create request.\n     * @return The created auth token.\n     *\n     * @example\n     * ```ts\n     * const ai = new GoogleGenAI({\n     *     apiKey: token.name,\n     *     httpOptions: { apiVersion: 'v1alpha' }  // Support in v1alpha only.\n     * });\n     *\n     * // Case 1: If LiveEphemeralParameters is unset, unlock LiveConnectConfig\n     * // when using the token in Live API sessions. Each session connection can\n     * // use a different configuration.\n     * const config: CreateAuthTokenConfig = {\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 2: If LiveEphemeralParameters is set, lock all fields in\n     * // LiveConnectConfig when using the token in Live API sessions. For\n     * // example, changing `outputAudioTranscription` in the Live API\n     * // connection will be ignored by the API.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     }\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 3: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // set, lock LiveConnectConfig with set and additional fields (e.g.\n     * // responseModalities, systemInstruction, temperature in this example) when\n     * // using the token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: ['temperature'],\n     * }\n     * const token = await ai.tokens.create(config);\n     *\n     * // Case 4: If LiveEphemeralParameters is set and lockAdditionalFields is\n     * // empty array, lock LiveConnectConfig with set fields (e.g.\n     * // responseModalities, systemInstruction in this example) when using the\n     * // token in Live API sessions.\n     * const config: CreateAuthTokenConfig =\n     *     uses: 3,\n     *     expireTime: '2025-05-01T00:00:00Z',\n     *     LiveEphemeralParameters: {\n     *        model: 'gemini-2.0-flash-001',\n     *        config: {\n     *           'responseModalities': ['AUDIO'],\n     *           'systemInstruction': 'Always answer in English.',\n     *        }\n     *     },\n     *     lockAdditionalFields: [],\n     * }\n     * const token = await ai.tokens.create(config);\n     * ```\n     */\n    async create(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('The client.tokens.create method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createAuthTokenParametersToMldev(this.apiClient, params);\n            path = formatMap('auth_tokens', body['_url']);\n            queryParams = body['_query'];\n            delete body['config'];\n            delete body['_url'];\n            delete body['_query'];\n            const transformedBody = convertBidiSetupToTokenSetup(body, params.config);\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(transformedBody),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json();\n            });\n            return response.then((apiResponse) => {\n                const resp = authTokenFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst GOOGLE_API_KEY_HEADER = 'x-goog-api-key';\nconst REQUIRED_VERTEX_AI_SCOPE = 'https://www.googleapis.com/auth/cloud-platform';\nclass NodeAuth {\n    constructor(opts) {\n        if (opts.apiKey !== undefined) {\n            this.apiKey = opts.apiKey;\n            return;\n        }\n        const vertexAuthOptions = buildGoogleAuthOptions(opts.googleAuthOptions);\n        this.googleAuth = new google_auth_library__WEBPACK_IMPORTED_MODULE_0__.GoogleAuth(vertexAuthOptions);\n    }\n    async addAuthHeaders(headers) {\n        if (this.apiKey !== undefined) {\n            if (this.apiKey.startsWith('auth_tokens/')) {\n                throw new Error('Ephemeral tokens are only supported by the live API.');\n            }\n            this.addKeyHeader(headers);\n            return;\n        }\n        return this.addGoogleAuthHeaders(headers);\n    }\n    addKeyHeader(headers) {\n        if (headers.get(GOOGLE_API_KEY_HEADER) !== null) {\n            return;\n        }\n        if (this.apiKey === undefined) {\n            // This should never happen, this method is only called\n            // when apiKey is set.\n            throw new Error('Trying to set API key header but apiKey is not set');\n        }\n        headers.append(GOOGLE_API_KEY_HEADER, this.apiKey);\n    }\n    async addGoogleAuthHeaders(headers) {\n        if (this.googleAuth === undefined) {\n            // This should never happen, addGoogleAuthHeaders should only be\n            // called when there is no apiKey set and in these cases googleAuth\n            // is set.\n            throw new Error('Trying to set google-auth headers but googleAuth is unset');\n        }\n        const authHeaders = await this.googleAuth.getRequestHeaders();\n        for (const key in authHeaders) {\n            if (headers.get(key) !== null) {\n                continue;\n            }\n            headers.append(key, authHeaders[key]);\n        }\n    }\n}\nfunction buildGoogleAuthOptions(googleAuthOptions) {\n    let authOptions;\n    if (!googleAuthOptions) {\n        authOptions = {\n            scopes: [REQUIRED_VERTEX_AI_SCOPE],\n        };\n        return authOptions;\n    }\n    else {\n        authOptions = googleAuthOptions;\n        if (!authOptions.scopes) {\n            authOptions.scopes = [REQUIRED_VERTEX_AI_SCOPE];\n            return authOptions;\n        }\n        else if ((typeof authOptions.scopes === 'string' &&\n            authOptions.scopes !== REQUIRED_VERTEX_AI_SCOPE) ||\n            (Array.isArray(authOptions.scopes) &&\n                authOptions.scopes.indexOf(REQUIRED_VERTEX_AI_SCOPE) < 0)) {\n            throw new Error(`Invalid auth scopes. Scopes must include: ${REQUIRED_VERTEX_AI_SCOPE}`);\n        }\n        return authOptions;\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeDownloader {\n    async download(params, apiClient) {\n        if (params.downloadPath) {\n            const response = await downloadFile(params, apiClient);\n            if (response instanceof HttpResponse) {\n                const writer = (0,fs__WEBPACK_IMPORTED_MODULE_1__.createWriteStream)(params.downloadPath);\n                node_stream__WEBPACK_IMPORTED_MODULE_2__.Readable.fromWeb(response.responseInternal.body).pipe(writer);\n            }\n            else {\n                (0,fs__WEBPACK_IMPORTED_MODULE_1__.writeFile)(params.downloadPath, response, { encoding: 'base64' }, (error) => {\n                    if (error) {\n                        throw new Error(`Failed to write file to ${params.downloadPath}: ${error}`);\n                    }\n                });\n            }\n        }\n    }\n}\nasync function downloadFile(params, apiClient) {\n    var _a, _b, _c;\n    const name = tFileName(params.file);\n    if (name !== undefined) {\n        return await apiClient.request({\n            path: `files/${name}:download`,\n            httpMethod: 'GET',\n            queryParams: {\n                'alt': 'media',\n            },\n            httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n            abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n        });\n    }\n    else if (isGeneratedVideo(params.file)) {\n        const videoBytes = (_c = params.file.video) === null || _c === void 0 ? void 0 : _c.videoBytes;\n        if (typeof videoBytes === 'string') {\n            return videoBytes;\n        }\n        else {\n            throw new Error('Failed to download generated video, Uri or videoBytes not found.');\n        }\n    }\n    else if (isVideo(params.file)) {\n        const videoBytes = params.file.videoBytes;\n        if (typeof videoBytes === 'string') {\n            return videoBytes;\n        }\n        else {\n            throw new Error('Failed to download video, Uri or videoBytes not found.');\n        }\n    }\n    else {\n        throw new Error('Unsupported file type');\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeWebSocketFactory {\n    create(url, headers, callbacks) {\n        return new NodeWebSocket(url, headers, callbacks);\n    }\n}\nclass NodeWebSocket {\n    constructor(url, headers, callbacks) {\n        this.url = url;\n        this.headers = headers;\n        this.callbacks = callbacks;\n    }\n    connect() {\n        this.ws = new ws__WEBPACK_IMPORTED_MODULE_3__.WebSocket(this.url, { headers: this.headers });\n        this.ws.onopen = this.callbacks.onopen;\n        this.ws.onerror = this.callbacks.onerror;\n        this.ws.onclose = this.callbacks.onclose;\n        this.ws.onmessage = this.callbacks.onmessage;\n    }\n    send(message) {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.send(message);\n    }\n    close() {\n        if (this.ws === undefined) {\n            throw new Error('WebSocket is not connected');\n        }\n        this.ws.close();\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n// Code generated by the Google Gen AI SDK generator DO NOT EDIT.\nfunction cancelTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction cancelTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['validationDataset']) !== undefined) {\n        throw new Error('validationDataset parameter is not supported in Gemini API.');\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['displayName'], fromTunedModelDisplayName);\n    }\n    if (getValueByPath(fromObject, ['description']) !== undefined) {\n        throw new Error('description parameter is not supported in Gemini API.');\n    }\n    const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'epochCount'], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        'learningRateMultiplier',\n    ]);\n    if (fromLearningRateMultiplier != null) {\n        setValueByPath(toObject, ['tuningTask', 'hyperparameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n    }\n    if (getValueByPath(fromObject, ['exportLastCheckpointOnly']) !==\n        undefined) {\n        throw new Error('exportLastCheckpointOnly parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['preTunedModelCheckpointId']) !==\n        undefined) {\n        throw new Error('preTunedModelCheckpointId parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['adapterSize']) !== undefined) {\n        throw new Error('adapterSize parameter is not supported in Gemini API.');\n    }\n    const fromBatchSize = getValueByPath(fromObject, ['batchSize']);\n    if (parentObject !== undefined && fromBatchSize != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'batchSize'], fromBatchSize);\n    }\n    const fromLearningRate = getValueByPath(fromObject, ['learningRate']);\n    if (parentObject !== undefined && fromLearningRate != null) {\n        setValueByPath(parentObject, ['tuningTask', 'hyperparameters', 'learningRate'], fromLearningRate);\n    }\n    if (getValueByPath(fromObject, ['labels']) !== undefined) {\n        throw new Error('labels parameter is not supported in Gemini API.');\n    }\n    return toObject;\n}\nfunction createTuningJobConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromValidationDataset = getValueByPath(fromObject, [\n        'validationDataset',\n    ]);\n    if (parentObject !== undefined && fromValidationDataset != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec'], tuningValidationDatasetToVertex(fromValidationDataset, toObject));\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (parentObject !== undefined && fromTunedModelDisplayName != null) {\n        setValueByPath(parentObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (parentObject !== undefined && fromDescription != null) {\n        setValueByPath(parentObject, ['description'], fromDescription);\n    }\n    const fromEpochCount = getValueByPath(fromObject, ['epochCount']);\n    if (parentObject !== undefined && fromEpochCount != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'epochCount'], fromEpochCount);\n    }\n    const fromLearningRateMultiplier = getValueByPath(fromObject, [\n        'learningRateMultiplier',\n    ]);\n    if (parentObject !== undefined && fromLearningRateMultiplier != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'learningRateMultiplier'], fromLearningRateMultiplier);\n    }\n    const fromExportLastCheckpointOnly = getValueByPath(fromObject, [\n        'exportLastCheckpointOnly',\n    ]);\n    if (parentObject !== undefined && fromExportLastCheckpointOnly != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'exportLastCheckpointOnly'], fromExportLastCheckpointOnly);\n    }\n    const fromAdapterSize = getValueByPath(fromObject, ['adapterSize']);\n    if (parentObject !== undefined && fromAdapterSize != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'hyperParameters', 'adapterSize'], fromAdapterSize);\n    }\n    if (getValueByPath(fromObject, ['batchSize']) !== undefined) {\n        throw new Error('batchSize parameter is not supported in Vertex AI.');\n    }\n    if (getValueByPath(fromObject, ['learningRate']) !== undefined) {\n        throw new Error('learningRate parameter is not supported in Vertex AI.');\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (parentObject !== undefined && fromLabels != null) {\n        setValueByPath(parentObject, ['labels'], fromLabels);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToMldev(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, ['tuningTask', 'trainingData'], tuningDatasetToMldev(fromTrainingDataset));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction createTuningJobParametersPrivateToVertex(fromObject) {\n    const toObject = {};\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromTrainingDataset = getValueByPath(fromObject, [\n        'trainingDataset',\n    ]);\n    if (fromTrainingDataset != null) {\n        setValueByPath(toObject, ['supervisedTuningSpec', 'trainingDatasetUri'], tuningDatasetToVertex(fromTrainingDataset, toObject));\n    }\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        createTuningJobConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction getTuningJobParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['_url', 'name'], fromName);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToMldev(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsConfigToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromPageSize = getValueByPath(fromObject, ['pageSize']);\n    if (parentObject !== undefined && fromPageSize != null) {\n        setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);\n    }\n    const fromPageToken = getValueByPath(fromObject, ['pageToken']);\n    if (parentObject !== undefined && fromPageToken != null) {\n        setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);\n    }\n    const fromFilter = getValueByPath(fromObject, ['filter']);\n    if (parentObject !== undefined && fromFilter != null) {\n        setValueByPath(parentObject, ['_query', 'filter'], fromFilter);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToMldev(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToMldev(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsParametersToVertex(fromObject) {\n    const toObject = {};\n    const fromConfig = getValueByPath(fromObject, ['config']);\n    if (fromConfig != null) {\n        listTuningJobsConfigToVertex(fromConfig, toObject);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tunedModels']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction listTuningJobsResponseFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromNextPageToken = getValueByPath(fromObject, [\n        'nextPageToken',\n    ]);\n    if (fromNextPageToken != null) {\n        setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);\n    }\n    const fromTuningJobs = getValueByPath(fromObject, ['tuningJobs']);\n    if (fromTuningJobs != null) {\n        let transformedList = fromTuningJobs;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningJobFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['tuningJobs'], transformedList);\n    }\n    return toObject;\n}\nfunction tunedModelCheckpointFromVertex(fromObject) {\n    const toObject = {};\n    const fromCheckpointId = getValueByPath(fromObject, ['checkpointId']);\n    if (fromCheckpointId != null) {\n        setValueByPath(toObject, ['checkpointId'], fromCheckpointId);\n    }\n    const fromEpoch = getValueByPath(fromObject, ['epoch']);\n    if (fromEpoch != null) {\n        setValueByPath(toObject, ['epoch'], fromEpoch);\n    }\n    const fromStep = getValueByPath(fromObject, ['step']);\n    if (fromStep != null) {\n        setValueByPath(toObject, ['step'], fromStep);\n    }\n    const fromEndpoint = getValueByPath(fromObject, ['endpoint']);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, ['endpoint'], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tunedModelFromMldev(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['name']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, ['name']);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, ['endpoint'], fromEndpoint);\n    }\n    return toObject;\n}\nfunction tunedModelFromVertex(fromObject) {\n    const toObject = {};\n    const fromModel = getValueByPath(fromObject, ['model']);\n    if (fromModel != null) {\n        setValueByPath(toObject, ['model'], fromModel);\n    }\n    const fromEndpoint = getValueByPath(fromObject, ['endpoint']);\n    if (fromEndpoint != null) {\n        setValueByPath(toObject, ['endpoint'], fromEndpoint);\n    }\n    const fromCheckpoints = getValueByPath(fromObject, ['checkpoints']);\n    if (fromCheckpoints != null) {\n        let transformedList = fromCheckpoints;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tunedModelCheckpointFromVertex(item);\n            });\n        }\n        setValueByPath(toObject, ['checkpoints'], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToMldev(fromObject) {\n    const toObject = {};\n    if (getValueByPath(fromObject, ['gcsUri']) !== undefined) {\n        throw new Error('gcsUri parameter is not supported in Gemini API.');\n    }\n    if (getValueByPath(fromObject, ['vertexDatasetResource']) !== undefined) {\n        throw new Error('vertexDatasetResource parameter is not supported in Gemini API.');\n    }\n    const fromExamples = getValueByPath(fromObject, ['examples']);\n    if (fromExamples != null) {\n        let transformedList = fromExamples;\n        if (Array.isArray(transformedList)) {\n            transformedList = transformedList.map((item) => {\n                return tuningExampleToMldev(item);\n            });\n        }\n        setValueByPath(toObject, ['examples', 'examples'], transformedList);\n    }\n    return toObject;\n}\nfunction tuningDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (parentObject !== undefined && fromGcsUri != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        'vertexDatasetResource',\n    ]);\n    if (parentObject !== undefined && fromVertexDatasetResource != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n    }\n    if (getValueByPath(fromObject, ['examples']) !== undefined) {\n        throw new Error('examples parameter is not supported in Vertex AI.');\n    }\n    return toObject;\n}\nfunction tuningExampleToMldev(fromObject) {\n    const toObject = {};\n    const fromTextInput = getValueByPath(fromObject, ['textInput']);\n    if (fromTextInput != null) {\n        setValueByPath(toObject, ['textInput'], fromTextInput);\n    }\n    const fromOutput = getValueByPath(fromObject, ['output']);\n    if (fromOutput != null) {\n        setValueByPath(toObject, ['output'], fromOutput);\n    }\n    return toObject;\n}\nfunction tuningJobFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'startTime',\n    ]);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, [\n        'tuningTask',\n        'completeTime',\n    ]);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['_self']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], tunedModelFromMldev(fromTunedModel));\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        'customBaseModel',\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, ['customBaseModel'], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, ['experiment']);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, ['experiment'], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, ['outputUri']);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, ['outputUri'], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, ['pipelineJob']);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, ['pipelineJob'], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        'serviceAccount',\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, ['serviceAccount'], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        'veoTuningSpec',\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, ['veoTuningSpec'], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningJobFromVertex(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromState = getValueByPath(fromObject, ['state']);\n    if (fromState != null) {\n        setValueByPath(toObject, ['state'], tTuningJobStatus(fromState));\n    }\n    const fromCreateTime = getValueByPath(fromObject, ['createTime']);\n    if (fromCreateTime != null) {\n        setValueByPath(toObject, ['createTime'], fromCreateTime);\n    }\n    const fromStartTime = getValueByPath(fromObject, ['startTime']);\n    if (fromStartTime != null) {\n        setValueByPath(toObject, ['startTime'], fromStartTime);\n    }\n    const fromEndTime = getValueByPath(fromObject, ['endTime']);\n    if (fromEndTime != null) {\n        setValueByPath(toObject, ['endTime'], fromEndTime);\n    }\n    const fromUpdateTime = getValueByPath(fromObject, ['updateTime']);\n    if (fromUpdateTime != null) {\n        setValueByPath(toObject, ['updateTime'], fromUpdateTime);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    const fromDescription = getValueByPath(fromObject, ['description']);\n    if (fromDescription != null) {\n        setValueByPath(toObject, ['description'], fromDescription);\n    }\n    const fromBaseModel = getValueByPath(fromObject, ['baseModel']);\n    if (fromBaseModel != null) {\n        setValueByPath(toObject, ['baseModel'], fromBaseModel);\n    }\n    const fromTunedModel = getValueByPath(fromObject, ['tunedModel']);\n    if (fromTunedModel != null) {\n        setValueByPath(toObject, ['tunedModel'], tunedModelFromVertex(fromTunedModel));\n    }\n    const fromPreTunedModel = getValueByPath(fromObject, [\n        'preTunedModel',\n    ]);\n    if (fromPreTunedModel != null) {\n        setValueByPath(toObject, ['preTunedModel'], fromPreTunedModel);\n    }\n    const fromSupervisedTuningSpec = getValueByPath(fromObject, [\n        'supervisedTuningSpec',\n    ]);\n    if (fromSupervisedTuningSpec != null) {\n        setValueByPath(toObject, ['supervisedTuningSpec'], fromSupervisedTuningSpec);\n    }\n    const fromTuningDataStats = getValueByPath(fromObject, [\n        'tuningDataStats',\n    ]);\n    if (fromTuningDataStats != null) {\n        setValueByPath(toObject, ['tuningDataStats'], fromTuningDataStats);\n    }\n    const fromEncryptionSpec = getValueByPath(fromObject, [\n        'encryptionSpec',\n    ]);\n    if (fromEncryptionSpec != null) {\n        setValueByPath(toObject, ['encryptionSpec'], fromEncryptionSpec);\n    }\n    const fromPartnerModelTuningSpec = getValueByPath(fromObject, [\n        'partnerModelTuningSpec',\n    ]);\n    if (fromPartnerModelTuningSpec != null) {\n        setValueByPath(toObject, ['partnerModelTuningSpec'], fromPartnerModelTuningSpec);\n    }\n    const fromCustomBaseModel = getValueByPath(fromObject, [\n        'customBaseModel',\n    ]);\n    if (fromCustomBaseModel != null) {\n        setValueByPath(toObject, ['customBaseModel'], fromCustomBaseModel);\n    }\n    const fromExperiment = getValueByPath(fromObject, ['experiment']);\n    if (fromExperiment != null) {\n        setValueByPath(toObject, ['experiment'], fromExperiment);\n    }\n    const fromLabels = getValueByPath(fromObject, ['labels']);\n    if (fromLabels != null) {\n        setValueByPath(toObject, ['labels'], fromLabels);\n    }\n    const fromOutputUri = getValueByPath(fromObject, ['outputUri']);\n    if (fromOutputUri != null) {\n        setValueByPath(toObject, ['outputUri'], fromOutputUri);\n    }\n    const fromPipelineJob = getValueByPath(fromObject, ['pipelineJob']);\n    if (fromPipelineJob != null) {\n        setValueByPath(toObject, ['pipelineJob'], fromPipelineJob);\n    }\n    const fromServiceAccount = getValueByPath(fromObject, [\n        'serviceAccount',\n    ]);\n    if (fromServiceAccount != null) {\n        setValueByPath(toObject, ['serviceAccount'], fromServiceAccount);\n    }\n    const fromTunedModelDisplayName = getValueByPath(fromObject, [\n        'tunedModelDisplayName',\n    ]);\n    if (fromTunedModelDisplayName != null) {\n        setValueByPath(toObject, ['tunedModelDisplayName'], fromTunedModelDisplayName);\n    }\n    const fromVeoTuningSpec = getValueByPath(fromObject, [\n        'veoTuningSpec',\n    ]);\n    if (fromVeoTuningSpec != null) {\n        setValueByPath(toObject, ['veoTuningSpec'], fromVeoTuningSpec);\n    }\n    return toObject;\n}\nfunction tuningOperationFromMldev(fromObject) {\n    const toObject = {};\n    const fromSdkHttpResponse = getValueByPath(fromObject, [\n        'sdkHttpResponse',\n    ]);\n    if (fromSdkHttpResponse != null) {\n        setValueByPath(toObject, ['sdkHttpResponse'], fromSdkHttpResponse);\n    }\n    const fromName = getValueByPath(fromObject, ['name']);\n    if (fromName != null) {\n        setValueByPath(toObject, ['name'], fromName);\n    }\n    const fromMetadata = getValueByPath(fromObject, ['metadata']);\n    if (fromMetadata != null) {\n        setValueByPath(toObject, ['metadata'], fromMetadata);\n    }\n    const fromDone = getValueByPath(fromObject, ['done']);\n    if (fromDone != null) {\n        setValueByPath(toObject, ['done'], fromDone);\n    }\n    const fromError = getValueByPath(fromObject, ['error']);\n    if (fromError != null) {\n        setValueByPath(toObject, ['error'], fromError);\n    }\n    return toObject;\n}\nfunction tuningValidationDatasetToVertex(fromObject, parentObject) {\n    const toObject = {};\n    const fromGcsUri = getValueByPath(fromObject, ['gcsUri']);\n    if (fromGcsUri != null) {\n        setValueByPath(toObject, ['validationDatasetUri'], fromGcsUri);\n    }\n    const fromVertexDatasetResource = getValueByPath(fromObject, [\n        'vertexDatasetResource',\n    ]);\n    if (parentObject !== undefined && fromVertexDatasetResource != null) {\n        setValueByPath(parentObject, ['supervisedTuningSpec', 'trainingDatasetUri'], fromVertexDatasetResource);\n    }\n    return toObject;\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass Tunings extends BaseModule {\n    constructor(apiClient) {\n        super();\n        this.apiClient = apiClient;\n        /**\n         * Gets a TuningJob.\n         *\n         * @param name - The resource name of the tuning job.\n         * @return - A TuningJob object.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.get = async (params) => {\n            return await this.getInternal(params);\n        };\n        /**\n         * Lists tuning jobs.\n         *\n         * @param config - The configuration for the list request.\n         * @return - A list of tuning jobs.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.list = async (params = {}) => {\n            return new Pager(PagedItem.PAGED_ITEM_TUNING_JOBS, (x) => this.listInternal(x), await this.listInternal(params), params);\n        };\n        /**\n         * Creates a supervised fine-tuning job.\n         *\n         * @param params - The parameters for the tuning job.\n         * @return - A TuningJob operation.\n         *\n         * @experimental - The SDK's tuning implementation is experimental, and may\n         * change in future versions.\n         */\n        this.tune = async (params) => {\n            var _a;\n            if (this.apiClient.isVertexAI()) {\n                if (params.baseModel.startsWith('projects/')) {\n                    const preTunedModel = {\n                        tunedModelName: params.baseModel,\n                    };\n                    if ((_a = params.config) === null || _a === void 0 ? void 0 : _a.preTunedModelCheckpointId) {\n                        preTunedModel.checkpointId = params.config.preTunedModelCheckpointId;\n                    }\n                    const paramsPrivate = Object.assign(Object.assign({}, params), { preTunedModel: preTunedModel });\n                    paramsPrivate.baseModel = undefined;\n                    return await this.tuneInternal(paramsPrivate);\n                }\n                else {\n                    const paramsPrivate = Object.assign({}, params);\n                    return await this.tuneInternal(paramsPrivate);\n                }\n            }\n            else {\n                const paramsPrivate = Object.assign({}, params);\n                const operation = await this.tuneMldevInternal(paramsPrivate);\n                let tunedModelName = '';\n                if (operation['metadata'] !== undefined &&\n                    operation['metadata']['tunedModel'] !== undefined) {\n                    tunedModelName = operation['metadata']['tunedModel'];\n                }\n                else if (operation['name'] !== undefined &&\n                    operation['name'].includes('/operations/')) {\n                    tunedModelName = operation['name'].split('/operations/')[0];\n                }\n                const tuningJob = {\n                    name: tunedModelName,\n                    state: JobState.JOB_STATE_QUEUED,\n                };\n                return tuningJob;\n            }\n        };\n    }\n    async getInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = getTuningJobParametersToVertex(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            const body = getTuningJobParametersToMldev(params);\n            path = formatMap('{name}', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n    async listInternal(params) {\n        var _a, _b, _c, _d;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = listTuningJobsParametersToVertex(params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromVertex(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n        else {\n            const body = listTuningJobsParametersToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'GET',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = listTuningJobsResponseFromMldev(apiResponse);\n                const typedResp = new ListTuningJobsResponse();\n                Object.assign(typedResp, resp);\n                return typedResp;\n            });\n        }\n    }\n    /**\n     * Cancels a tuning job.\n     *\n     * @param params - The parameters for the cancel request.\n     * @return The empty response returned by the API.\n     *\n     * @example\n     * ```ts\n     * await ai.tunings.cancel({name: '...'}); // The server-generated resource name.\n     * ```\n     */\n    async cancel(params) {\n        var _a, _b, _c, _d;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = cancelTuningJobParametersToVertex(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            });\n        }\n        else {\n            const body = cancelTuningJobParametersToMldev(params);\n            path = formatMap('{name}:cancel', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            await this.apiClient.request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_c = params.config) === null || _c === void 0 ? void 0 : _c.httpOptions,\n                abortSignal: (_d = params.config) === null || _d === void 0 ? void 0 : _d.abortSignal,\n            });\n        }\n    }\n    async tuneInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            const body = createTuningJobParametersPrivateToVertex(params);\n            path = formatMap('tuningJobs', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningJobFromVertex(apiResponse);\n                return resp;\n            });\n        }\n        else {\n            throw new Error('This method is only supported by the Vertex AI.');\n        }\n    }\n    async tuneMldevInternal(params) {\n        var _a, _b;\n        let response;\n        let path = '';\n        let queryParams = {};\n        if (this.apiClient.isVertexAI()) {\n            throw new Error('This method is only supported by the Gemini Developer API.');\n        }\n        else {\n            const body = createTuningJobParametersPrivateToMldev(params);\n            path = formatMap('tunedModels', body['_url']);\n            queryParams = body['_query'];\n            delete body['_url'];\n            delete body['_query'];\n            response = this.apiClient\n                .request({\n                path: path,\n                queryParams: queryParams,\n                body: JSON.stringify(body),\n                httpMethod: 'POST',\n                httpOptions: (_a = params.config) === null || _a === void 0 ? void 0 : _a.httpOptions,\n                abortSignal: (_b = params.config) === null || _b === void 0 ? void 0 : _b.abortSignal,\n            })\n                .then((httpResponse) => {\n                return httpResponse.json().then((jsonResponse) => {\n                    const response = jsonResponse;\n                    response.sdkHttpResponse = {\n                        headers: httpResponse.headers,\n                    };\n                    return response;\n                });\n            });\n            return response.then((apiResponse) => {\n                const resp = tuningOperationFromMldev(apiResponse);\n                return resp;\n            });\n        }\n    }\n}\n\nconst MAX_CHUNK_SIZE = 1024 * 1024 * 8; // bytes\nconst MAX_RETRY_COUNT = 3;\nconst INITIAL_RETRY_DELAY_MS = 1000;\nconst DELAY_MULTIPLIER = 2;\nconst X_GOOG_UPLOAD_STATUS_HEADER_FIELD = 'x-goog-upload-status';\nasync function uploadBlob(file, uploadUrl, apiClient) {\n    var _a, _b, _c;\n    let fileSize = 0;\n    let offset = 0;\n    let response = new HttpResponse(new Response());\n    let uploadCommand = 'upload';\n    fileSize = file.size;\n    while (offset < fileSize) {\n        const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n        const chunk = file.slice(offset, offset + chunkSize);\n        if (offset + chunkSize >= fileSize) {\n            uploadCommand += ', finalize';\n        }\n        let retryCount = 0;\n        let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n        while (retryCount < MAX_RETRY_COUNT) {\n            response = await apiClient.request({\n                path: '',\n                body: chunk,\n                httpMethod: 'POST',\n                httpOptions: {\n                    apiVersion: '',\n                    baseUrl: uploadUrl,\n                    headers: {\n                        'X-Goog-Upload-Command': uploadCommand,\n                        'X-Goog-Upload-Offset': String(offset),\n                        'Content-Length': String(chunkSize),\n                    },\n                },\n            });\n            if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                break;\n            }\n            retryCount++;\n            await sleep(currentDelayMs);\n            currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n        }\n        offset += chunkSize;\n        // The `x-goog-upload-status` header field can be `active`, `final` and\n        //`cancelled` in resposne.\n        if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n            break;\n        }\n        // TODO(b/401391430) Investigate why the upload status is not finalized\n        // even though all content has been uploaded.\n        if (fileSize <= offset) {\n            throw new Error('All content has been uploaded, but the upload status is not finalized.');\n        }\n    }\n    const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n    if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n        throw new Error('Failed to upload file: Upload status is not finalized.');\n    }\n    return responseJson['file'];\n}\nasync function getBlobStat(file) {\n    const fileStat = { size: file.size, type: file.type };\n    return fileStat;\n}\nfunction sleep(ms) {\n    return new Promise((resolvePromise) => setTimeout(resolvePromise, ms));\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nclass NodeUploader {\n    async stat(file) {\n        const fileStat = { size: 0, type: undefined };\n        if (typeof file === 'string') {\n            const originalStat = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.stat(file);\n            fileStat.size = originalStat.size;\n            fileStat.type = this.inferMimeType(file);\n            return fileStat;\n        }\n        else {\n            return await getBlobStat(file);\n        }\n    }\n    async upload(file, uploadUrl, apiClient) {\n        if (typeof file === 'string') {\n            return await this.uploadFileFromPath(file, uploadUrl, apiClient);\n        }\n        else {\n            return uploadBlob(file, uploadUrl, apiClient);\n        }\n    }\n    /**\n     * Infers the MIME type of a file based on its extension.\n     *\n     * @param filePath The path to the file.\n     * @returns The MIME type of the file, or undefined if it cannot be inferred.\n     */\n    inferMimeType(filePath) {\n        // Get the file extension.\n        const fileExtension = filePath.slice(filePath.lastIndexOf('.') + 1);\n        // Create a map of file extensions to MIME types.\n        const mimeTypes = {\n            'aac': 'audio/aac',\n            'abw': 'application/x-abiword',\n            'arc': 'application/x-freearc',\n            'avi': 'video/x-msvideo',\n            'azw': 'application/vnd.amazon.ebook',\n            'bin': 'application/octet-stream',\n            'bmp': 'image/bmp',\n            'bz': 'application/x-bzip',\n            'bz2': 'application/x-bzip2',\n            'csh': 'application/x-csh',\n            'css': 'text/css',\n            'csv': 'text/csv',\n            'doc': 'application/msword',\n            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            'eot': 'application/vnd.ms-fontobject',\n            'epub': 'application/epub+zip',\n            'gz': 'application/gzip',\n            'gif': 'image/gif',\n            'htm': 'text/html',\n            'html': 'text/html',\n            'ico': 'image/vnd.microsoft.icon',\n            'ics': 'text/calendar',\n            'jar': 'application/java-archive',\n            'jpeg': 'image/jpeg',\n            'jpg': 'image/jpeg',\n            'js': 'text/javascript',\n            'json': 'application/json',\n            'jsonld': 'application/ld+json',\n            'kml': 'application/vnd.google-earth.kml+xml',\n            'kmz': 'application/vnd.google-earth.kmz+xml',\n            'mjs': 'text/javascript',\n            'mp3': 'audio/mpeg',\n            'mp4': 'video/mp4',\n            'mpeg': 'video/mpeg',\n            'mpkg': 'application/vnd.apple.installer+xml',\n            'odt': 'application/vnd.oasis.opendocument.text',\n            'oga': 'audio/ogg',\n            'ogv': 'video/ogg',\n            'ogx': 'application/ogg',\n            'opus': 'audio/opus',\n            'otf': 'font/otf',\n            'png': 'image/png',\n            'pdf': 'application/pdf',\n            'php': 'application/x-httpd-php',\n            'ppt': 'application/vnd.ms-powerpoint',\n            'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\n            'rar': 'application/vnd.rar',\n            'rtf': 'application/rtf',\n            'sh': 'application/x-sh',\n            'svg': 'image/svg+xml',\n            'swf': 'application/x-shockwave-flash',\n            'tar': 'application/x-tar',\n            'tif': 'image/tiff',\n            'tiff': 'image/tiff',\n            'ts': 'video/mp2t',\n            'ttf': 'font/ttf',\n            'txt': 'text/plain',\n            'vsd': 'application/vnd.visio',\n            'wav': 'audio/wav',\n            'weba': 'audio/webm',\n            'webm': 'video/webm',\n            'webp': 'image/webp',\n            'woff': 'font/woff',\n            'woff2': 'font/woff2',\n            'xhtml': 'application/xhtml+xml',\n            'xls': 'application/vnd.ms-excel',\n            'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            'xml': 'application/xml',\n            'xul': 'application/vnd.mozilla.xul+xml',\n            'zip': 'application/zip',\n            '3gp': 'video/3gpp',\n            '3g2': 'video/3gpp2',\n            '7z': 'application/x-7z-compressed',\n        };\n        // Look up the MIME type based on the file extension.\n        const mimeType = mimeTypes[fileExtension.toLowerCase()];\n        // Return the MIME type.\n        return mimeType;\n    }\n    async uploadFileFromPath(file, uploadUrl, apiClient) {\n        var _a, _b, _c;\n        let fileSize = 0;\n        let offset = 0;\n        let response = new HttpResponse(new Response());\n        let uploadCommand = 'upload';\n        let fileHandle;\n        try {\n            fileHandle = await fs_promises__WEBPACK_IMPORTED_MODULE_4__.open(file, 'r');\n            if (!fileHandle) {\n                throw new Error(`Failed to open file`);\n            }\n            fileSize = (await fileHandle.stat()).size;\n            while (offset < fileSize) {\n                const chunkSize = Math.min(MAX_CHUNK_SIZE, fileSize - offset);\n                if (offset + chunkSize >= fileSize) {\n                    uploadCommand += ', finalize';\n                }\n                const buffer = new Uint8Array(chunkSize);\n                const { bytesRead: bytesRead } = await fileHandle.read(buffer, 0, chunkSize, offset);\n                if (bytesRead !== chunkSize) {\n                    throw new Error(`Failed to read ${chunkSize} bytes from file at offset ${offset}. bytes actually read: ${bytesRead}`);\n                }\n                const chunk = new Blob([buffer]);\n                let retryCount = 0;\n                let currentDelayMs = INITIAL_RETRY_DELAY_MS;\n                while (retryCount < MAX_RETRY_COUNT) {\n                    response = await apiClient.request({\n                        path: '',\n                        body: chunk,\n                        httpMethod: 'POST',\n                        httpOptions: {\n                            apiVersion: '',\n                            baseUrl: uploadUrl,\n                            headers: {\n                                'X-Goog-Upload-Command': uploadCommand,\n                                'X-Goog-Upload-Offset': String(offset),\n                                'Content-Length': String(bytesRead),\n                            },\n                        },\n                    });\n                    if ((_a = response === null || response === void 0 ? void 0 : response.headers) === null || _a === void 0 ? void 0 : _a[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) {\n                        break;\n                    }\n                    retryCount++;\n                    await sleep(currentDelayMs);\n                    currentDelayMs = currentDelayMs * DELAY_MULTIPLIER;\n                }\n                offset += bytesRead;\n                // The `x-goog-upload-status` header field can be `active`, `final` and\n                //`cancelled` in resposne.\n                if (((_b = response === null || response === void 0 ? void 0 : response.headers) === null || _b === void 0 ? void 0 : _b[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'active') {\n                    break;\n                }\n                if (fileSize <= offset) {\n                    throw new Error('All content has been uploaded, but the upload status is not finalized.');\n                }\n            }\n            const responseJson = (await (response === null || response === void 0 ? void 0 : response.json()));\n            if (((_c = response === null || response === void 0 ? void 0 : response.headers) === null || _c === void 0 ? void 0 : _c[X_GOOG_UPLOAD_STATUS_HEADER_FIELD]) !== 'final') {\n                throw new Error('Failed to upload file: Upload status is not finalized.');\n            }\n            return responseJson['file'];\n        }\n        finally {\n            // Ensure the file handle is always closed\n            if (fileHandle) {\n                await fileHandle.close();\n            }\n        }\n    }\n}\n\n/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst LANGUAGE_LABEL_PREFIX = 'gl-node/';\n/**\n * The Google GenAI SDK.\n *\n * @remarks\n * Provides access to the GenAI features through either the {@link\n * https://cloud.google.com/vertex-ai/docs/reference/rest | Gemini API} or\n * the {@link https://cloud.google.com/vertex-ai/docs/reference/rest | Vertex AI\n * API}.\n *\n * The {@link GoogleGenAIOptions.vertexai} value determines which of the API\n * services to use.\n *\n * When using the Gemini API, a {@link GoogleGenAIOptions.apiKey} must also be\n * set. When using Vertex AI, both {@link GoogleGenAIOptions.project} and {@link\n * GoogleGenAIOptions.location} must be set, or a {@link\n * GoogleGenAIOptions.apiKey} must be set when using Express Mode.\n *\n * Explicitly passed in values in {@link GoogleGenAIOptions} will always take\n * precedence over environment variables. If both project/location and api_key\n * exist in the environment variables, the project/location will be used.\n *\n * @example\n * Initializing the SDK for using the Gemini API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({apiKey: 'GEMINI_API_KEY'});\n * ```\n *\n * @example\n * Initializing the SDK for using the Vertex AI API:\n * ```ts\n * import {GoogleGenAI} from '@google/genai';\n * const ai = new GoogleGenAI({\n *   vertexai: true,\n *   project: 'PROJECT_ID',\n *   location: 'PROJECT_LOCATION'\n * });\n * ```\n *\n */\nclass GoogleGenAI {\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f;\n        // Validate explicitly set initializer values.\n        if ((options.project || options.location) && options.apiKey) {\n            throw new Error('Project/location and API key are mutually exclusive in the client initializer.');\n        }\n        this.vertexai =\n            (_b = (_a = options.vertexai) !== null && _a !== void 0 ? _a : getBooleanEnv('GOOGLE_GENAI_USE_VERTEXAI')) !== null && _b !== void 0 ? _b : false;\n        const envApiKey = getApiKeyFromEnv();\n        const envProject = getEnv('GOOGLE_CLOUD_PROJECT');\n        const envLocation = getEnv('GOOGLE_CLOUD_LOCATION');\n        this.apiKey = (_c = options.apiKey) !== null && _c !== void 0 ? _c : envApiKey;\n        this.project = (_d = options.project) !== null && _d !== void 0 ? _d : envProject;\n        this.location = (_e = options.location) !== null && _e !== void 0 ? _e : envLocation;\n        // Handle when to use Vertex AI in express mode (api key)\n        if (options.vertexai) {\n            if ((_f = options.googleAuthOptions) === null || _f === void 0 ? void 0 : _f.credentials) {\n                // Explicit credentials take precedence over implicit api_key.\n                console.debug('The user provided Google Cloud credentials will take precedence' +\n                    ' over the API key from the environment variable.');\n                this.apiKey = undefined;\n            }\n            // Explicit api_key and explicit project/location already handled above.\n            if ((envProject || envLocation) && options.apiKey) {\n                // Explicit api_key takes precedence over implicit project/location.\n                console.debug('The user provided Vertex AI API key will take precedence over' +\n                    ' the project/location from the environment variables.');\n                this.project = undefined;\n                this.location = undefined;\n            }\n            else if ((options.project || options.location) && envApiKey) {\n                // Explicit project/location takes precedence over implicit api_key.\n                console.debug('The user provided project/location will take precedence over' +\n                    ' the API key from the environment variables.');\n                this.apiKey = undefined;\n            }\n            else if ((envProject || envLocation) && envApiKey) {\n                // Implicit project/location takes precedence over implicit api_key.\n                console.debug('The project/location from the environment variables will take' +\n                    ' precedence over the API key from the environment variables.');\n                this.apiKey = undefined;\n            }\n        }\n        const baseUrl = getBaseUrl(options.httpOptions, options.vertexai, getEnv('GOOGLE_VERTEX_BASE_URL'), getEnv('GOOGLE_GEMINI_BASE_URL'));\n        if (baseUrl) {\n            if (options.httpOptions) {\n                options.httpOptions.baseUrl = baseUrl;\n            }\n            else {\n                options.httpOptions = { baseUrl: baseUrl };\n            }\n        }\n        this.apiVersion = options.apiVersion;\n        const auth = new NodeAuth({\n            apiKey: this.apiKey,\n            googleAuthOptions: options.googleAuthOptions,\n        });\n        this.apiClient = new ApiClient({\n            auth: auth,\n            project: this.project,\n            location: this.location,\n            apiVersion: this.apiVersion,\n            apiKey: this.apiKey,\n            vertexai: this.vertexai,\n            httpOptions: options.httpOptions,\n            userAgentExtra: LANGUAGE_LABEL_PREFIX + process.version,\n            uploader: new NodeUploader(),\n            downloader: new NodeDownloader(),\n        });\n        this.models = new Models(this.apiClient);\n        this.live = new Live(this.apiClient, auth, new NodeWebSocketFactory());\n        this.batches = new Batches(this.apiClient);\n        this.chats = new Chats(this.models, this.apiClient);\n        this.caches = new Caches(this.apiClient);\n        this.files = new Files(this.apiClient);\n        this.operations = new Operations(this.apiClient);\n        this.authTokens = new Tokens(this.apiClient);\n        this.tunings = new Tunings(this.apiClient);\n    }\n}\nfunction getEnv(env) {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a[env]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : undefined;\n}\nfunction getBooleanEnv(env) {\n    return stringToBoolean(getEnv(env));\n}\nfunction stringToBoolean(str) {\n    if (str === undefined) {\n        return false;\n    }\n    return str.toLowerCase() === 'true';\n}\nfunction getApiKeyFromEnv() {\n    const envGoogleApiKey = getEnv('GOOGLE_API_KEY');\n    const envGeminiApiKey = getEnv('GEMINI_API_KEY');\n    if (envGoogleApiKey && envGeminiApiKey) {\n        console.warn('Both GOOGLE_API_KEY and GEMINI_API_KEY are set. Using GOOGLE_API_KEY.');\n    }\n    return envGoogleApiKey || envGeminiApiKey || undefined;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGdvb2dsZS9nZW5haS9kaXN0L25vZGUvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRDtBQUNDO0FBQ1g7QUFDVjtBQUNLOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQTZDO0FBQ3BFO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxLQUFLO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsc0JBQXNCLFdBQVc7QUFDbEY7QUFDQTtBQUNBLGdGQUFnRixJQUFJO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnRUFBZ0U7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0VBQWdFO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4REFBOEQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9FQUFvRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwREFBMEQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBEQUEwRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnREFBZ0Q7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0Q0FBNEM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQ0FBb0M7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdFQUFnRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0JBQXNCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrREFBa0Q7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDREQUE0RDtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxjQUFjO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix3REFBd0Q7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEMsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGNBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxVQUFVLFNBQVM7QUFDN0Q7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCLGFBQWEsd0JBQXdCLEdBQUcsaUJBQWlCO0FBQzNHO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCLGFBQWEsd0JBQXdCLHFCQUFxQixpQkFBaUI7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxZQUFZO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx5QkFBeUI7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0NBQStDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUcsU0FBUyxlQUFlLEdBQUcsZUFBZTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUyxhQUFhLEdBQUcsZUFBZSxFQUFFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxvQkFBb0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZUFBZTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CLEdBQUcsYUFBYTtBQUNuRTtBQUNBLDRDQUE0QyxlQUFlO0FBQzNELCtCQUErQixvQkFBb0IsYUFBYSxxQkFBcUIsR0FBRyxhQUFhO0FBQ3JHO0FBQ0E7QUFDQSwrQkFBK0Isb0JBQW9CLGFBQWEscUJBQXFCLEdBQUcsZUFBZSxHQUFHLGFBQWE7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWUsR0FBRyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsNEVBQTRFLElBQUk7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBLDZFQUE2RSxJQUFJO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFdBQVc7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsU0FBUyxjQUFjO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVMsY0FBYztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwREFBMEQ7QUFDN0U7QUFDQSxzQkFBc0IsNkRBQTZEO0FBQ25GO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFDQUFxQztBQUN4RCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUyxlQUFlO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxZQUFZO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxnREFBZ0QsWUFBWTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sUUFBUSxhQUFhO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLFFBQVEsYUFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsWUFBWSxHQUFHO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxLQUFLO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWSxHQUFHO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFNBQVMsZUFBZTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVksR0FBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWSxHQUFHO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5Q0FBeUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMEJBQTBCO0FBQy9EO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHdCQUF3QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDBCQUEwQjtBQUMvRDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEcsZ0dBQWdHO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsU0FBUyxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwQ0FBMEM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxLQUFLO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QiwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxXQUFXLDhGQUE4RjtBQUNwSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNEJBQTRCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDJCQUEyQixhQUFhLDRCQUE0QjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxrQkFBa0Isb0JBQW9CO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEVBQTBFLGtCQUFrQixvQkFBb0I7QUFDaEg7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxjQUFjO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU8sSUFBSSwwQkFBMEI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxxQkFBcUIsSUFBSSxFQUFFO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxlQUFlO0FBQzdFLDREQUE0RCxjQUFjO0FBQzFFLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSSxvQkFBb0IsbUJBQW1CLGNBQWMsbUJBQW1CO0FBQ3BMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsVUFBVTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxRQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUcseUNBQXlDO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxhQUFhO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCLG1DQUFtQyxXQUFXLDJDQUEyQyxPQUFPO0FBQ3hJO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDhEQUE4RCxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQiw4QkFBOEIsV0FBVztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0ksbUNBQW1DLHdCQUF3QixHQUFHO0FBQ3RNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGlCQUFpQixtQ0FBbUMsV0FBVyxxQkFBcUIsT0FBTyxHQUFHLFFBQVEsR0FBRyxPQUFPO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVEsYUFBYSxTQUFTO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixvQkFBb0I7QUFDdEc7QUFDQTtBQUNBLGlDQUFpQyxvREFBb0Q7QUFDckY7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsd0JBQXdCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQ0FBc0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGVBQWU7QUFDekM7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUNBQXFDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLHFCQUFxQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9CQUFvQix5QkFBeUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGdDQUFnQyxxQkFBcUI7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSEFBZ0gsOEVBQThFO0FBQzlMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFNQUFxTSxnQkFBZ0IsaUJBQWlCLHVCQUF1QjtBQUM3UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsdUZBQXVGO0FBQ2hNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHVGQUF1RjtBQUNoTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsMEJBQTBCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE1BQU07QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsYUFBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLElBQUksR0FBRyxHQUFHO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxPQUFPO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIseUJBQXlCO0FBQ25ELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQVU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSx5QkFBeUI7QUFDbEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscURBQWlCO0FBQ2hELGdCQUFnQixpREFBUTtBQUN4QjtBQUNBO0FBQ0EsZ0JBQWdCLDZDQUFTLGtDQUFrQyxvQkFBb0I7QUFDL0U7QUFDQSxtRUFBbUUsb0JBQW9CLElBQUksTUFBTTtBQUNqRztBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsS0FBSztBQUNoQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IseUNBQWdCLGFBQWEsdUJBQXVCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGFBQWEsOEJBQThCO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixLQUFLO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVksR0FBRztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHVDQUF1Qyw2Q0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNkNBQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0Esc0RBQXNELFdBQVcsNEJBQTRCLE9BQU8seUJBQXlCLFVBQVU7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RCx3RUFBd0U7QUFDeEUsUUFBUTtBQUNSLE9BQU87QUFDUDtBQUNBLFFBQVEsbUNBQW1DO0FBQzNDO0FBQ0E7QUFDQSxpQ0FBaUMsaUNBQWlDO0FBQ2xFLG9DQUFvQyxrQ0FBa0MsS0FBSztBQUMzRSxnQ0FBZ0MsbUJBQW1CO0FBQ25ELDhCQUE4QjtBQUM5QjtBQUNBLG1DQUFtQywwQkFBMEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStsRTtBQUMvbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXRoLXByb2JsZW0tZ2VuZXJhdG9yLy4vbm9kZV9tb2R1bGVzL0Bnb29nbGUvZ2VuYWkvZGlzdC9ub2RlL2luZGV4Lm1qcz8wZDk4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEdvb2dsZUF1dGggfSBmcm9tICdnb29nbGUtYXV0aC1saWJyYXJ5JztcbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtLCB3cml0ZUZpbGUgfSBmcm9tICdmcyc7XG5pbXBvcnQgeyBSZWFkYWJsZSB9IGZyb20gJ25vZGU6c3RyZWFtJztcbmltcG9ydCAqIGFzIE5vZGVXcyBmcm9tICd3cyc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy9wcm9taXNlcyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmxldCBfZGVmYXVsdEJhc2VHZW1pbmlVcmwgPSB1bmRlZmluZWQ7XG5sZXQgX2RlZmF1bHRCYXNlVmVydGV4VXJsID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBPdmVycmlkZXMgdGhlIGJhc2UgVVJMcyBmb3IgdGhlIEdlbWluaSBBUEkgYW5kIFZlcnRleCBBSSBBUEkuXG4gKlxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBpbml0aWFsaXppbmcgdGhlIFNESy4gSWYgdGhlXG4gKiBiYXNlIFVSTHMgYXJlIHNldCBhZnRlciBpbml0aWFsaXppbmcgdGhlIFNESywgdGhlIGJhc2UgVVJMcyB3aWxsIG5vdCBiZVxuICogdXBkYXRlZC4gQmFzZSBVUkxzIHByb3ZpZGVkIGluIHRoZSBIdHRwT3B0aW9ucyB3aWxsIGFsc28gdGFrZSBwcmVjZWRlbmNlIG92ZXJcbiAqIFVSTHMgc2V0IGhlcmUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJLCBzZXREZWZhdWx0QmFzZVVybHN9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogLy8gT3ZlcnJpZGUgdGhlIGJhc2UgVVJMIGZvciB0aGUgR2VtaW5pIEFQSS5cbiAqIHNldERlZmF1bHRCYXNlVXJscyh7Z2VtaW5pVXJsOidodHRwczovL2dlbWluaS5nb29nbGUuY29tJ30pO1xuICpcbiAqIC8vIE92ZXJyaWRlIHRoZSBiYXNlIFVSTCBmb3IgdGhlIFZlcnRleCBBSSBBUEkuXG4gKiBzZXREZWZhdWx0QmFzZVVybHMoe3ZlcnRleFVybDogJ2h0dHBzOi8vdmVydGV4YWkuZ29vZ2xlYXBpcy5jb20nfSk7XG4gKlxuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHNldERlZmF1bHRCYXNlVXJscyhiYXNlVXJsUGFyYW1zKSB7XG4gICAgX2RlZmF1bHRCYXNlR2VtaW5pVXJsID0gYmFzZVVybFBhcmFtcy5nZW1pbmlVcmw7XG4gICAgX2RlZmF1bHRCYXNlVmVydGV4VXJsID0gYmFzZVVybFBhcmFtcy52ZXJ0ZXhVcmw7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmF1bHQgYmFzZSBVUkxzIGZvciB0aGUgR2VtaW5pIEFQSSBhbmQgVmVydGV4IEFJIEFQSS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVmYXVsdEJhc2VVcmxzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGdlbWluaVVybDogX2RlZmF1bHRCYXNlR2VtaW5pVXJsLFxuICAgICAgICB2ZXJ0ZXhVcmw6IF9kZWZhdWx0QmFzZVZlcnRleFVybCxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGJhc2VkIG9uIHRoZSBmb2xsb3dpbmcgcHJpb3JpdHk6XG4gKiAgIDEuIEJhc2UgVVJMcyBzZXQgdmlhIEh0dHBPcHRpb25zLlxuICogICAyLiBCYXNlIFVSTHMgc2V0IHZpYSB0aGUgbGF0ZXN0IGNhbGwgdG8gc2V0RGVmYXVsdEJhc2VVcmxzLlxuICogICAzLiBCYXNlIFVSTHMgc2V0IHZpYSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIGdldEJhc2VVcmwoaHR0cE9wdGlvbnMsIHZlcnRleGFpLCB2ZXJ0ZXhCYXNlVXJsRnJvbUVudiwgZ2VtaW5pQmFzZVVybEZyb21FbnYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghKGh0dHBPcHRpb25zID09PSBudWxsIHx8IGh0dHBPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwT3B0aW9ucy5iYXNlVXJsKSkge1xuICAgICAgICBjb25zdCBkZWZhdWx0QmFzZVVybHMgPSBnZXREZWZhdWx0QmFzZVVybHMoKTtcbiAgICAgICAgaWYgKHZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gZGVmYXVsdEJhc2VVcmxzLnZlcnRleFVybCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmVydGV4QmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gKF9iID0gZGVmYXVsdEJhc2VVcmxzLmdlbWluaVVybCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZ2VtaW5pQmFzZVVybEZyb21FbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGh0dHBPcHRpb25zLmJhc2VVcmw7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEJhc2VNb2R1bGUge1xufVxuZnVuY3Rpb24gZm9ybWF0TWFwKHRlbXBsYXRlU3RyaW5nLCB2YWx1ZU1hcCkge1xuICAgIC8vIFVzZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBmaW5kIGFsbCBwbGFjZWhvbGRlcnMgaW4gdGhlIHRlbXBsYXRlIHN0cmluZ1xuICAgIGNvbnN0IHJlZ2V4ID0gL1xceyhbXn1dKylcXH0vZztcbiAgICAvLyBSZXBsYWNlIGVhY2ggcGxhY2Vob2xkZXIgd2l0aCBpdHMgY29ycmVzcG9uZGluZyB2YWx1ZSBmcm9tIHRoZSB2YWx1ZU1hcFxuICAgIHJldHVybiB0ZW1wbGF0ZVN0cmluZy5yZXBsYWNlKHJlZ2V4LCAobWF0Y2gsIGtleSkgPT4ge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlTWFwLCBrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlTWFwW2tleV07XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIHN0cmluZyBpZiBpdCdzIG5vdCBhIHN0cmluZyBhbHJlYWR5XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCA/IFN0cmluZyh2YWx1ZSkgOiAnJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXNzaW5nIGtleXNcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICcke2tleX0nIG5vdCBmb3VuZCBpbiB2YWx1ZU1hcC5gKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVCeVBhdGgoZGF0YSwga2V5cywgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmIChrZXkuZW5kc1dpdGgoJ1tdJykpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleU5hbWUgPSBrZXkuc2xpY2UoMCwgLTIpO1xuICAgICAgICAgICAgaWYgKCEoa2V5TmFtZSBpbiBkYXRhKSkge1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2tleU5hbWVdID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdmFsdWUubGVuZ3RoIH0sICgpID0+ICh7fSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBWYWx1ZSBtdXN0IGJlIGEgbGlzdCBnaXZlbiBhbiBhcnJheSBwYXRoICR7a2V5fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5TmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gZGF0YVtrZXlOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBhcnJheURhdGEubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gYXJyYXlEYXRhW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoZW50cnksIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZVtqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZCBvZiBhcnJheURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFZhbHVlQnlQYXRoKGQsIGtleXMuc2xpY2UoaSArIDEpLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5LmVuZHNXaXRoKCdbMF0nKSkge1xuICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMyk7XG4gICAgICAgICAgICBpZiAoIShrZXlOYW1lIGluIGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXlOYW1lXSA9IFt7fV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgc2V0VmFsdWVCeVBhdGgoYXJyYXlEYXRhWzBdLCBrZXlzLnNsaWNlKGkgKyAxKSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YVtrZXldIHx8IHR5cGVvZiBkYXRhW2tleV0gIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gZGF0YVtrZXldO1xuICAgIH1cbiAgICBjb25zdCBrZXlUb1NldCA9IGtleXNba2V5cy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBleGlzdGluZ0RhdGEgPSBkYXRhW2tleVRvU2V0XTtcbiAgICBpZiAoZXhpc3RpbmdEYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IGV4aXN0aW5nRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXhpc3RpbmdEYXRhID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgZXhpc3RpbmdEYXRhICE9PSBudWxsICYmXG4gICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihleGlzdGluZ0RhdGEsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCB2YWx1ZSBmb3IgYW4gZXhpc3Rpbmcga2V5LiBLZXk6ICR7a2V5VG9TZXR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChrZXlUb1NldCA9PT0gJ19zZWxmJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVBc1JlY29yZCA9IHZhbHVlO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihkYXRhLCB2YWx1ZUFzUmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFba2V5VG9TZXRdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRWYWx1ZUJ5UGF0aChkYXRhLCBrZXlzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxICYmIGtleXNbMF0gPT09ICdfc2VsZicpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5LmVuZHNXaXRoKCdbXScpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5TmFtZSA9IGtleS5zbGljZSgwLCAtMik7XG4gICAgICAgICAgICAgICAgaWYgKGtleU5hbWUgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcnJheURhdGEgPSBkYXRhW2tleU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlEYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXlEYXRhLm1hcCgoZCkgPT4gZ2V0VmFsdWVCeVBhdGgoZCwga2V5cy5zbGljZShpICsgMSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIHRCeXRlcyQxKGZyb21CeXRlcykge1xuICAgIGlmICh0eXBlb2YgZnJvbUJ5dGVzICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Zyb21JbWFnZUJ5dGVzIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgLy8gVE9ETyhiLzM4OTEzMzkxNCk6IFJlbW92ZSBkdW1teSBieXRlcyBjb252ZXJ0ZXIuXG4gICAgcmV0dXJuIGZyb21CeXRlcztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLy8gQ29kZSBnZW5lcmF0ZWQgYnkgdGhlIEdvb2dsZSBHZW4gQUkgU0RLIGdlbmVyYXRvciBETyBOT1QgRURJVC5cbmZ1bmN0aW9uIGZldGNoUHJlZGljdE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3BlcmF0aW9uTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ29wZXJhdGlvbk5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3BlcmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29wZXJhdGlvbk5hbWUnXSwgZnJvbU9wZXJhdGlvbk5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzb3VyY2VOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvdXJjZU5hbWUnXSk7XG4gICAgaWYgKGZyb21SZXNvdXJjZU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ3Jlc291cmNlTmFtZSddLCBmcm9tUmVzb3VyY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYkMShmcm9tUmVzcG9uc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnXSk7XG4gICAgaWYgKGZyb21NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21ldGFkYXRhJ10sIGZyb21NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlZFNhbXBsZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZFZpZGVvcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZENvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkUmVhc29ucyddLCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvcyddKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZFZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkVmlkZW9zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZFZpZGVvRnJvbVZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tTWxkZXYkMShmcm9tVmlkZW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4JDEoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0T3BlcmF0aW9uUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PcGVyYXRpb25OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3BlcmF0aW9uTmFtZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PcGVyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdvcGVyYXRpb25OYW1lJ10sIGZyb21PcGVyYXRpb25OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2aWRlbycsICd1cmknXSk7XG4gICAgaWYgKGZyb21VcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmknXSwgZnJvbVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb0J5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW8nLFxuICAgICAgICAnZW5jb2RlZFZpZGVvJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb0J5dGVzJ10sIHRCeXRlcyQxKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5jb2RpbmcnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzJDEoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKiogUmVxdWlyZWQuIE91dGNvbWUgb2YgdGhlIGNvZGUgZXhlY3V0aW9uLiAqL1xudmFyIE91dGNvbWU7XG4oZnVuY3Rpb24gKE91dGNvbWUpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBzdGF0dXMuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIE91dGNvbWVbXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCJdID0gXCJPVVRDT01FX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9PS1wiXSA9IFwiT1VUQ09NRV9PS1wiO1xuICAgIC8qKlxuICAgICAqIENvZGUgZXhlY3V0aW9uIGZpbmlzaGVkIGJ1dCB3aXRoIGEgZmFpbHVyZS4gYHN0ZGVycmAgc2hvdWxkIGNvbnRhaW4gdGhlIHJlYXNvbi5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9GQUlMRURcIl0gPSBcIk9VVENPTUVfRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogQ29kZSBleGVjdXRpb24gcmFuIGZvciB0b28gbG9uZywgYW5kIHdhcyBjYW5jZWxsZWQuIFRoZXJlIG1heSBvciBtYXkgbm90IGJlIGEgcGFydGlhbCBvdXRwdXQgcHJlc2VudC5cbiAgICAgKi9cbiAgICBPdXRjb21lW1wiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiXSA9IFwiT1VUQ09NRV9ERUFETElORV9FWENFRURFRFwiO1xufSkoT3V0Y29tZSB8fCAoT3V0Y29tZSA9IHt9KSk7XG4vKiogUmVxdWlyZWQuIFByb2dyYW1taW5nIGxhbmd1YWdlIG9mIHRoZSBgY29kZWAuICovXG52YXIgTGFuZ3VhZ2U7XG4oZnVuY3Rpb24gKExhbmd1YWdlKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgbGFuZ3VhZ2UuIFRoaXMgdmFsdWUgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIExhbmd1YWdlW1wiTEFOR1VBR0VfVU5TUEVDSUZJRURcIl0gPSBcIkxBTkdVQUdFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogUHl0aG9uID49IDMuMTAsIHdpdGggbnVtcHkgYW5kIHNpbXB5IGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBMYW5ndWFnZVtcIlBZVEhPTlwiXSA9IFwiUFlUSE9OXCI7XG59KShMYW5ndWFnZSB8fCAoTGFuZ3VhZ2UgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBUaGUgdHlwZSBvZiB0aGUgZGF0YS4gKi9cbnZhciBUeXBlO1xuKGZ1bmN0aW9uIChUeXBlKSB7XG4gICAgLyoqXG4gICAgICogTm90IHNwZWNpZmllZCwgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICAgICAqL1xuICAgIFR5cGVbXCJUWVBFX1VOU1BFQ0lGSUVEXCJdID0gXCJUWVBFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBzdHJpbmcgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJTVFJJTkdcIl0gPSBcIlNUUklOR1wiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgbnVtYmVyIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiTlVNQkVSXCJdID0gXCJOVU1CRVJcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIGludGVnZXIgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJJTlRFR0VSXCJdID0gXCJJTlRFR0VSXCI7XG4gICAgLyoqXG4gICAgICogT3BlbkFQSSBib29sZWFuIHR5cGVcbiAgICAgKi9cbiAgICBUeXBlW1wiQk9PTEVBTlwiXSA9IFwiQk9PTEVBTlwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5BUEkgYXJyYXkgdHlwZVxuICAgICAqL1xuICAgIFR5cGVbXCJBUlJBWVwiXSA9IFwiQVJSQVlcIjtcbiAgICAvKipcbiAgICAgKiBPcGVuQVBJIG9iamVjdCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk9CSkVDVFwiXSA9IFwiT0JKRUNUXCI7XG4gICAgLyoqXG4gICAgICogTnVsbCB0eXBlXG4gICAgICovXG4gICAgVHlwZVtcIk5VTExcIl0gPSBcIk5VTExcIjtcbn0pKFR5cGUgfHwgKFR5cGUgPSB7fSkpO1xuLyoqIFJlcXVpcmVkLiBIYXJtIGNhdGVnb3J5LiAqL1xudmFyIEhhcm1DYXRlZ29yeTtcbihmdW5jdGlvbiAoSGFybUNhdGVnb3J5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9DQVRFR09SWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGhhdGUgc3BlZWNoLlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFURV9TUEVFQ0hcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBkYW5nZXJvdXMgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQ6IEVsZWN0aW9uIGZpbHRlciBpcyBub3QgbG9uZ2VyIHN1cHBvcnRlZC4gVGhlIGhhcm0gY2F0ZWdvcnkgaXMgY2l2aWMgaW50ZWdyaXR5LlxuICAgICAqL1xuICAgIEhhcm1DYXRlZ29yeVtcIkhBUk1fQ0FURUdPUllfQ0lWSUNfSU5URUdSSVRZXCJdID0gXCJIQVJNX0NBVEVHT1JZX0NJVklDX0lOVEVHUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIGhhdGUuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9IQVRFXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBVEVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBjYXRlZ29yeSBpcyBpbWFnZSBkYW5nZXJvdXMgY29udGVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCJdID0gXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0RBTkdFUk9VU19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gY2F0ZWdvcnkgaXMgaW1hZ2UgaGFyYXNzbWVudC5cbiAgICAgKi9cbiAgICBIYXJtQ2F0ZWdvcnlbXCJIQVJNX0NBVEVHT1JZX0lNQUdFX0hBUkFTU01FTlRcIl0gPSBcIkhBUk1fQ0FURUdPUllfSU1BR0VfSEFSQVNTTUVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGNhdGVnb3J5IGlzIGltYWdlIHNleHVhbGx5IGV4cGxpY2l0IGNvbnRlbnQuXG4gICAgICovXG4gICAgSGFybUNhdGVnb3J5W1wiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiXSA9IFwiSEFSTV9DQVRFR09SWV9JTUFHRV9TRVhVQUxMWV9FWFBMSUNJVFwiO1xufSkoSGFybUNhdGVnb3J5IHx8IChIYXJtQ2F0ZWdvcnkgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBTcGVjaWZ5IGlmIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgb3Igc2V2ZXJpdHkgc2NvcmUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZSB0aHJlc2hvbGQgaXMgdXNlZCBmb3IgcHJvYmFiaWxpdHkgc2NvcmUuICovXG52YXIgSGFybUJsb2NrTWV0aG9kO1xuKGZ1bmN0aW9uIChIYXJtQmxvY2tNZXRob2QpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaGFybSBibG9jayBtZXRob2QgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybUJsb2NrTWV0aG9kW1wiSEFSTV9CTE9DS19NRVRIT0RfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfTUVUSE9EX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGhhcm0gYmxvY2sgbWV0aG9kIHVzZXMgYm90aCBwcm9iYWJpbGl0eSBhbmQgc2V2ZXJpdHkgc2NvcmVzLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja01ldGhvZFtcIlNFVkVSSVRZXCJdID0gXCJTRVZFUklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBoYXJtIGJsb2NrIG1ldGhvZCB1c2VzIHRoZSBwcm9iYWJpbGl0eSBzY29yZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tNZXRob2RbXCJQUk9CQUJJTElUWVwiXSA9IFwiUFJPQkFCSUxJVFlcIjtcbn0pKEhhcm1CbG9ja01ldGhvZCB8fCAoSGFybUJsb2NrTWV0aG9kID0ge30pKTtcbi8qKiBSZXF1aXJlZC4gVGhlIGhhcm0gYmxvY2sgdGhyZXNob2xkLiAqL1xudmFyIEhhcm1CbG9ja1RocmVzaG9sZDtcbihmdW5jdGlvbiAoSGFybUJsb2NrVGhyZXNob2xkKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgaGFybSBibG9jayB0aHJlc2hvbGQuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiSEFSTV9CTE9DS19USFJFU0hPTERfVU5TUEVDSUZJRURcIl0gPSBcIkhBUk1fQkxPQ0tfVEhSRVNIT0xEX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbG93IHRocmVzaG9sZCBhbmQgYWJvdmUgKGkuZS4gYmxvY2sgbW9yZSkuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiQkxPQ0tfTE9XX0FORF9BQk9WRVwiXSA9IFwiQkxPQ0tfTE9XX0FORF9BQk9WRVwiO1xuICAgIC8qKlxuICAgICAqIEJsb2NrIG1lZGl1bSB0aHJlc2hvbGQgYW5kIGFib3ZlLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICAvKipcbiAgICAgKiBCbG9jayBvbmx5IGhpZ2ggdGhyZXNob2xkIChpLmUuIGJsb2NrIGxlc3MpLlxuICAgICAqL1xuICAgIEhhcm1CbG9ja1RocmVzaG9sZFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQmxvY2sgbm9uZS5cbiAgICAgKi9cbiAgICBIYXJtQmxvY2tUaHJlc2hvbGRbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG4gICAgLyoqXG4gICAgICogVHVybiBvZmYgdGhlIHNhZmV0eSBmaWx0ZXIuXG4gICAgICovXG4gICAgSGFybUJsb2NrVGhyZXNob2xkW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKEhhcm1CbG9ja1RocmVzaG9sZCB8fCAoSGFybUJsb2NrVGhyZXNob2xkID0ge30pKTtcbi8qKiBUaGUgbW9kZSBvZiB0aGUgcHJlZGljdG9yIHRvIGJlIHVzZWQgaW4gZHluYW1pYyByZXRyaWV2YWwuICovXG52YXIgTW9kZTtcbihmdW5jdGlvbiAoTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBNb2RlW1wiTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTU9ERV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFJ1biByZXRyaWV2YWwgb25seSB3aGVuIHN5c3RlbSBkZWNpZGVzIGl0IGlzIG5lY2Vzc2FyeS5cbiAgICAgKi9cbiAgICBNb2RlW1wiTU9ERV9EWU5BTUlDXCJdID0gXCJNT0RFX0RZTkFNSUNcIjtcbn0pKE1vZGUgfHwgKE1vZGUgPSB7fSkpO1xuLyoqIFR5cGUgb2YgYXV0aCBzY2hlbWUuICovXG52YXIgQXV0aFR5cGU7XG4oZnVuY3Rpb24gKEF1dGhUeXBlKSB7XG4gICAgQXV0aFR5cGVbXCJBVVRIX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIkFVVEhfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5vIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJOT19BVVRIXCJdID0gXCJOT19BVVRIXCI7XG4gICAgLyoqXG4gICAgICogQVBJIEtleSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiQVBJX0tFWV9BVVRIXCJdID0gXCJBUElfS0VZX0FVVEhcIjtcbiAgICAvKipcbiAgICAgKiBIVFRQIEJhc2ljIEF1dGguXG4gICAgICovXG4gICAgQXV0aFR5cGVbXCJIVFRQX0JBU0lDX0FVVEhcIl0gPSBcIkhUVFBfQkFTSUNfQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIEdvb2dsZSBTZXJ2aWNlIEFjY291bnQgQXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIkdPT0dMRV9TRVJWSUNFX0FDQ09VTlRfQVVUSFwiXSA9IFwiR09PR0xFX1NFUlZJQ0VfQUNDT1VOVF9BVVRIXCI7XG4gICAgLyoqXG4gICAgICogT0F1dGggYXV0aC5cbiAgICAgKi9cbiAgICBBdXRoVHlwZVtcIk9BVVRIXCJdID0gXCJPQVVUSFwiO1xuICAgIC8qKlxuICAgICAqIE9wZW5JRCBDb25uZWN0IChPSURDKSBBdXRoLlxuICAgICAqL1xuICAgIEF1dGhUeXBlW1wiT0lEQ19BVVRIXCJdID0gXCJPSURDX0FVVEhcIjtcbn0pKEF1dGhUeXBlIHx8IChBdXRoVHlwZSA9IHt9KSk7XG4vKiogVGhlIEFQSSBzcGVjIHRoYXQgdGhlIGV4dGVybmFsIEFQSSBpbXBsZW1lbnRzLiAqL1xudmFyIEFwaVNwZWM7XG4oZnVuY3Rpb24gKEFwaVNwZWMpIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBBUEkgc3BlYy4gVGhpcyB2YWx1ZSBzaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIkFQSV9TUEVDX1VOU1BFQ0lGSUVEXCJdID0gXCJBUElfU1BFQ19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFNpbXBsZSBzZWFyY2ggQVBJIHNwZWMuXG4gICAgICovXG4gICAgQXBpU3BlY1tcIlNJTVBMRV9TRUFSQ0hcIl0gPSBcIlNJTVBMRV9TRUFSQ0hcIjtcbiAgICAvKipcbiAgICAgKiBFbGFzdGljIHNlYXJjaCBBUEkgc3BlYy5cbiAgICAgKi9cbiAgICBBcGlTcGVjW1wiRUxBU1RJQ19TRUFSQ0hcIl0gPSBcIkVMQVNUSUNfU0VBUkNIXCI7XG59KShBcGlTcGVjIHx8IChBcGlTcGVjID0ge30pKTtcbi8qKiBTdGF0dXMgb2YgdGhlIHVybCByZXRyaWV2YWwuICovXG52YXIgVXJsUmV0cmlldmFsU3RhdHVzO1xuKGZ1bmN0aW9uIChVcmxSZXRyaWV2YWxTdGF0dXMpIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZFxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU1BFQ0lGSUVEXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgc3VjY2Vzc2Z1bC5cbiAgICAgKi9cbiAgICBVcmxSZXRyaWV2YWxTdGF0dXNbXCJVUkxfUkVUUklFVkFMX1NUQVRVU19TVUNDRVNTXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19TVUNDRVNTXCI7XG4gICAgLyoqXG4gICAgICogVXJsIHJldHJpZXZhbCBpcyBmYWlsZWQgZHVlIHRvIGVycm9yLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX0VSUk9SXCJdID0gXCJVUkxfUkVUUklFVkFMX1NUQVRVU19FUlJPUlwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgYmVoaW5kIHBheXdhbGwuXG4gICAgICovXG4gICAgVXJsUmV0cmlldmFsU3RhdHVzW1wiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfUEFZV0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFVybCByZXRyaWV2YWwgaXMgZmFpbGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgaXMgdW5zYWZlLlxuICAgICAqL1xuICAgIFVybFJldHJpZXZhbFN0YXR1c1tcIlVSTF9SRVRSSUVWQUxfU1RBVFVTX1VOU0FGRVwiXSA9IFwiVVJMX1JFVFJJRVZBTF9TVEFUVVNfVU5TQUZFXCI7XG59KShVcmxSZXRyaWV2YWxTdGF0dXMgfHwgKFVybFJldHJpZXZhbFN0YXR1cyA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRoZSByZWFzb24gd2h5IHRoZSBtb2RlbCBzdG9wcGVkIGdlbmVyYXRpbmcgdG9rZW5zLlxuXG4gIElmIGVtcHR5LCB0aGUgbW9kZWwgaGFzIG5vdCBzdG9wcGVkIGdlbmVyYXRpbmcgdGhlIHRva2Vucy5cbiAgICovXG52YXIgRmluaXNoUmVhc29uO1xuKGZ1bmN0aW9uIChGaW5pc2hSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgZmluaXNoIHJlYXNvbiBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCJdID0gXCJGSU5JU0hfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIGEgbmF0dXJhbCBzdG9wcGluZyBwb2ludCBvciBhIGNvbmZpZ3VyZWQgc3RvcCBzZXF1ZW5jZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJTVE9QXCJdID0gXCJTVE9QXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiByZWFjaGVkIHRoZSBjb25maWd1cmVkIG1heGltdW0gb3V0cHV0IHRva2Vucy5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQVhfVE9LRU5TXCJdID0gXCJNQVhfVE9LRU5TXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgcG90ZW50aWFsbHkgY29udGFpbnMgc2FmZXR5IHZpb2xhdGlvbnMuIE5PVEU6IFdoZW4gc3RyZWFtaW5nLCBbY29udGVudF1bXSBpcyBlbXB0eSBpZiBjb250ZW50IGZpbHRlcnMgYmxvY2tzIHRoZSBvdXRwdXQuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU0FGRVRZXCJdID0gXCJTQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2Ugb2YgcG90ZW50aWFsIHJlY2l0YXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiUkVDSVRBVElPTlwiXSA9IFwiUkVDSVRBVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB0b2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBvZiB1c2luZyBhbiB1bnN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJMQU5HVUFHRVwiXSA9IFwiTEFOR1VBR0VcIjtcbiAgICAvKipcbiAgICAgKiBBbGwgb3RoZXIgcmVhc29ucyB0aGF0IHN0b3BwZWQgdGhlIHRva2VuIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiT1RIRVJcIl0gPSBcIk9USEVSXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGJlY2F1c2UgdGhlIGNvbnRlbnQgY29udGFpbnMgZm9yYmlkZGVuIHRlcm1zLlxuICAgICAqL1xuICAgIEZpbmlzaFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogVG9rZW4gZ2VuZXJhdGlvbiBzdG9wcGVkIGZvciBwb3RlbnRpYWxseSBjb250YWluaW5nIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJQUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIlBST0hJQklURURfQ09OVEVOVFwiO1xuICAgIC8qKlxuICAgICAqIFRva2VuIGdlbmVyYXRpb24gc3RvcHBlZCBiZWNhdXNlIHRoZSBjb250ZW50IHBvdGVudGlhbGx5IGNvbnRhaW5zIFNlbnNpdGl2ZSBQZXJzb25hbGx5IElkZW50aWZpYWJsZSBJbmZvcm1hdGlvbiAoU1BJSSkuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiU1BJSVwiXSA9IFwiU1BJSVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiXSA9IFwiTUFMRk9STUVEX0ZVTkNUSU9OX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBUb2tlbiBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSBnZW5lcmF0ZWQgaW1hZ2VzIGhhdmUgc2FmZXR5IHZpb2xhdGlvbnMuXG4gICAgICovXG4gICAgRmluaXNoUmVhc29uW1wiSU1BR0VfU0FGRVRZXCJdID0gXCJJTUFHRV9TQUZFVFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdG9vbCBjYWxsIGdlbmVyYXRlZCBieSB0aGUgbW9kZWwgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJVTkVYUEVDVEVEX1RPT0xfQ0FMTFwiXSA9IFwiVU5FWFBFQ1RFRF9UT09MX0NBTExcIjtcbiAgICAvKipcbiAgICAgKiBJbWFnZSBnZW5lcmF0aW9uIHN0b3BwZWQgYmVjYXVzZSB0aGUgZ2VuZXJhdGVkIGltYWdlcyBoYXZlIHByb2hpYml0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBGaW5pc2hSZWFzb25bXCJJTUFHRV9QUk9ISUJJVEVEX0NPTlRFTlRcIl0gPSBcIklNQUdFX1BST0hJQklURURfQ09OVEVOVFwiO1xufSkoRmluaXNoUmVhc29uIHx8IChGaW5pc2hSZWFzb24gPSB7fSkpO1xuLyoqIE91dHB1dCBvbmx5LiBIYXJtIHByb2JhYmlsaXR5IGxldmVscyBpbiB0aGUgY29udGVudC4gKi9cbnZhciBIYXJtUHJvYmFiaWxpdHk7XG4oZnVuY3Rpb24gKEhhcm1Qcm9iYWJpbGl0eSkge1xuICAgIC8qKlxuICAgICAqIEhhcm0gcHJvYmFiaWxpdHkgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiSEFSTV9QUk9CQUJJTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE5lZ2xpZ2libGUgbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJORUdMSUdJQkxFXCJdID0gXCJORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0uXG4gICAgICovXG4gICAgSGFybVByb2JhYmlsaXR5W1wiTE9XXCJdID0gXCJMT1dcIjtcbiAgICAvKipcbiAgICAgKiBNZWRpdW0gbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJNRURJVU1cIl0gPSBcIk1FRElVTVwiO1xuICAgIC8qKlxuICAgICAqIEhpZ2ggbGV2ZWwgb2YgaGFybS5cbiAgICAgKi9cbiAgICBIYXJtUHJvYmFiaWxpdHlbXCJISUdIXCJdID0gXCJISUdIXCI7XG59KShIYXJtUHJvYmFiaWxpdHkgfHwgKEhhcm1Qcm9iYWJpbGl0eSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEhhcm0gc2V2ZXJpdHkgbGV2ZWxzIGluIHRoZSBjb250ZW50LiAqL1xudmFyIEhhcm1TZXZlcml0eTtcbihmdW5jdGlvbiAoSGFybVNldmVyaXR5KSB7XG4gICAgLyoqXG4gICAgICogSGFybSBzZXZlcml0eSB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBIYXJtU2V2ZXJpdHlbXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJIQVJNX1NFVkVSSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTmVnbGlnaWJsZSBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfTkVHTElHSUJMRVwiXSA9IFwiSEFSTV9TRVZFUklUWV9ORUdMSUdJQkxFXCI7XG4gICAgLyoqXG4gICAgICogTG93IGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9MT1dcIl0gPSBcIkhBUk1fU0VWRVJJVFlfTE9XXCI7XG4gICAgLyoqXG4gICAgICogTWVkaXVtIGxldmVsIG9mIGhhcm0gc2V2ZXJpdHkuXG4gICAgICovXG4gICAgSGFybVNldmVyaXR5W1wiSEFSTV9TRVZFUklUWV9NRURJVU1cIl0gPSBcIkhBUk1fU0VWRVJJVFlfTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogSGlnaCBsZXZlbCBvZiBoYXJtIHNldmVyaXR5LlxuICAgICAqL1xuICAgIEhhcm1TZXZlcml0eVtcIkhBUk1fU0VWRVJJVFlfSElHSFwiXSA9IFwiSEFSTV9TRVZFUklUWV9ISUdIXCI7XG59KShIYXJtU2V2ZXJpdHkgfHwgKEhhcm1TZXZlcml0eSA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIEJsb2NrZWQgcmVhc29uLiAqL1xudmFyIEJsb2NrZWRSZWFzb247XG4oZnVuY3Rpb24gKEJsb2NrZWRSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBVbnNwZWNpZmllZCBibG9ja2VkIHJlYXNvbi5cbiAgICAgKi9cbiAgICBCbG9ja2VkUmVhc29uW1wiQkxPQ0tFRF9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIkJMT0NLRURfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQ2FuZGlkYXRlcyBibG9ja2VkIGR1ZSB0byBzYWZldHkuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIlNBRkVUWVwiXSA9IFwiU0FGRVRZXCI7XG4gICAgLyoqXG4gICAgICogQ2FuZGlkYXRlcyBibG9ja2VkIGR1ZSB0byBvdGhlciByZWFzb24uXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIk9USEVSXCJdID0gXCJPVEhFUlwiO1xuICAgIC8qKlxuICAgICAqIENhbmRpZGF0ZXMgYmxvY2tlZCBkdWUgdG8gdGhlIHRlcm1zIHdoaWNoIGFyZSBpbmNsdWRlZCBmcm9tIHRoZSB0ZXJtaW5vbG9neSBibG9ja2xpc3QuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIkJMT0NLTElTVFwiXSA9IFwiQkxPQ0tMSVNUXCI7XG4gICAgLyoqXG4gICAgICogQ2FuZGlkYXRlcyBibG9ja2VkIGR1ZSB0byBwcm9oaWJpdGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgQmxvY2tlZFJlYXNvbltcIlBST0hJQklURURfQ09OVEVOVFwiXSA9IFwiUFJPSElCSVRFRF9DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogQ2FuZGlkYXRlcyBibG9ja2VkIGR1ZSB0byB1bnNhZmUgaW1hZ2UgZ2VuZXJhdGlvbiBjb250ZW50LlxuICAgICAqL1xuICAgIEJsb2NrZWRSZWFzb25bXCJJTUFHRV9TQUZFVFlcIl0gPSBcIklNQUdFX1NBRkVUWVwiO1xufSkoQmxvY2tlZFJlYXNvbiB8fCAoQmxvY2tlZFJlYXNvbiA9IHt9KSk7XG4vKiogT3V0cHV0IG9ubHkuIFRyYWZmaWMgdHlwZS4gVGhpcyBzaG93cyB3aGV0aGVyIGEgcmVxdWVzdCBjb25zdW1lcyBQYXktQXMtWW91LUdvIG9yIFByb3Zpc2lvbmVkIFRocm91Z2hwdXQgcXVvdGEuICovXG52YXIgVHJhZmZpY1R5cGU7XG4oZnVuY3Rpb24gKFRyYWZmaWNUeXBlKSB7XG4gICAgLyoqXG4gICAgICogVW5zcGVjaWZpZWQgcmVxdWVzdCB0cmFmZmljIHR5cGUuXG4gICAgICovXG4gICAgVHJhZmZpY1R5cGVbXCJUUkFGRklDX1RZUEVfVU5TUEVDSUZJRURcIl0gPSBcIlRSQUZGSUNfVFlQRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFR5cGUgZm9yIFBheS1Bcy1Zb3UtR28gdHJhZmZpYy5cbiAgICAgKi9cbiAgICBUcmFmZmljVHlwZVtcIk9OX0RFTUFORFwiXSA9IFwiT05fREVNQU5EXCI7XG4gICAgLyoqXG4gICAgICogVHlwZSBmb3IgUHJvdmlzaW9uZWQgVGhyb3VnaHB1dCB0cmFmZmljLlxuICAgICAqL1xuICAgIFRyYWZmaWNUeXBlW1wiUFJPVklTSU9ORURfVEhST1VHSFBVVFwiXSA9IFwiUFJPVklTSU9ORURfVEhST1VHSFBVVFwiO1xufSkoVHJhZmZpY1R5cGUgfHwgKFRyYWZmaWNUeXBlID0ge30pKTtcbi8qKiBTZXJ2ZXIgY29udGVudCBtb2RhbGl0aWVzLiAqL1xudmFyIE1vZGFsaXR5O1xuKGZ1bmN0aW9uIChNb2RhbGl0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RhbGl0eSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIk1PREFMSVRZX1VOU1BFQ0lGSUVEXCJdID0gXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiB0ZXh0XG4gICAgICovXG4gICAgTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoZSBtb2RlbCBzaG91bGQgcmV0dXJuIGltYWdlcy5cbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIklNQUdFXCJdID0gXCJJTUFHRVwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGUgbW9kZWwgc2hvdWxkIHJldHVybiBhdWRpby5cbiAgICAgKi9cbiAgICBNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xufSkoTW9kYWxpdHkgfHwgKE1vZGFsaXR5ID0ge30pKTtcbi8qKiBUaGUgbWVkaWEgcmVzb2x1dGlvbiB0byB1c2UuICovXG52YXIgTWVkaWFSZXNvbHV0aW9uO1xuKGZ1bmN0aW9uIChNZWRpYVJlc29sdXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBNZWRpYSByZXNvbHV0aW9uIGhhcyBub3QgYmVlbiBzZXRcbiAgICAgKi9cbiAgICBNZWRpYVJlc29sdXRpb25bXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gbG93ICg2NCB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fTE9XXCJdID0gXCJNRURJQV9SRVNPTFVUSU9OX0xPV1wiO1xuICAgIC8qKlxuICAgICAqIE1lZGlhIHJlc29sdXRpb24gc2V0IHRvIG1lZGl1bSAoMjU2IHRva2VucykuXG4gICAgICovXG4gICAgTWVkaWFSZXNvbHV0aW9uW1wiTUVESUFfUkVTT0xVVElPTl9NRURJVU1cIl0gPSBcIk1FRElBX1JFU09MVVRJT05fTUVESVVNXCI7XG4gICAgLyoqXG4gICAgICogTWVkaWEgcmVzb2x1dGlvbiBzZXQgdG8gaGlnaCAoem9vbWVkIHJlZnJhbWluZyB3aXRoIDI1NiB0b2tlbnMpLlxuICAgICAqL1xuICAgIE1lZGlhUmVzb2x1dGlvbltcIk1FRElBX1JFU09MVVRJT05fSElHSFwiXSA9IFwiTUVESUFfUkVTT0xVVElPTl9ISUdIXCI7XG59KShNZWRpYVJlc29sdXRpb24gfHwgKE1lZGlhUmVzb2x1dGlvbiA9IHt9KSk7XG4vKiogSm9iIHN0YXRlLiAqL1xudmFyIEpvYlN0YXRlO1xuKGZ1bmN0aW9uIChKb2JTdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2Igc3RhdGUgaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfVU5TUEVDSUZJRURcIl0gPSBcIkpPQl9TVEFURV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4ganVzdCBjcmVhdGVkIG9yIHJlc3VtZWQgYW5kIHByb2Nlc3NpbmcgaGFzIG5vdCB5ZXQgYmVndW4uXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfUVVFVUVEXCJdID0gXCJKT0JfU1RBVEVfUVVFVUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZpY2UgaXMgcHJlcGFyaW5nIHRvIHJ1biB0aGUgam9iLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BFTkRJTkdcIl0gPSBcIkpPQl9TVEFURV9QRU5ESU5HXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGpvYiBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9SVU5OSU5HXCJdID0gXCJKT0JfU1RBVEVfUlVOTklOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgY29tcGxldGVkIHN1Y2Nlc3NmdWxseS5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9TVUNDRUVERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGZhaWxlZC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9GQUlMRURcIl0gPSBcIkpPQl9TVEFURV9GQUlMRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIGNhbmNlbGxlZC4gRnJvbSB0aGlzIHN0YXRlIHRoZSBqb2IgbWF5IG9ubHkgZ28gdG8gZWl0aGVyIGBKT0JfU1RBVEVfU1VDQ0VFREVEYCwgYEpPQl9TVEFURV9GQUlMRURgIG9yIGBKT0JfU1RBVEVfQ0FOQ0VMTEVEYC5cbiAgICAgKi9cbiAgICBKb2JTdGF0ZVtcIkpPQl9TVEFURV9DQU5DRUxMSU5HXCJdID0gXCJKT0JfU1RBVEVfQ0FOQ0VMTElOR1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gY2FuY2VsbGVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX0NBTkNFTExFRFwiXSA9IFwiSk9CX1NUQVRFX0NBTkNFTExFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGJlZW4gc3RvcHBlZCwgYW5kIGNhbiBiZSByZXN1bWVkLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBVVNFRFwiXSA9IFwiSk9CX1NUQVRFX1BBVVNFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBqb2IgaGFzIGV4cGlyZWQuXG4gICAgICovXG4gICAgSm9iU3RhdGVbXCJKT0JfU1RBVEVfRVhQSVJFRFwiXSA9IFwiSk9CX1NUQVRFX0VYUElSRURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIGJlaW5nIHVwZGF0ZWQuIE9ubHkgam9icyBpbiB0aGUgYEpPQl9TVEFURV9SVU5OSU5HYCBzdGF0ZSBjYW4gYmUgdXBkYXRlZC4gQWZ0ZXIgdXBkYXRpbmcsIHRoZSBqb2IgZ29lcyBiYWNrIHRvIHRoZSBgSk9CX1NUQVRFX1JVTk5JTkdgIHN0YXRlLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1VQREFUSU5HXCJdID0gXCJKT0JfU1RBVEVfVVBEQVRJTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgam9iIGlzIHBhcnRpYWxseSBzdWNjZWVkZWQsIHNvbWUgcmVzdWx0cyBtYXkgYmUgbWlzc2luZyBkdWUgdG8gZXJyb3JzLlxuICAgICAqL1xuICAgIEpvYlN0YXRlW1wiSk9CX1NUQVRFX1BBUlRJQUxMWV9TVUNDRUVERURcIl0gPSBcIkpPQl9TVEFURV9QQVJUSUFMTFlfU1VDQ0VFREVEXCI7XG59KShKb2JTdGF0ZSB8fCAoSm9iU3RhdGUgPSB7fSkpO1xuLyoqIFR1bmluZyBtb2RlLiAqL1xudmFyIFR1bmluZ01vZGU7XG4oZnVuY3Rpb24gKFR1bmluZ01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUdW5pbmcgbW9kZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBUdW5pbmdNb2RlW1wiVFVOSU5HX01PREVfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogRnVsbCBmaW5lLXR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9GVUxMXCJdID0gXCJUVU5JTkdfTU9ERV9GVUxMXCI7XG4gICAgLyoqXG4gICAgICogUEVGVCBhZGFwdGVyIHR1bmluZyBtb2RlLlxuICAgICAqL1xuICAgIFR1bmluZ01vZGVbXCJUVU5JTkdfTU9ERV9QRUZUX0FEQVBURVJcIl0gPSBcIlRVTklOR19NT0RFX1BFRlRfQURBUFRFUlwiO1xufSkoVHVuaW5nTW9kZSB8fCAoVHVuaW5nTW9kZSA9IHt9KSk7XG4vKiogT3B0aW9uYWwuIEFkYXB0ZXIgc2l6ZSBmb3IgdHVuaW5nLiAqL1xudmFyIEFkYXB0ZXJTaXplO1xuKGZ1bmN0aW9uIChBZGFwdGVyU2l6ZSkge1xuICAgIC8qKlxuICAgICAqIEFkYXB0ZXIgc2l6ZSBpcyB1bnNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9VTlNQRUNJRklFRFwiXSA9IFwiQURBUFRFUl9TSVpFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDEuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfT05FXCJdID0gXCJBREFQVEVSX1NJWkVfT05FXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDIuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfVFdPXCJdID0gXCJBREFQVEVSX1NJWkVfVFdPXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDQuXG4gICAgICovXG4gICAgQWRhcHRlclNpemVbXCJBREFQVEVSX1NJWkVfRk9VUlwiXSA9IFwiQURBUFRFUl9TSVpFX0ZPVVJcIjtcbiAgICAvKipcbiAgICAgKiBBZGFwdGVyIHNpemUgOC5cbiAgICAgKi9cbiAgICBBZGFwdGVyU2l6ZVtcIkFEQVBURVJfU0laRV9FSUdIVFwiXSA9IFwiQURBUFRFUl9TSVpFX0VJR0hUXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDE2LlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1NJWFRFRU5cIl0gPSBcIkFEQVBURVJfU0laRV9TSVhURUVOXCI7XG4gICAgLyoqXG4gICAgICogQWRhcHRlciBzaXplIDMyLlxuICAgICAqL1xuICAgIEFkYXB0ZXJTaXplW1wiQURBUFRFUl9TSVpFX1RISVJUWV9UV09cIl0gPSBcIkFEQVBURVJfU0laRV9USElSVFlfVFdPXCI7XG59KShBZGFwdGVyU2l6ZSB8fCAoQWRhcHRlclNpemUgPSB7fSkpO1xuLyoqIE9wdGlvbmFsLiBUaGUgdHVuaW5nIHRhc2suIEVpdGhlciBJMlYgb3IgVDJWLiAqL1xudmFyIFR1bmluZ1Rhc2s7XG4oZnVuY3Rpb24gKFR1bmluZ1Rhc2spIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBUdW5pbmdUYXNrW1wiVFVOSU5HX1RBU0tfVU5TUEVDSUZJRURcIl0gPSBcIlRVTklOR19UQVNLX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVHVuaW5nIHRhc2sgZm9yIGltYWdlIHRvIHZpZGVvLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19JMlZcIl0gPSBcIlRVTklOR19UQVNLX0kyVlwiO1xuICAgIC8qKlxuICAgICAqIFR1bmluZyB0YXNrIGZvciB0ZXh0IHRvIHZpZGVvLlxuICAgICAqL1xuICAgIFR1bmluZ1Rhc2tbXCJUVU5JTkdfVEFTS19UMlZcIl0gPSBcIlRVTklOR19UQVNLX1QyVlwiO1xufSkoVHVuaW5nVGFzayB8fCAoVHVuaW5nVGFzayA9IHt9KSk7XG4vKiogT3B0aW9ucyBmb3IgZmVhdHVyZSBzZWxlY3Rpb24gcHJlZmVyZW5jZS4gKi9cbnZhciBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZTtcbihmdW5jdGlvbiAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpIHtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIl0gPSBcIkZFQVRVUkVfU0VMRUNUSU9OX1BSRUZFUkVOQ0VfVU5TUEVDSUZJRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfUVVBTElUWVwiXSA9IFwiUFJJT1JJVElaRV9RVUFMSVRZXCI7XG4gICAgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2VbXCJCQUxBTkNFRFwiXSA9IFwiQkFMQU5DRURcIjtcbiAgICBGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZVtcIlBSSU9SSVRJWkVfQ09TVFwiXSA9IFwiUFJJT1JJVElaRV9DT1NUXCI7XG59KShGZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSB8fCAoRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgPSB7fSkpO1xuLyoqIERlZmluZXMgdGhlIGZ1bmN0aW9uIGJlaGF2aW9yLiBEZWZhdWx0cyB0byBgQkxPQ0tJTkdgLiAqL1xudmFyIEJlaGF2aW9yO1xuKGZ1bmN0aW9uIChCZWhhdmlvcikge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiVU5TUEVDSUZJRURcIl0gPSBcIlVOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgc3lzdGVtIHdpbGwgd2FpdCB0byByZWNlaXZlIHRoZSBmdW5jdGlvbiByZXNwb25zZSBiZWZvcmUgY29udGludWluZyB0aGUgY29udmVyc2F0aW9uLlxuICAgICAqL1xuICAgIEJlaGF2aW9yW1wiQkxPQ0tJTkdcIl0gPSBcIkJMT0NLSU5HXCI7XG4gICAgLyoqXG4gICAgICogSWYgc2V0LCB0aGUgc3lzdGVtIHdpbGwgbm90IHdhaXQgdG8gcmVjZWl2ZSB0aGUgZnVuY3Rpb24gcmVzcG9uc2UuIEluc3RlYWQsIGl0IHdpbGwgYXR0ZW1wdCB0byBoYW5kbGUgZnVuY3Rpb24gcmVzcG9uc2VzIGFzIHRoZXkgYmVjb21lIGF2YWlsYWJsZSB3aGlsZSBtYWludGFpbmluZyB0aGUgY29udmVyc2F0aW9uIGJldHdlZW4gdGhlIHVzZXIgYW5kIHRoZSBtb2RlbC5cbiAgICAgKi9cbiAgICBCZWhhdmlvcltcIk5PTl9CTE9DS0lOR1wiXSA9IFwiTk9OX0JMT0NLSU5HXCI7XG59KShCZWhhdmlvciB8fCAoQmVoYXZpb3IgPSB7fSkpO1xuLyoqIENvbmZpZyBmb3IgdGhlIGR5bmFtaWMgcmV0cmlldmFsIGNvbmZpZyBtb2RlLiAqL1xudmFyIER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlO1xuKGZ1bmN0aW9uIChEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIEFsd2F5cyB0cmlnZ2VyIHJldHJpZXZhbC5cbiAgICAgKi9cbiAgICBEeW5hbWljUmV0cmlldmFsQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBSdW4gcmV0cmlldmFsIG9ubHkgd2hlbiBzeXN0ZW0gZGVjaWRlcyBpdCBpcyBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGVbXCJNT0RFX0RZTkFNSUNcIl0gPSBcIk1PREVfRFlOQU1JQ1wiO1xufSkoRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUgfHwgKER5bmFtaWNSZXRyaWV2YWxDb25maWdNb2RlID0ge30pKTtcbi8qKiBUaGUgZW52aXJvbm1lbnQgYmVpbmcgb3BlcmF0ZWQuICovXG52YXIgRW52aXJvbm1lbnQ7XG4oZnVuY3Rpb24gKEVudmlyb25tZW50KSB7XG4gICAgLyoqXG4gICAgICogRGVmYXVsdHMgdG8gYnJvd3Nlci5cbiAgICAgKi9cbiAgICBFbnZpcm9ubWVudFtcIkVOVklST05NRU5UX1VOU1BFQ0lGSUVEXCJdID0gXCJFTlZJUk9OTUVOVF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIE9wZXJhdGVzIGluIGEgd2ViIGJyb3dzZXIuXG4gICAgICovXG4gICAgRW52aXJvbm1lbnRbXCJFTlZJUk9OTUVOVF9CUk9XU0VSXCJdID0gXCJFTlZJUk9OTUVOVF9CUk9XU0VSXCI7XG59KShFbnZpcm9ubWVudCB8fCAoRW52aXJvbm1lbnQgPSB7fSkpO1xuLyoqIENvbmZpZyBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxpbmcgY29uZmlnIG1vZGUuICovXG52YXIgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZTtcbihmdW5jdGlvbiAoRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiBjYWxsaW5nIGNvbmZpZyBtb2RlIGlzIHVuc3BlY2lmaWVkLiBTaG91bGQgbm90IGJlIHVzZWQuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIk1PREVfVU5TUEVDSUZJRURcIl0gPSBcIk1PREVfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IG1vZGVsIGJlaGF2aW9yLCBtb2RlbCBkZWNpZGVzIHRvIHByZWRpY3QgZWl0aGVyIGZ1bmN0aW9uIGNhbGxzIG9yIG5hdHVyYWwgbGFuZ3VhZ2UgcmVzcG9uc2UuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIkFVVE9cIl0gPSBcIkFVVE9cIjtcbiAgICAvKipcbiAgICAgKiBNb2RlbCBpcyBjb25zdHJhaW5lZCB0byBhbHdheXMgcHJlZGljdGluZyBmdW5jdGlvbiBjYWxscyBvbmx5LiBJZiBcImFsbG93ZWRfZnVuY3Rpb25fbmFtZXNcIiBhcmUgc2V0LCB0aGUgcHJlZGljdGVkIGZ1bmN0aW9uIGNhbGxzIHdpbGwgYmUgbGltaXRlZCB0byBhbnkgb25lIG9mIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiLCBlbHNlIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbHMgd2lsbCBiZSBhbnkgb25lIG9mIHRoZSBwcm92aWRlZCBcImZ1bmN0aW9uX2RlY2xhcmF0aW9uc1wiLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGVbXCJBTllcIl0gPSBcIkFOWVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIHdpbGwgbm90IHByZWRpY3QgYW55IGZ1bmN0aW9uIGNhbGxzLiBNb2RlbCBiZWhhdmlvciBpcyBzYW1lIGFzIHdoZW4gbm90IHBhc3NpbmcgYW55IGZ1bmN0aW9uIGRlY2xhcmF0aW9ucy5cbiAgICAgKi9cbiAgICBGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlW1wiTk9ORVwiXSA9IFwiTk9ORVwiO1xuICAgIC8qKlxuICAgICAqIE1vZGVsIGRlY2lkZXMgdG8gcHJlZGljdCBlaXRoZXIgYSBmdW5jdGlvbiBjYWxsIG9yIGEgbmF0dXJhbCBsYW5ndWFnZSByZXNwb25zZSwgYnV0IHdpbGwgdmFsaWRhdGUgZnVuY3Rpb24gY2FsbHMgd2l0aCBjb25zdHJhaW5lZCBkZWNvZGluZy4gSWYgXCJhbGxvd2VkX2Z1bmN0aW9uX25hbWVzXCIgYXJlIHNldCwgdGhlIHByZWRpY3RlZCBmdW5jdGlvbiBjYWxsIHdpbGwgYmUgbGltaXRlZCB0byBhbnkgb25lIG9mIFwiYWxsb3dlZF9mdW5jdGlvbl9uYW1lc1wiLCBlbHNlIHRoZSBwcmVkaWN0ZWQgZnVuY3Rpb24gY2FsbCB3aWxsIGJlIGFueSBvbmUgb2YgdGhlIHByb3ZpZGVkIFwiZnVuY3Rpb25fZGVjbGFyYXRpb25zXCIuXG4gICAgICovXG4gICAgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZVtcIlZBTElEQVRFRFwiXSA9IFwiVkFMSURBVEVEXCI7XG59KShGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlIHx8IChGdW5jdGlvbkNhbGxpbmdDb25maWdNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIHNhZmV0eSBmaWx0ZXIgbGV2ZWwgZm9yIG9iamVjdGlvbmFibGUgY29udGVudC4gKi9cbnZhciBTYWZldHlGaWx0ZXJMZXZlbDtcbihmdW5jdGlvbiAoU2FmZXR5RmlsdGVyTGV2ZWwpIHtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX0xPV19BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX0xPV19BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIl0gPSBcIkJMT0NLX01FRElVTV9BTkRfQUJPVkVcIjtcbiAgICBTYWZldHlGaWx0ZXJMZXZlbFtcIkJMT0NLX09OTFlfSElHSFwiXSA9IFwiQkxPQ0tfT05MWV9ISUdIXCI7XG4gICAgU2FmZXR5RmlsdGVyTGV2ZWxbXCJCTE9DS19OT05FXCJdID0gXCJCTE9DS19OT05FXCI7XG59KShTYWZldHlGaWx0ZXJMZXZlbCB8fCAoU2FmZXR5RmlsdGVyTGV2ZWwgPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBjb250cm9scyB0aGUgZ2VuZXJhdGlvbiBvZiBwZW9wbGUuICovXG52YXIgUGVyc29uR2VuZXJhdGlvbjtcbihmdW5jdGlvbiAoUGVyc29uR2VuZXJhdGlvbikge1xuICAgIC8qKlxuICAgICAqIEJsb2NrIGdlbmVyYXRpb24gb2YgaW1hZ2VzIG9mIHBlb3BsZS5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiRE9OVF9BTExPV1wiXSA9IFwiRE9OVF9BTExPV1wiO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyBvZiBhZHVsdHMsIGJ1dCBub3QgY2hpbGRyZW4uXG4gICAgICovXG4gICAgUGVyc29uR2VuZXJhdGlvbltcIkFMTE9XX0FEVUxUXCJdID0gXCJBTExPV19BRFVMVFwiO1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGltYWdlcyB0aGF0IGluY2x1ZGUgYWR1bHRzIGFuZCBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBQZXJzb25HZW5lcmF0aW9uW1wiQUxMT1dfQUxMXCJdID0gXCJBTExPV19BTExcIjtcbn0pKFBlcnNvbkdlbmVyYXRpb24gfHwgKFBlcnNvbkdlbmVyYXRpb24gPSB7fSkpO1xuLyoqIEVudW0gdGhhdCBzcGVjaWZpZXMgdGhlIGxhbmd1YWdlIG9mIHRoZSB0ZXh0IGluIHRoZSBwcm9tcHQuICovXG52YXIgSW1hZ2VQcm9tcHRMYW5ndWFnZTtcbihmdW5jdGlvbiAoSW1hZ2VQcm9tcHRMYW5ndWFnZSkge1xuICAgIC8qKlxuICAgICAqIEF1dG8tZGV0ZWN0IHRoZSBsYW5ndWFnZS5cbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiYXV0b1wiXSA9IFwiYXV0b1wiO1xuICAgIC8qKlxuICAgICAqIEVuZ2xpc2hcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiZW5cIl0gPSBcImVuXCI7XG4gICAgLyoqXG4gICAgICogSmFwYW5lc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiamFcIl0gPSBcImphXCI7XG4gICAgLyoqXG4gICAgICogS29yZWFuXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImtvXCJdID0gXCJrb1wiO1xuICAgIC8qKlxuICAgICAqIEhpbmRpXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImhpXCJdID0gXCJoaVwiO1xuICAgIC8qKlxuICAgICAqIENoaW5lc2VcbiAgICAgKi9cbiAgICBJbWFnZVByb21wdExhbmd1YWdlW1wiemhcIl0gPSBcInpoXCI7XG4gICAgLyoqXG4gICAgICogUG9ydHVndWVzZVxuICAgICAqL1xuICAgIEltYWdlUHJvbXB0TGFuZ3VhZ2VbXCJwdFwiXSA9IFwicHRcIjtcbiAgICAvKipcbiAgICAgKiBTcGFuaXNoXG4gICAgICovXG4gICAgSW1hZ2VQcm9tcHRMYW5ndWFnZVtcImVzXCJdID0gXCJlc1wiO1xufSkoSW1hZ2VQcm9tcHRMYW5ndWFnZSB8fCAoSW1hZ2VQcm9tcHRMYW5ndWFnZSA9IHt9KSk7XG4vKiogRW51bSByZXByZXNlbnRpbmcgdGhlIG1hc2sgbW9kZSBvZiBhIG1hc2sgcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIE1hc2tSZWZlcmVuY2VNb2RlO1xuKGZ1bmN0aW9uIChNYXNrUmVmZXJlbmNlTW9kZSkge1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0RFRkFVTFRcIl0gPSBcIk1BU0tfTU9ERV9ERUZBVUxUXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfVVNFUl9QUk9WSURFRFwiXSA9IFwiTUFTS19NT0RFX1VTRVJfUFJPVklERURcIjtcbiAgICBNYXNrUmVmZXJlbmNlTW9kZVtcIk1BU0tfTU9ERV9CQUNLR1JPVU5EXCJdID0gXCJNQVNLX01PREVfQkFDS0dST1VORFwiO1xuICAgIE1hc2tSZWZlcmVuY2VNb2RlW1wiTUFTS19NT0RFX0ZPUkVHUk9VTkRcIl0gPSBcIk1BU0tfTU9ERV9GT1JFR1JPVU5EXCI7XG4gICAgTWFza1JlZmVyZW5jZU1vZGVbXCJNQVNLX01PREVfU0VNQU5USUNcIl0gPSBcIk1BU0tfTU9ERV9TRU1BTlRJQ1wiO1xufSkoTWFza1JlZmVyZW5jZU1vZGUgfHwgKE1hc2tSZWZlcmVuY2VNb2RlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgY29udHJvbCB0eXBlIG9mIGEgY29udHJvbCByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgQ29udHJvbFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKENvbnRyb2xSZWZlcmVuY2VUeXBlKSB7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfREVGQVVMVFwiXSA9IFwiQ09OVFJPTF9UWVBFX0RFRkFVTFRcIjtcbiAgICBDb250cm9sUmVmZXJlbmNlVHlwZVtcIkNPTlRST0xfVFlQRV9DQU5OWVwiXSA9IFwiQ09OVFJPTF9UWVBFX0NBTk5ZXCI7XG4gICAgQ29udHJvbFJlZmVyZW5jZVR5cGVbXCJDT05UUk9MX1RZUEVfU0NSSUJCTEVcIl0gPSBcIkNPTlRST0xfVFlQRV9TQ1JJQkJMRVwiO1xuICAgIENvbnRyb2xSZWZlcmVuY2VUeXBlW1wiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiXSA9IFwiQ09OVFJPTF9UWVBFX0ZBQ0VfTUVTSFwiO1xufSkoQ29udHJvbFJlZmVyZW5jZVR5cGUgfHwgKENvbnRyb2xSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgc3ViamVjdCB0eXBlIG9mIGEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuICovXG52YXIgU3ViamVjdFJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFN1YmplY3RSZWZlcmVuY2VUeXBlKSB7XG4gICAgU3ViamVjdFJlZmVyZW5jZVR5cGVbXCJTVUJKRUNUX1RZUEVfREVGQVVMVFwiXSA9IFwiU1VCSkVDVF9UWVBFX0RFRkFVTFRcIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9QRVJTT05cIl0gPSBcIlNVQkpFQ1RfVFlQRV9QRVJTT05cIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9BTklNQUxcIl0gPSBcIlNVQkpFQ1RfVFlQRV9BTklNQUxcIjtcbiAgICBTdWJqZWN0UmVmZXJlbmNlVHlwZVtcIlNVQkpFQ1RfVFlQRV9QUk9EVUNUXCJdID0gXCJTVUJKRUNUX1RZUEVfUFJPRFVDVFwiO1xufSkoU3ViamVjdFJlZmVyZW5jZVR5cGUgfHwgKFN1YmplY3RSZWZlcmVuY2VUeXBlID0ge30pKTtcbi8qKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZWRpdGluZyBtb2RlLiAqL1xudmFyIEVkaXRNb2RlO1xuKGZ1bmN0aW9uIChFZGl0TW9kZSkge1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX0RFRkFVTFRcIl0gPSBcIkVESVRfTU9ERV9ERUZBVUxUXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfSU5QQUlOVF9SRU1PVkFMXCJdID0gXCJFRElUX01PREVfSU5QQUlOVF9SRU1PVkFMXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfSU5QQUlOVF9JTlNFUlRJT05cIl0gPSBcIkVESVRfTU9ERV9JTlBBSU5UX0lOU0VSVElPTlwiO1xuICAgIEVkaXRNb2RlW1wiRURJVF9NT0RFX09VVFBBSU5UXCJdID0gXCJFRElUX01PREVfT1VUUEFJTlRcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9DT05UUk9MTEVEX0VESVRJTkdcIl0gPSBcIkVESVRfTU9ERV9DT05UUk9MTEVEX0VESVRJTkdcIjtcbiAgICBFZGl0TW9kZVtcIkVESVRfTU9ERV9TVFlMRVwiXSA9IFwiRURJVF9NT0RFX1NUWUxFXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfQkdTV0FQXCJdID0gXCJFRElUX01PREVfQkdTV0FQXCI7XG4gICAgRWRpdE1vZGVbXCJFRElUX01PREVfUFJPRFVDVF9JTUFHRVwiXSA9IFwiRURJVF9NT0RFX1BST0RVQ1RfSU1BR0VcIjtcbn0pKEVkaXRNb2RlIHx8IChFZGl0TW9kZSA9IHt9KSk7XG4vKiogRW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHNlZ21lbnRhdGlvbiBtb2RlLiAqL1xudmFyIFNlZ21lbnRNb2RlO1xuKGZ1bmN0aW9uIChTZWdtZW50TW9kZSkge1xuICAgIFNlZ21lbnRNb2RlW1wiRk9SRUdST1VORFwiXSA9IFwiRk9SRUdST1VORFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiQkFDS0dST1VORFwiXSA9IFwiQkFDS0dST1VORFwiO1xuICAgIFNlZ21lbnRNb2RlW1wiUFJPTVBUXCJdID0gXCJQUk9NUFRcIjtcbiAgICBTZWdtZW50TW9kZVtcIlNFTUFOVElDXCJdID0gXCJTRU1BTlRJQ1wiO1xuICAgIFNlZ21lbnRNb2RlW1wiSU5URVJBQ1RJVkVcIl0gPSBcIklOVEVSQUNUSVZFXCI7XG59KShTZWdtZW50TW9kZSB8fCAoU2VnbWVudE1vZGUgPSB7fSkpO1xuLyoqIEVudW0gZm9yIHRoZSByZWZlcmVuY2UgdHlwZSBvZiBhIHZpZGVvIGdlbmVyYXRpb24gcmVmZXJlbmNlIGltYWdlLiAqL1xudmFyIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGU7XG4oZnVuY3Rpb24gKFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGUpIHtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSBpbWFnZSB0aGF0IHByb3ZpZGVzIGFzc2V0cyB0byB0aGUgZ2VuZXJhdGVkIHZpZGVvLFxuICAgICAgICBzdWNoIGFzIHRoZSBzY2VuZSwgYW4gb2JqZWN0LCBhIGNoYXJhY3RlciwgZXRjLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZVR5cGVbXCJBU1NFVFwiXSA9IFwiQVNTRVRcIjtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSBpbWFnZSB0aGF0IHByb3ZpZGVzIGFlc3RoZXRpY3MgaW5jbHVkaW5nIGNvbG9ycyxcbiAgICAgICAgbGlnaHRpbmcsIHRleHR1cmUsIGV0Yy4sIHRvIGJlIHVzZWQgYXMgdGhlIHN0eWxlIG9mIHRoZSBnZW5lcmF0ZWQgdmlkZW8sXG4gICAgICAgIHN1Y2ggYXMgJ2FuaW1lJywgJ3Bob3RvZ3JhcGh5JywgJ29yaWdhbWknLCBldGMuXG4gICAgICovXG4gICAgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZVtcIlNUWUxFXCJdID0gXCJTVFlMRVwiO1xufSkoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSB8fCAoVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSA9IHt9KSk7XG4vKiogRW51bSBmb3IgdGhlIG1hc2sgbW9kZSBvZiBhIHZpZGVvIGdlbmVyYXRpb24gbWFzay4gKi9cbnZhciBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZTtcbihmdW5jdGlvbiAoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBjb250YWlucyBhIG1hc2tlZCByZWN0YW5ndWxhciByZWdpb24gd2hpY2ggaXNcbiAgICAgICAgYXBwbGllZCBvbiB0aGUgZmlyc3QgZnJhbWUgb2YgdGhlIGlucHV0IHZpZGVvLiBUaGUgb2JqZWN0IGRlc2NyaWJlZCBpblxuICAgICAgICB0aGUgcHJvbXB0IGlzIGluc2VydGVkIGludG8gdGhpcyByZWdpb24gYW5kIHdpbGwgYXBwZWFyIGluIHN1YnNlcXVlbnRcbiAgICAgICAgZnJhbWVzLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiSU5TRVJUXCJdID0gXCJJTlNFUlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBpcyB1c2VkIHRvIGRldGVybWluZSBhbiBvYmplY3QgaW4gdGhlXG4gICAgICAgIGZpcnN0IHZpZGVvIGZyYW1lIHRvIHRyYWNrLiBUaGlzIG9iamVjdCBpcyByZW1vdmVkIGZyb20gdGhlIHZpZGVvLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiUkVNT1ZFXCJdID0gXCJSRU1PVkVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgaW1hZ2UgbWFzayBpcyB1c2VkIHRvIGRldGVybWluZSBhIHJlZ2lvbiBpbiB0aGVcbiAgICAgICAgdmlkZW8uIE9iamVjdHMgaW4gdGhpcyByZWdpb24gd2lsbCBiZSByZW1vdmVkLlxuICAgICAqL1xuICAgIFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlW1wiUkVNT1ZFX1NUQVRJQ1wiXSA9IFwiUkVNT1ZFX1NUQVRJQ1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbWFnZSBtYXNrIGNvbnRhaW5zIGEgbWFza2VkIHJlY3Rhbmd1bGFyIHJlZ2lvbiB3aGVyZVxuICAgICAgICB0aGUgaW5wdXQgdmlkZW8gd2lsbCBnby4gVGhlIHJlbWFpbmluZyBhcmVhIHdpbGwgYmUgZ2VuZXJhdGVkLiBWaWRlb1xuICAgICAgICBtYXNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZVtcIk9VVFBBSU5UXCJdID0gXCJPVVRQQUlOVFwiO1xufSkoVmlkZW9HZW5lcmF0aW9uTWFza01vZGUgfHwgKFZpZGVvR2VuZXJhdGlvbk1hc2tNb2RlID0ge30pKTtcbi8qKiBFbnVtIHRoYXQgY29udHJvbHMgdGhlIGNvbXByZXNzaW9uIHF1YWxpdHkgb2YgdGhlIGdlbmVyYXRlZCB2aWRlb3MuICovXG52YXIgVmlkZW9Db21wcmVzc2lvblF1YWxpdHk7XG4oZnVuY3Rpb24gKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogT3B0aW1pemVkIHZpZGVvIGNvbXByZXNzaW9uIHF1YWxpdHkuIFRoaXMgd2lsbCBwcm9kdWNlIHZpZGVvc1xuICAgICAgICB3aXRoIGEgY29tcHJlc3NlZCwgc21hbGxlciBmaWxlIHNpemUuXG4gICAgICovXG4gICAgVmlkZW9Db21wcmVzc2lvblF1YWxpdHlbXCJPUFRJTUlaRURcIl0gPSBcIk9QVElNSVpFRFwiO1xuICAgIC8qKlxuICAgICAqIExvc3NsZXNzIHZpZGVvIGNvbXByZXNzaW9uIHF1YWxpdHkuIFRoaXMgd2lsbCBwcm9kdWNlIHZpZGVvc1xuICAgICAgICB3aXRoIGEgbGFyZ2VyIGZpbGUgc2l6ZS5cbiAgICAgKi9cbiAgICBWaWRlb0NvbXByZXNzaW9uUXVhbGl0eVtcIkxPU1NMRVNTXCJdID0gXCJMT1NTTEVTU1wiO1xufSkoVmlkZW9Db21wcmVzc2lvblF1YWxpdHkgfHwgKFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5ID0ge30pKTtcbi8qKiBTdGF0ZSBmb3IgdGhlIGxpZmVjeWNsZSBvZiBhIEZpbGUuICovXG52YXIgRmlsZVN0YXRlO1xuKGZ1bmN0aW9uIChGaWxlU3RhdGUpIHtcbiAgICBGaWxlU3RhdGVbXCJTVEFURV9VTlNQRUNJRklFRFwiXSA9IFwiU1RBVEVfVU5TUEVDSUZJRURcIjtcbiAgICBGaWxlU3RhdGVbXCJQUk9DRVNTSU5HXCJdID0gXCJQUk9DRVNTSU5HXCI7XG4gICAgRmlsZVN0YXRlW1wiQUNUSVZFXCJdID0gXCJBQ1RJVkVcIjtcbiAgICBGaWxlU3RhdGVbXCJGQUlMRURcIl0gPSBcIkZBSUxFRFwiO1xufSkoRmlsZVN0YXRlIHx8IChGaWxlU3RhdGUgPSB7fSkpO1xuLyoqIFNvdXJjZSBvZiB0aGUgRmlsZS4gKi9cbnZhciBGaWxlU291cmNlO1xuKGZ1bmN0aW9uIChGaWxlU291cmNlKSB7XG4gICAgRmlsZVNvdXJjZVtcIlNPVVJDRV9VTlNQRUNJRklFRFwiXSA9IFwiU09VUkNFX1VOU1BFQ0lGSUVEXCI7XG4gICAgRmlsZVNvdXJjZVtcIlVQTE9BREVEXCJdID0gXCJVUExPQURFRFwiO1xuICAgIEZpbGVTb3VyY2VbXCJHRU5FUkFURURcIl0gPSBcIkdFTkVSQVRFRFwiO1xufSkoRmlsZVNvdXJjZSB8fCAoRmlsZVNvdXJjZSA9IHt9KSk7XG4vKiogVGhlIHJlYXNvbiB3aHkgdGhlIHR1cm4gaXMgY29tcGxldGUuICovXG52YXIgVHVybkNvbXBsZXRlUmVhc29uO1xuKGZ1bmN0aW9uIChUdXJuQ29tcGxldGVSZWFzb24pIHtcbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHZhbHVlLiBSZWFzb24gaXMgdW5zcGVjaWZpZWQuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiVFVSTl9DT01QTEVURV9SRUFTT05fVU5TUEVDSUZJRURcIl0gPSBcIlRVUk5fQ09NUExFVEVfUkVBU09OX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bmN0aW9uIGNhbGwgZ2VuZXJhdGVkIGJ5IHRoZSBtb2RlbCBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk1BTEZPUk1FRF9GVU5DVElPTl9DQUxMXCJdID0gXCJNQUxGT1JNRURfRlVOQ1RJT05fQ0FMTFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNwb25zZSBpcyByZWplY3RlZCBieSB0aGUgbW9kZWwuXG4gICAgICovXG4gICAgVHVybkNvbXBsZXRlUmVhc29uW1wiUkVTUE9OU0VfUkVKRUNURURcIl0gPSBcIlJFU1BPTlNFX1JFSkVDVEVEXCI7XG4gICAgLyoqXG4gICAgICogTmVlZHMgbW9yZSBpbnB1dCBmcm9tIHRoZSB1c2VyLlxuICAgICAqL1xuICAgIFR1cm5Db21wbGV0ZVJlYXNvbltcIk5FRURfTU9SRV9JTlBVVFwiXSA9IFwiTkVFRF9NT1JFX0lOUFVUXCI7XG59KShUdXJuQ29tcGxldGVSZWFzb24gfHwgKFR1cm5Db21wbGV0ZVJlYXNvbiA9IHt9KSk7XG4vKiogU2VydmVyIGNvbnRlbnQgbW9kYWxpdGllcy4gKi9cbnZhciBNZWRpYU1vZGFsaXR5O1xuKGZ1bmN0aW9uIChNZWRpYU1vZGFsaXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIG1vZGFsaXR5IGlzIHVuc3BlY2lmaWVkLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJNT0RBTElUWV9VTlNQRUNJRklFRFwiXSA9IFwiTU9EQUxJVFlfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBQbGFpbiB0ZXh0LlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJURVhUXCJdID0gXCJURVhUXCI7XG4gICAgLyoqXG4gICAgICogSW1hZ2VzLlxuICAgICAqL1xuICAgIE1lZGlhTW9kYWxpdHlbXCJJTUFHRVwiXSA9IFwiSU1BR0VcIjtcbiAgICAvKipcbiAgICAgKiBWaWRlby5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiVklERU9cIl0gPSBcIlZJREVPXCI7XG4gICAgLyoqXG4gICAgICogQXVkaW8uXG4gICAgICovXG4gICAgTWVkaWFNb2RhbGl0eVtcIkFVRElPXCJdID0gXCJBVURJT1wiO1xuICAgIC8qKlxuICAgICAqIERvY3VtZW50LCBlLmcuIFBERi5cbiAgICAgKi9cbiAgICBNZWRpYU1vZGFsaXR5W1wiRE9DVU1FTlRcIl0gPSBcIkRPQ1VNRU5UXCI7XG59KShNZWRpYU1vZGFsaXR5IHx8IChNZWRpYU1vZGFsaXR5ID0ge30pKTtcbi8qKiBTdGFydCBvZiBzcGVlY2ggc2Vuc2l0aXZpdHkuICovXG52YXIgU3RhcnRTZW5zaXRpdml0eTtcbihmdW5jdGlvbiAoU3RhcnRTZW5zaXRpdml0eSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGlzIFNUQVJUX1NFTlNJVElWSVRZX0xPVy5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfVU5TUEVDSUZJRURcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiB3aWxsIGRldGVjdCB0aGUgc3RhcnQgb2Ygc3BlZWNoIG1vcmUgb2Z0ZW4uXG4gICAgICovXG4gICAgU3RhcnRTZW5zaXRpdml0eVtcIlNUQVJUX1NFTlNJVElWSVRZX0hJR0hcIl0gPSBcIlNUQVJUX1NFTlNJVElWSVRZX0hJR0hcIjtcbiAgICAvKipcbiAgICAgKiBBdXRvbWF0aWMgZGV0ZWN0aW9uIHdpbGwgZGV0ZWN0IHRoZSBzdGFydCBvZiBzcGVlY2ggbGVzcyBvZnRlbi5cbiAgICAgKi9cbiAgICBTdGFydFNlbnNpdGl2aXR5W1wiU1RBUlRfU0VOU0lUSVZJVFlfTE9XXCJdID0gXCJTVEFSVF9TRU5TSVRJVklUWV9MT1dcIjtcbn0pKFN0YXJ0U2Vuc2l0aXZpdHkgfHwgKFN0YXJ0U2Vuc2l0aXZpdHkgPSB7fSkpO1xuLyoqIEVuZCBvZiBzcGVlY2ggc2Vuc2l0aXZpdHkuICovXG52YXIgRW5kU2Vuc2l0aXZpdHk7XG4oZnVuY3Rpb24gKEVuZFNlbnNpdGl2aXR5KSB7XG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgaXMgRU5EX1NFTlNJVElWSVRZX0xPVy5cbiAgICAgKi9cbiAgICBFbmRTZW5zaXRpdml0eVtcIkVORF9TRU5TSVRJVklUWV9VTlNQRUNJRklFRFwiXSA9IFwiRU5EX1NFTlNJVElWSVRZX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiBlbmRzIHNwZWVjaCBtb3JlIG9mdGVuLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX0hJR0hcIl0gPSBcIkVORF9TRU5TSVRJVklUWV9ISUdIXCI7XG4gICAgLyoqXG4gICAgICogQXV0b21hdGljIGRldGVjdGlvbiBlbmRzIHNwZWVjaCBsZXNzIG9mdGVuLlxuICAgICAqL1xuICAgIEVuZFNlbnNpdGl2aXR5W1wiRU5EX1NFTlNJVElWSVRZX0xPV1wiXSA9IFwiRU5EX1NFTlNJVElWSVRZX0xPV1wiO1xufSkoRW5kU2Vuc2l0aXZpdHkgfHwgKEVuZFNlbnNpdGl2aXR5ID0ge30pKTtcbi8qKiBUaGUgZGlmZmVyZW50IHdheXMgb2YgaGFuZGxpbmcgdXNlciBhY3Rpdml0eS4gKi9cbnZhciBBY3Rpdml0eUhhbmRsaW5nO1xuKGZ1bmN0aW9uIChBY3Rpdml0eUhhbmRsaW5nKSB7XG4gICAgLyoqXG4gICAgICogSWYgdW5zcGVjaWZpZWQsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIGlzIGBTVEFSVF9PRl9BQ1RJVklUWV9JTlRFUlJVUFRTYC5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiQUNUSVZJVFlfSEFORExJTkdfVU5TUEVDSUZJRURcIl0gPSBcIkFDVElWSVRZX0hBTkRMSU5HX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgc3RhcnQgb2YgYWN0aXZpdHkgd2lsbCBpbnRlcnJ1cHQgdGhlIG1vZGVsJ3MgcmVzcG9uc2UgKGFsc28gY2FsbGVkIFwiYmFyZ2UgaW5cIikuIFRoZSBtb2RlbCdzIGN1cnJlbnQgcmVzcG9uc2Ugd2lsbCBiZSBjdXQtb2ZmIGluIHRoZSBtb21lbnQgb2YgdGhlIGludGVycnVwdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBBY3Rpdml0eUhhbmRsaW5nW1wiU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU1wiXSA9IFwiU1RBUlRfT0ZfQUNUSVZJVFlfSU5URVJSVVBUU1wiO1xuICAgIC8qKlxuICAgICAqIFRoZSBtb2RlbCdzIHJlc3BvbnNlIHdpbGwgbm90IGJlIGludGVycnVwdGVkLlxuICAgICAqL1xuICAgIEFjdGl2aXR5SGFuZGxpbmdbXCJOT19JTlRFUlJVUFRJT05cIl0gPSBcIk5PX0lOVEVSUlVQVElPTlwiO1xufSkoQWN0aXZpdHlIYW5kbGluZyB8fCAoQWN0aXZpdHlIYW5kbGluZyA9IHt9KSk7XG4vKiogT3B0aW9ucyBhYm91dCB3aGljaCBpbnB1dCBpcyBpbmNsdWRlZCBpbiB0aGUgdXNlcidzIHR1cm4uICovXG52YXIgVHVybkNvdmVyYWdlO1xuKGZ1bmN0aW9uIChUdXJuQ292ZXJhZ2UpIHtcbiAgICAvKipcbiAgICAgKiBJZiB1bnNwZWNpZmllZCwgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgYFRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWWAuXG4gICAgICovXG4gICAgVHVybkNvdmVyYWdlW1wiVFVSTl9DT1ZFUkFHRV9VTlNQRUNJRklFRFwiXSA9IFwiVFVSTl9DT1ZFUkFHRV9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VycyB0dXJuIG9ubHkgaW5jbHVkZXMgYWN0aXZpdHkgc2luY2UgdGhlIGxhc3QgdHVybiwgZXhjbHVkaW5nIGluYWN0aXZpdHkgKGUuZy4gc2lsZW5jZSBvbiB0aGUgYXVkaW8gc3RyZWFtKS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICBUdXJuQ292ZXJhZ2VbXCJUVVJOX0lOQ0xVREVTX09OTFlfQUNUSVZJVFlcIl0gPSBcIlRVUk5fSU5DTFVERVNfT05MWV9BQ1RJVklUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VycyB0dXJuIGluY2x1ZGVzIGFsbCByZWFsdGltZSBpbnB1dCBzaW5jZSB0aGUgbGFzdCB0dXJuLCBpbmNsdWRpbmcgaW5hY3Rpdml0eSAoZS5nLiBzaWxlbmNlIG9uIHRoZSBhdWRpbyBzdHJlYW0pLlxuICAgICAqL1xuICAgIFR1cm5Db3ZlcmFnZVtcIlRVUk5fSU5DTFVERVNfQUxMX0lOUFVUXCJdID0gXCJUVVJOX0lOQ0xVREVTX0FMTF9JTlBVVFwiO1xufSkoVHVybkNvdmVyYWdlIHx8IChUdXJuQ292ZXJhZ2UgPSB7fSkpO1xuLyoqIFNwZWNpZmllcyBob3cgdGhlIHJlc3BvbnNlIHNob3VsZCBiZSBzY2hlZHVsZWQgaW4gdGhlIGNvbnZlcnNhdGlvbi4gKi9cbnZhciBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZztcbihmdW5jdGlvbiAoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcpIHtcbiAgICAvKipcbiAgICAgKiBUaGlzIHZhbHVlIGlzIHVudXNlZC5cbiAgICAgKi9cbiAgICBGdW5jdGlvblJlc3BvbnNlU2NoZWR1bGluZ1tcIlNDSEVEVUxJTkdfVU5TUEVDSUZJRURcIl0gPSBcIlNDSEVEVUxJTkdfVU5TUEVDSUZJRURcIjtcbiAgICAvKipcbiAgICAgKiBPbmx5IGFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgZG8gbm90IGludGVycnVwdCBvciB0cmlnZ2VyIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJTSUxFTlRcIl0gPSBcIlNJTEVOVFwiO1xuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBjb252ZXJzYXRpb24gY29udGV4dCwgYW5kIHByb21wdCB0byBnZW5lcmF0ZSBvdXRwdXQgd2l0aG91dCBpbnRlcnJ1cHRpbmcgb25nb2luZyBnZW5lcmF0aW9uLlxuICAgICAqL1xuICAgIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nW1wiV0hFTl9JRExFXCJdID0gXCJXSEVOX0lETEVcIjtcbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIHJlc3VsdCB0byB0aGUgY29udmVyc2F0aW9uIGNvbnRleHQsIGludGVycnVwdCBvbmdvaW5nIGdlbmVyYXRpb24gYW5kIHByb21wdCB0byBnZW5lcmF0ZSBvdXRwdXQuXG4gICAgICovXG4gICAgRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmdbXCJJTlRFUlJVUFRcIl0gPSBcIklOVEVSUlVQVFwiO1xufSkoRnVuY3Rpb25SZXNwb25zZVNjaGVkdWxpbmcgfHwgKEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nID0ge30pKTtcbi8qKiBTY2FsZSBvZiB0aGUgZ2VuZXJhdGVkIG11c2ljLiAqL1xudmFyIFNjYWxlO1xuKGZ1bmN0aW9uIChTY2FsZSkge1xuICAgIC8qKlxuICAgICAqIERlZmF1bHQgdmFsdWUuIFRoaXMgdmFsdWUgaXMgdW51c2VkLlxuICAgICAqL1xuICAgIFNjYWxlW1wiU0NBTEVfVU5TUEVDSUZJRURcIl0gPSBcIlNDQUxFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogQyBtYWpvciBvciBBIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQ19NQUpPUl9BX01JTk9SXCJdID0gXCJDX01BSk9SX0FfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBEYiBtYWpvciBvciBCYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkRfRkxBVF9NQUpPUl9CX0ZMQVRfTUlOT1JcIl0gPSBcIkRfRkxBVF9NQUpPUl9CX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBEIG1ham9yIG9yIEIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJEX01BSk9SX0JfTUlOT1JcIl0gPSBcIkRfTUFKT1JfQl9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEViIG1ham9yIG9yIEMgbWlub3JcbiAgICAgKi9cbiAgICBTY2FsZVtcIkVfRkxBVF9NQUpPUl9DX01JTk9SXCJdID0gXCJFX0ZMQVRfTUFKT1JfQ19NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEUgbWFqb3Igb3IgRGIgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJFX01BSk9SX0RfRkxBVF9NSU5PUlwiXSA9IFwiRV9NQUpPUl9EX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBGIG1ham9yIG9yIEQgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJGX01BSk9SX0RfTUlOT1JcIl0gPSBcIkZfTUFKT1JfRF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEdiIG1ham9yIG9yIEViIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiR19GTEFUX01BSk9SX0VfRkxBVF9NSU5PUlwiXSA9IFwiR19GTEFUX01BSk9SX0VfRkxBVF9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEcgbWFqb3Igb3IgRSBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkdfTUFKT1JfRV9NSU5PUlwiXSA9IFwiR19NQUpPUl9FX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQWIgbWFqb3Igb3IgRiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkFfRkxBVF9NQUpPUl9GX01JTk9SXCJdID0gXCJBX0ZMQVRfTUFKT1JfRl9NSU5PUlwiO1xuICAgIC8qKlxuICAgICAqIEEgbWFqb3Igb3IgR2IgbWlub3IuXG4gICAgICovXG4gICAgU2NhbGVbXCJBX01BSk9SX0dfRkxBVF9NSU5PUlwiXSA9IFwiQV9NQUpPUl9HX0ZMQVRfTUlOT1JcIjtcbiAgICAvKipcbiAgICAgKiBCYiBtYWpvciBvciBHIG1pbm9yLlxuICAgICAqL1xuICAgIFNjYWxlW1wiQl9GTEFUX01BSk9SX0dfTUlOT1JcIl0gPSBcIkJfRkxBVF9NQUpPUl9HX01JTk9SXCI7XG4gICAgLyoqXG4gICAgICogQiBtYWpvciBvciBBYiBtaW5vci5cbiAgICAgKi9cbiAgICBTY2FsZVtcIkJfTUFKT1JfQV9GTEFUX01JTk9SXCJdID0gXCJCX01BSk9SX0FfRkxBVF9NSU5PUlwiO1xufSkoU2NhbGUgfHwgKFNjYWxlID0ge30pKTtcbi8qKiBUaGUgbW9kZSBvZiBtdXNpYyBnZW5lcmF0aW9uLiAqL1xudmFyIE11c2ljR2VuZXJhdGlvbk1vZGU7XG4oZnVuY3Rpb24gKE11c2ljR2VuZXJhdGlvbk1vZGUpIHtcbiAgICAvKipcbiAgICAgKiBSZWx5IG9uIHRoZSBzZXJ2ZXIgZGVmYXVsdCBnZW5lcmF0aW9uIG1vZGUuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIk1VU0lDX0dFTkVSQVRJT05fTU9ERV9VTlNQRUNJRklFRFwiXSA9IFwiTVVTSUNfR0VORVJBVElPTl9NT0RFX1VOU1BFQ0lGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIHdpdGggaGlnaGVyIHF1YWxpdHlcbiAgICAgICAgbXVzaWMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIlFVQUxJVFlcIl0gPSBcIlFVQUxJVFlcIjtcbiAgICAvKipcbiAgICAgKiBTdGVlciB0ZXh0IHByb21wdHMgdG8gcmVnaW9ucyBvZiBsYXRlbnQgc3BhY2Ugd2l0aCBhIGxhcmdlclxuICAgICAgICBkaXZlcnNpdHkgb2YgbXVzaWMuXG4gICAgICovXG4gICAgTXVzaWNHZW5lcmF0aW9uTW9kZVtcIkRJVkVSU0lUWVwiXSA9IFwiRElWRVJTSVRZXCI7XG4gICAgLyoqXG4gICAgICogU3RlZXIgdGV4dCBwcm9tcHRzIHRvIHJlZ2lvbnMgb2YgbGF0ZW50IHNwYWNlIG1vcmUgbGlrZWx5IHRvXG4gICAgICAgIGdlbmVyYXRlIG11c2ljIHdpdGggdm9jYWxzLlxuICAgICAqL1xuICAgIE11c2ljR2VuZXJhdGlvbk1vZGVbXCJWT0NBTElaQVRJT05cIl0gPSBcIlZPQ0FMSVpBVElPTlwiO1xufSkoTXVzaWNHZW5lcmF0aW9uTW9kZSB8fCAoTXVzaWNHZW5lcmF0aW9uTW9kZSA9IHt9KSk7XG4vKiogVGhlIHBsYXliYWNrIGNvbnRyb2wgc2lnbmFsIHRvIGFwcGx5IHRvIHRoZSBtdXNpYyBnZW5lcmF0aW9uLiAqL1xudmFyIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbDtcbihmdW5jdGlvbiAoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyB2YWx1ZSBpcyB1bnVzZWQuXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiUExBWUJBQ0tfQ09OVFJPTF9VTlNQRUNJRklFRFwiXSA9IFwiUExBWUJBQ0tfQ09OVFJPTF9VTlNQRUNJRklFRFwiO1xuICAgIC8qKlxuICAgICAqIFN0YXJ0IGdlbmVyYXRpbmcgdGhlIG11c2ljLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlBMQVlcIl0gPSBcIlBMQVlcIjtcbiAgICAvKipcbiAgICAgKiBIb2xkIHRoZSBtdXNpYyBnZW5lcmF0aW9uLiBVc2UgUExBWSB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2xbXCJQQVVTRVwiXSA9IFwiUEFVU0VcIjtcbiAgICAvKipcbiAgICAgKiBTdG9wIHRoZSBtdXNpYyBnZW5lcmF0aW9uIGFuZCByZXNldCB0aGUgY29udGV4dCAocHJvbXB0cyByZXRhaW5lZCkuXG4gICAgICAgIFVzZSBQTEFZIHRvIHJlc3RhcnQgdGhlIG11c2ljIGdlbmVyYXRpb24uXG4gICAgICovXG4gICAgTGl2ZU11c2ljUGxheWJhY2tDb250cm9sW1wiU1RPUFwiXSA9IFwiU1RPUFwiO1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICAgIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0cyBhbmQgY29uZmlnLlxuICAgICAqL1xuICAgIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbFtcIlJFU0VUX0NPTlRFWFRcIl0gPSBcIlJFU0VUX0NPTlRFWFRcIjtcbn0pKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCB8fCAoTGl2ZU11c2ljUGxheWJhY2tDb250cm9sID0ge30pKTtcbi8qKiBSYXcgbWVkaWEgYnl0ZXMgZm9yIGZ1bmN0aW9uIHJlc3BvbnNlLlxuXG4gIFRleHQgc2hvdWxkIG5vdCBiZSBzZW50IGFzIHJhdyBieXRlcywgdXNlIHRoZSBGdW5jdGlvblJlc3BvbnNlLnJlc3BvbnNlXG4gIGZpZWxkLlxuICAgKi9cbmNsYXNzIEZ1bmN0aW9uUmVzcG9uc2VCbG9iIHtcbn1cbi8qKiBVUkkgYmFzZWQgZGF0YSBmb3IgZnVuY3Rpb24gcmVzcG9uc2UuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlRmlsZURhdGEge1xufVxuLyoqIEEgZGF0YXR5cGUgY29udGFpbmluZyBtZWRpYSB0aGF0IGlzIHBhcnQgb2YgYSBgRnVuY3Rpb25SZXNwb25zZWAgbWVzc2FnZS5cblxuICBBIGBGdW5jdGlvblJlc3BvbnNlUGFydGAgY29uc2lzdHMgb2YgZGF0YSB3aGljaCBoYXMgYW4gYXNzb2NpYXRlZCBkYXRhdHlwZS4gQVxuICBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIGNhbiBvbmx5IGNvbnRhaW4gb25lIG9mIHRoZSBhY2NlcHRlZCB0eXBlcyBpblxuICBgRnVuY3Rpb25SZXNwb25zZVBhcnQuZGF0YWAuXG5cbiAgQSBgRnVuY3Rpb25SZXNwb25zZVBhcnRgIG11c3QgaGF2ZSBhIGZpeGVkIElBTkEgTUlNRSB0eXBlIGlkZW50aWZ5aW5nIHRoZVxuICB0eXBlIGFuZCBzdWJ0eXBlIG9mIHRoZSBtZWRpYSBpZiB0aGUgYGlubGluZV9kYXRhYCBmaWVsZCBpcyBmaWxsZWQgd2l0aCByYXdcbiAgYnl0ZXMuXG4gICAqL1xuY2xhc3MgRnVuY3Rpb25SZXNwb25zZVBhcnQge1xufVxuLyoqIEEgZnVuY3Rpb24gcmVzcG9uc2UuICovXG5jbGFzcyBGdW5jdGlvblJlc3BvbnNlIHtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBVUklgIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21VcmkodXJpLCBtaW1lVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZpbGVEYXRhOiB7XG4gICAgICAgICAgICBmaWxlVXJpOiB1cmksXG4gICAgICAgICAgICBtaW1lVHlwZTogbWltZVR5cGUsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGB0ZXh0YCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uQ2FsbGAgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbChuYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnVuY3Rpb25DYWxsOiB7XG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgYXJnczogYXJncyxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIGEgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlKGlkLCBuYW1lLCByZXNwb25zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICByZXNwb25zZTogcmVzcG9uc2UsXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBQYXJ0YCBvYmplY3QgZnJvbSBhIGBiYXNlNjRgIGVuY29kZWQgYHN0cmluZ2AuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tQmFzZTY0KGRhdGEsIG1pbWVUeXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5saW5lRGF0YToge1xuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBtaW1lVHlwZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgb3V0Y29tZWAgYW5kIGBvdXRwdXRgIG9mIGEgYENvZGVFeGVjdXRpb25SZXN1bHRgIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KG91dGNvbWUsIG91dHB1dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvZGVFeGVjdXRpb25SZXN1bHQ6IHtcbiAgICAgICAgICAgIG91dGNvbWU6IG91dGNvbWUsXG4gICAgICAgICAgICBvdXRwdXQ6IG91dHB1dCxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYFBhcnRgIG9iamVjdCBmcm9tIHRoZSBgY29kZWAgYW5kIGBsYW5ndWFnZWAgb2YgYW4gYEV4ZWN1dGFibGVDb2RlYCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBhcnRGcm9tRXhlY3V0YWJsZUNvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBleGVjdXRhYmxlQ29kZToge1xuICAgICAgICAgICAgY29kZTogY29kZSxcbiAgICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gX2lzUGFydChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAoJ2ZpbGVEYXRhJyBpbiBvYmogfHxcbiAgICAgICAgICAgICd0ZXh0JyBpbiBvYmogfHxcbiAgICAgICAgICAgICdmdW5jdGlvbkNhbGwnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2lubGluZURhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnIGluIG9iaiB8fFxuICAgICAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyBpbiBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpIHtcbiAgICBjb25zdCBwYXJ0cyA9IFtdO1xuICAgIGlmICh0eXBlb2YgcGFydE9yU3RyaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKGNyZWF0ZVBhcnRGcm9tVGV4dChwYXJ0T3JTdHJpbmcpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIHBhcnRzLnB1c2gocGFydE9yU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShwYXJ0T3JTdHJpbmcpKSB7XG4gICAgICAgIGlmIChwYXJ0T3JTdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcnRPclN0cmluZyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydE9yU3RyaW5nKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcGFydHMucHVzaChjcmVhdGVQYXJ0RnJvbVRleHQocGFydCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX2lzUGFydChwYXJ0KSkge1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VsZW1lbnQgaW4gUGFydFVuaW9uIG11c3QgYmUgYSBQYXJ0IG9iamVjdCBvciBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJ0T3JTdHJpbmcgbXVzdCBiZSBhIFBhcnQgb2JqZWN0LCBzdHJpbmcsIG9yIGFycmF5Jyk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cztcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBDb250ZW50YCBvYmplY3Qgd2l0aCBhIHVzZXIgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVXNlckNvbnRlbnQocGFydE9yU3RyaW5nKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogX3RvUGFydHMocGFydE9yU3RyaW5nKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgYENvbnRlbnRgIG9iamVjdCB3aXRoIGEgbW9kZWwgcm9sZSBmcm9tIGEgYFBhcnRMaXN0VW5pb25gIG9iamVjdCBvciBgc3RyaW5nYC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9kZWxDb250ZW50KHBhcnRPclN0cmluZykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJvbGU6ICdtb2RlbCcsXG4gICAgICAgIHBhcnRzOiBfdG9QYXJ0cyhwYXJ0T3JTdHJpbmcpLFxuICAgIH07XG59XG4vKiogQSB3cmFwcGVyIGNsYXNzIGZvciB0aGUgaHR0cCByZXNwb25zZS4gKi9cbmNsYXNzIEh0dHBSZXNwb25zZSB7XG4gICAgY29uc3RydWN0b3IocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgaGVhZGVycy5cbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcmVzcG9uc2UuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIC8vIEtlZXAgdGhlIG9yaWdpbmFsIHJlc3BvbnNlLlxuICAgICAgICB0aGlzLnJlc3BvbnNlSW50ZXJuYWwgPSByZXNwb25zZTtcbiAgICB9XG4gICAganNvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzcG9uc2VJbnRlcm5hbC5qc29uKCk7XG4gICAgfVxufVxuLyoqIENvbnRlbnQgZmlsdGVyIHJlc3VsdHMgZm9yIGEgcHJvbXB0IHNlbnQgaW4gdGhlIHJlcXVlc3QuICovXG5jbGFzcyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZVByb21wdEZlZWRiYWNrIHtcbn1cbi8qKiBVc2FnZSBtZXRhZGF0YSBhYm91dCByZXNwb25zZShzKS4gKi9cbmNsYXNzIEdlbmVyYXRlQ29udGVudFJlc3BvbnNlVXNhZ2VNZXRhZGF0YSB7XG59XG4vKiogUmVzcG9uc2UgbWVzc2FnZSBmb3IgUHJlZGljdGlvblNlcnZpY2UuR2VuZXJhdGVDb250ZW50LiAqL1xuY2xhc3MgR2VuZXJhdGVDb250ZW50UmVzcG9uc2Uge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIHRleHQgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgdGV4dCBmcm9tIHRoZSBmaXJzdFxuICAgICAqIG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKiBJZiB0aGVyZSBhcmUgdGhvdWdodCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgZXhjbHVkaW5nIHRoZSB0aG91Z2h0IHBhcnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgKiAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICBjb250ZW50czpcbiAgICAgKiAgICAgJ1doeSBpcyB0aGUgc2t5IGJsdWU/JyxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UudGV4dCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgdGV4dCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgbGV0IGFueVRleHRQYXJ0VGV4dCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBub25UZXh0UGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICd0ZXh0JyAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZE5hbWUgIT09ICd0aG91Z2h0JyAmJlxuICAgICAgICAgICAgICAgICAgICAoZmllbGRWYWx1ZSAhPT0gbnVsbCB8fCBmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vblRleHRQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0LnRob3VnaHQgPT09ICdib29sZWFuJyAmJiBwYXJ0LnRob3VnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueVRleHRQYXJ0VGV4dCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRUZXh0ID8gdGV4dCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlXG4gICAgICogaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBpbmxpbmUgZGF0YSBmcm9tIHRoZVxuICAgICAqIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLiBJZiB0aGVyZSBhcmUgbm9uLWlubGluZSBkYXRhIHBhcnRzIGluIHRoZVxuICAgICAqIHJlc3BvbnNlLCB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaW5saW5lIGRhdGEgcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kXG4gICAgICogYSB3YXJuaW5nIHdpbGwgYmUgbG9nZ2VkLlxuICAgICAqL1xuICAgIGdldCBkYXRhKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGRhdGEgZnJvbSB0aGUgZmlyc3Qgb25lLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhID0gJyc7XG4gICAgICAgIGNvbnN0IG5vbkRhdGFQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9oID0gKF9nID0gKF9mID0gKF9lID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2VbMF0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jb250ZW50KSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cucGFydHMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ2lubGluZURhdGEnICYmXG4gICAgICAgICAgICAgICAgICAgIChmaWVsZFZhbHVlICE9PSBudWxsIHx8IGZpZWxkVmFsdWUgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uRGF0YVBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydC5pbmxpbmVEYXRhICYmIHR5cGVvZiBwYXJ0LmlubGluZURhdGEuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkYXRhICs9IGF0b2IocGFydC5pbmxpbmVEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub25EYXRhUGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGB0aGVyZSBhcmUgbm9uLWRhdGEgcGFydHMgJHtub25EYXRhUGFydHN9IGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvbmNhdGVuYXRpb24gb2YgYWxsIGRhdGEgcGFydHMuIFBsZWFzZSByZWZlciB0byB0aGUgbm9uIGRhdGEgcGFydHMgZm9yIGEgZnVsbCByZXNwb25zZSBmcm9tIG1vZGVsLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhLmxlbmd0aCA+IDAgPyBidG9hKGRhdGEpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBjYW5kaWRhdGUgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBmdW5jdGlvbiBjYWxscyBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBmdW5jdGlvbiBjYWxscyBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb246IEZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XG4gICAgICogICBuYW1lOiAnY29udHJvbExpZ2h0JyxcbiAgICAgKiAgIHBhcmFtZXRlcnM6IHtcbiAgICAgKiAgIHR5cGU6IFR5cGUuT0JKRUNULFxuICAgICAqICAgZGVzY3JpcHRpb246ICdTZXQgdGhlIGJyaWdodG5lc3MgYW5kIGNvbG9yIHRlbXBlcmF0dXJlIG9mIGEgcm9vbSBsaWdodC4nLFxuICAgICAqICAgcHJvcGVydGllczoge1xuICAgICAqICAgICBicmlnaHRuZXNzOiB7XG4gICAgICogICAgICAgdHlwZTogVHlwZS5OVU1CRVIsXG4gICAgICogICAgICAgZGVzY3JpcHRpb246XG4gICAgICogICAgICAgICAnTGlnaHQgbGV2ZWwgZnJvbSAwIHRvIDEwMC4gWmVybyBpcyBvZmYgYW5kIDEwMCBpcyBmdWxsIGJyaWdodG5lc3MuJyxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY29sb3JUZW1wZXJhdHVyZToge1xuICAgICAqICAgICAgIHR5cGU6IFR5cGUuU1RSSU5HLFxuICAgICAqICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAqICAgICAgICAgJ0NvbG9yIHRlbXBlcmF0dXJlIG9mIHRoZSBsaWdodCBmaXh0dXJlIHdoaWNoIGNhbiBiZSBgZGF5bGlnaHRgLCBgY29vbGAgb3IgYHdhcm1gLicsXG4gICAgICogICAgIH0sXG4gICAgICogICB9LFxuICAgICAqICAgcmVxdWlyZWQ6IFsnYnJpZ2h0bmVzcycsICdjb2xvclRlbXBlcmF0dXJlJ10sXG4gICAgICogIH07XG4gICAgICogIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaCcsXG4gICAgICogICAgIGNvbnRlbnRzOiAnRGltIHRoZSBsaWdodHMgc28gdGhlIHJvb20gZmVlbHMgY296eSBhbmQgd2FybS4nLFxuICAgICAqICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICB0b29sczogW3tmdW5jdGlvbkRlY2xhcmF0aW9uczogW2NvbnRyb2xMaWdodEZ1bmN0aW9uRGVjbGFyYXRpb25dfV0sXG4gICAgICogICAgICAgdG9vbENvbmZpZzoge1xuICAgICAqICAgICAgICAgZnVuY3Rpb25DYWxsaW5nQ29uZmlnOiB7XG4gICAgICogICAgICAgICAgIG1vZGU6IEZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ01vZGUuQU5ZLFxuICAgICAqICAgICAgICAgICBhbGxvd2VkRnVuY3Rpb25OYW1lczogWydjb250cm9sTGlnaHQnXSxcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pO1xuICAgICAqICBjb25zb2xlLmRlYnVnKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMpKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgZnVuY3Rpb25DYWxscygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgaWYgKCgoX2QgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5wYXJ0cykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY2FuZGlkYXRlcyAmJiB0aGlzLmNhbmRpZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGVyZSBhcmUgbXVsdGlwbGUgY2FuZGlkYXRlcyBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBmdW5jdGlvbiBjYWxscyBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxscyA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkubWFwKChwYXJ0KSA9PiBwYXJ0LmZ1bmN0aW9uQ2FsbCkuZmlsdGVyKChmdW5jdGlvbkNhbGwpID0+IGZ1bmN0aW9uQ2FsbCAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKChmdW5jdGlvbkNhbGxzID09PSBudWxsIHx8IGZ1bmN0aW9uQ2FsbHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZ1bmN0aW9uQ2FsbHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb25DYWxscztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IGNhbmRpZGF0ZSBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgdGhlIGV4ZWN1dGFibGUgY29kZSBmcm9tXG4gICAgICogdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIElmIHRoZXJlIGFyZSBubyBleGVjdXRhYmxlIGNvZGUgaW4gdGhlIHJlc3BvbnNlLCB1bmRlZmluZWQgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuZXhlY3V0YWJsZUNvZGUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBleGVjdXRhYmxlQ29kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XG4gICAgICAgIGlmICgoKF9kID0gKF9jID0gKF9iID0gKF9hID0gdGhpcy5jYW5kaWRhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucGFydHMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNhbmRpZGF0ZXMgJiYgdGhpcy5jYW5kaWRhdGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgZXhlY3V0YWJsZSBjb2RlIGZyb20gdGhlIGZpcnN0IG9uZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGVjdXRhYmxlQ29kZSA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmV4ZWN1dGFibGVDb2RlKS5tYXAoKHBhcnQpID0+IHBhcnQuZXhlY3V0YWJsZUNvZGUpLmZpbHRlcigoZXhlY3V0YWJsZUNvZGUpID0+IGV4ZWN1dGFibGVDb2RlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICBpZiAoKGV4ZWN1dGFibGVDb2RlID09PSBudWxsIHx8IGV4ZWN1dGFibGVDb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGVjdXRhYmxlQ29kZS5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2ogPSBleGVjdXRhYmxlQ29kZSA9PT0gbnVsbCB8fCBleGVjdXRhYmxlQ29kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXhlY3V0YWJsZUNvZGVbMF0pID09PSBudWxsIHx8IF9qID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfai5jb2RlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBjb2RlIGV4ZWN1dGlvbiByZXN1bHQgZnJvbSB0aGUgZmlyc3QgY2FuZGlkYXRlIGluIHRoZSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNhbmRpZGF0ZXMgaW4gdGhlIHJlc3BvbnNlLCB0aGUgY29kZSBleGVjdXRpb24gcmVzdWx0IGZyb21cbiAgICAgKiB0aGUgZmlyc3Qgb25lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICAgY29udGVudHM6XG4gICAgICogICAgICdXaGF0IGlzIHRoZSBzdW0gb2YgdGhlIGZpcnN0IDUwIHByaW1lIG51bWJlcnM/IEdlbmVyYXRlIGFuZCBydW4gY29kZSBmb3IgdGhlIGNhbGN1bGF0aW9uLCBhbmQgbWFrZSBzdXJlIHlvdSBnZXQgYWxsIDUwLidcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICB0b29sczogW3tjb2RlRXhlY3V0aW9uOiB7fX1dLFxuICAgICAqICAgfSxcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUuZGVidWcocmVzcG9uc2UuY29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGNvZGVFeGVjdXRpb25SZXN1bHQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xuICAgICAgICBpZiAoKChfZCA9IChfYyA9IChfYiA9IChfYSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnBhcnRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5kaWRhdGVzICYmIHRoaXMuY2FuZGlkYXRlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoZXJlIGFyZSBtdWx0aXBsZSBjYW5kaWRhdGVzIGluIHRoZSByZXNwb25zZSwgcmV0dXJuaW5nIGNvZGUgZXhlY3V0aW9uIHJlc3VsdCBmcm9tIHRoZSBmaXJzdCBvbmUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZUV4ZWN1dGlvblJlc3VsdCA9IChfaCA9IChfZyA9IChfZiA9IChfZSA9IHRoaXMuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lWzBdKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY29udGVudCkgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnBhcnRzKSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LmNvZGVFeGVjdXRpb25SZXN1bHQpLm1hcCgocGFydCkgPT4gcGFydC5jb2RlRXhlY3V0aW9uUmVzdWx0KS5maWx0ZXIoKGNvZGVFeGVjdXRpb25SZXN1bHQpID0+IGNvZGVFeGVjdXRpb25SZXN1bHQgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmICgoY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gbnVsbCB8fCBjb2RlRXhlY3V0aW9uUmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2RlRXhlY3V0aW9uUmVzdWx0Lmxlbmd0aCkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfaiA9IGNvZGVFeGVjdXRpb25SZXN1bHQgPT09IG51bGwgfHwgY29kZUV4ZWN1dGlvblJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29kZUV4ZWN1dGlvblJlc3VsdFswXSkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLm91dHB1dDtcbiAgICB9XG59XG4vKiogUmVzcG9uc2UgZm9yIHRoZSBlbWJlZF9jb250ZW50IG1ldGhvZC4gKi9cbmNsYXNzIEVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBUaGUgb3V0cHV0IGltYWdlcyByZXNwb25zZS4gKi9cbmNsYXNzIEdlbmVyYXRlSW1hZ2VzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgcmVxdWVzdCB0byBlZGl0IGFuIGltYWdlLiAqL1xuY2xhc3MgRWRpdEltYWdlUmVzcG9uc2Uge1xufVxuY2xhc3MgVXBzY2FsZUltYWdlUmVzcG9uc2Uge1xufVxuLyoqIFRoZSBvdXRwdXQgaW1hZ2VzIHJlc3BvbnNlLiAqL1xuY2xhc3MgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSB7XG59XG4vKiogVGhlIG91dHB1dCBpbWFnZXMgcmVzcG9uc2UuICovXG5jbGFzcyBTZWdtZW50SW1hZ2VSZXNwb25zZSB7XG59XG5jbGFzcyBMaXN0TW9kZWxzUmVzcG9uc2Uge1xufVxuY2xhc3MgRGVsZXRlTW9kZWxSZXNwb25zZSB7XG59XG4vKiogUmVzcG9uc2UgZm9yIGNvdW50aW5nIHRva2Vucy4gKi9cbmNsYXNzIENvdW50VG9rZW5zUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciBjb21wdXRpbmcgdG9rZW5zLiAqL1xuY2xhc3MgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSB3aXRoIGdlbmVyYXRlZCB2aWRlb3MuICovXG5jbGFzcyBHZW5lcmF0ZVZpZGVvc1Jlc3BvbnNlIHtcbn1cbi8qKiBBIHZpZGVvIGdlbmVyYXRpb24gb3BlcmF0aW9uLiAqL1xuY2xhc3MgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24ge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlcyBhbiBPcGVyYXRpb24gb2YgdGhlIHNhbWUgdHlwZSBhcyB0aGUgb25lIGJlaW5nIGNhbGxlZCB3aXRoIHRoZSBmaWVsZHMgc2V0IGZyb20gdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBfZnJvbUFQSVJlc3BvbnNlKHsgYXBpUmVzcG9uc2UsIGlzVmVydGV4QUksIH0pIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uKCk7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgY29uc3Qgb3AgPSBhcGlSZXNwb25zZTtcbiAgICAgICAgaWYgKGlzVmVydGV4QUkpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4JDEob3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldiQxKG9wKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuYXNzaWduKG9wZXJhdGlvbiwgcmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgdHVuaW5nIGpvYnMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSB7XG59XG4vKiogRW1wdHkgcmVzcG9uc2UgZm9yIGNhY2hlcy5kZWxldGUgbWV0aG9kLiAqL1xuY2xhc3MgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlIHtcbn1cbmNsYXNzIExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGxpc3QgZmlsZXMgbWV0aG9kLiAqL1xuY2xhc3MgTGlzdEZpbGVzUmVzcG9uc2Uge1xufVxuLyoqIFJlc3BvbnNlIGZvciB0aGUgY3JlYXRlIGZpbGUgbWV0aG9kLiAqL1xuY2xhc3MgQ3JlYXRlRmlsZVJlc3BvbnNlIHtcbn1cbi8qKiBSZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBmaWxlIG1ldGhvZC4gKi9cbmNsYXNzIERlbGV0ZUZpbGVSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgaW5saW5lZF9yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBgcmVzcG9uc2VgIHBhcmFtZXRlci4gKi9cbmNsYXNzIFNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlIHtcbn1cbi8qKiBDb25maWcgZm9yIGBpbmxpbmVkX2VtYmVkZGluZ19yZXNwb25zZXNgIHBhcmFtZXRlci4gKi9cbmNsYXNzIElubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSB7XG59XG4vKiogQ29uZmlnIGZvciBiYXRjaGVzLmxpc3QgcmV0dXJuIHZhbHVlLiAqL1xuY2xhc3MgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlIHtcbn1cbi8qKiBSZXByZXNlbnRzIGEgc2luZ2xlIHJlc3BvbnNlIGluIGEgcmVwbGF5LiAqL1xuY2xhc3MgUmVwbGF5UmVzcG9uc2Uge1xufVxuLyoqIEEgcmF3IHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgcmVwcmVzZW50cyB0aGUgYmFzZSBpbWFnZSB0byBlZGl0LCBwcm92aWRlZCBieSB0aGUgdXNlci5cbiAgSXQgY2FuIG9wdGlvbmFsbHkgYmUgcHJvdmlkZWQgaW4gYWRkaXRpb24gdG8gYSBtYXNrIHJlZmVyZW5jZSBpbWFnZSBvclxuICBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cbiAgICovXG5jbGFzcyBSYXdSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfUkFXJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBtYXNrIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGlzIGVuY2Fwc3VsYXRlcyBlaXRoZXIgYSBtYXNrIGltYWdlIHByb3ZpZGVkIGJ5IHRoZSB1c2VyIGFuZCBjb25maWdzIGZvclxuICB0aGUgdXNlciBwcm92aWRlZCBtYXNrLCBvciBvbmx5IGNvbmZpZyBwYXJhbWV0ZXJzIGZvciB0aGUgbW9kZWwgdG8gZ2VuZXJhdGVcbiAgYSBtYXNrLlxuXG4gIEEgbWFzayBpbWFnZSBpcyBhbiBpbWFnZSB3aG9zZSBub24temVybyB2YWx1ZXMgaW5kaWNhdGUgd2hlcmUgdG8gZWRpdCB0aGUgYmFzZVxuICBpbWFnZS4gSWYgdGhlIHVzZXIgcHJvdmlkZXMgYSBtYXNrIGltYWdlLCB0aGUgbWFzayBtdXN0IGJlIGluIHRoZSBzYW1lXG4gIGRpbWVuc2lvbnMgYXMgdGhlIHJhdyBpbWFnZS5cbiAgICovXG5jbGFzcyBNYXNrUmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX01BU0snLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIG1hc2tJbWFnZUNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWZlcmVuY2VJbWFnZUFQSTtcbiAgICB9XG59XG4vKiogQSBjb250cm9sIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGUgaW1hZ2Ugb2YgdGhlIGNvbnRyb2wgcmVmZXJlbmNlIGltYWdlIGlzIGVpdGhlciBhIGNvbnRyb2wgaW1hZ2UgcHJvdmlkZWRcbiAgYnkgdGhlIHVzZXIsIG9yIGEgcmVndWxhciBpbWFnZSB3aGljaCB0aGUgYmFja2VuZCB3aWxsIHVzZSB0byBnZW5lcmF0ZSBhXG4gIGNvbnRyb2wgaW1hZ2Ugb2YuIEluIHRoZSBjYXNlIG9mIHRoZSBsYXR0ZXIsIHRoZVxuICBlbmFibGVfY29udHJvbF9pbWFnZV9jb21wdXRhdGlvbiBmaWVsZCBpbiB0aGUgY29uZmlnIHNob3VsZCBiZSBzZXQgdG8gVHJ1ZS5cblxuICBBIGNvbnRyb2wgaW1hZ2UgaXMgYW4gaW1hZ2UgdGhhdCByZXByZXNlbnRzIGEgc2tldGNoIGltYWdlIG9mIGFyZWFzIGZvciB0aGVcbiAgbW9kZWwgdG8gZmlsbCBpbiBiYXNlZCBvbiB0aGUgcHJvbXB0LlxuICAgKi9cbmNsYXNzIENvbnRyb2xSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfQ09OVFJPTCcsXG4gICAgICAgICAgICByZWZlcmVuY2VJbWFnZTogdGhpcy5yZWZlcmVuY2VJbWFnZSxcbiAgICAgICAgICAgIHJlZmVyZW5jZUlkOiB0aGlzLnJlZmVyZW5jZUlkLFxuICAgICAgICAgICAgY29udHJvbEltYWdlQ29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBBIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuICBUaGlzIGVuY2Fwc3VsYXRlcyBhIHN0eWxlIHJlZmVyZW5jZSBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciwgYW5kXG4gIGFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN0eWxlIHJlZmVyZW5jZSBpbWFnZS5cblxuICBBIHJhdyByZWZlcmVuY2UgaW1hZ2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgYXMgYSBkZXN0aW5hdGlvbiBmb3IgdGhlIHN0eWxlIHRvXG4gIGJlIGFwcGxpZWQgdG8uXG4gICAqL1xuY2xhc3MgU3R5bGVSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyoqIEludGVybmFsIG1ldGhvZCB0byBjb252ZXJ0IHRvIFJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWwuICovXG4gICAgdG9SZWZlcmVuY2VJbWFnZUFQSSgpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlSW1hZ2VBUEkgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2VUeXBlOiAnUkVGRVJFTkNFX1RZUEVfU1RZTEUnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgICAgIHN0eWxlSW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgc3ViamVjdCByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgVGhpcyBlbmNhcHN1bGF0ZXMgYSBzdWJqZWN0IHJlZmVyZW5jZSBpbWFnZSBwcm92aWRlZCBieSB0aGUgdXNlciwgYW5kXG4gIGFkZGl0aW9uYWxseSBvcHRpb25hbCBjb25maWcgcGFyYW1ldGVycyBmb3IgdGhlIHN1YmplY3QgcmVmZXJlbmNlIGltYWdlLlxuXG4gIEEgcmF3IHJlZmVyZW5jZSBpbWFnZSBjYW4gYWxzbyBiZSBwcm92aWRlZCBhcyBhIGRlc3RpbmF0aW9uIGZvciB0aGUgc3ViamVjdCB0b1xuICBiZSBhcHBsaWVkIHRvLlxuICAgKi9cbmNsYXNzIFN1YmplY3RSZWZlcmVuY2VJbWFnZSB7XG4gICAgLyogSW50ZXJuYWwgbWV0aG9kIHRvIGNvbnZlcnQgdG8gUmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbC4gKi9cbiAgICB0b1JlZmVyZW5jZUltYWdlQVBJKCkge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbWFnZUFQSSA9IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZVR5cGU6ICdSRUZFUkVOQ0VfVFlQRV9TVUJKRUNUJyxcbiAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlOiB0aGlzLnJlZmVyZW5jZUltYWdlLFxuICAgICAgICAgICAgcmVmZXJlbmNlSWQ6IHRoaXMucmVmZXJlbmNlSWQsXG4gICAgICAgICAgICBzdWJqZWN0SW1hZ2VDb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUEk7XG4gICAgfVxufVxuLyoqIEEgY29udGVudCByZWZlcmVuY2UgaW1hZ2UuXG5cbiAgQSBjb250ZW50IHJlZmVyZW5jZSBpbWFnZSByZXByZXNlbnRzIGEgc3ViamVjdCB0byByZWZlcmVuY2UgKGV4LiBwZXJzb24sXG4gIHByb2R1Y3QsIGFuaW1hbCkgcHJvdmlkZWQgYnkgdGhlIHVzZXIuIEl0IGNhbiBvcHRpb25hbGx5IGJlIHByb3ZpZGVkIGluXG4gIGFkZGl0aW9uIHRvIGEgc3R5bGUgcmVmZXJlbmNlIGltYWdlIChleC4gYmFja2dyb3VuZCwgc3R5bGUgcmVmZXJlbmNlKS5cbiAgICovXG5jbGFzcyBDb250ZW50UmVmZXJlbmNlSW1hZ2Uge1xuICAgIC8qKiBJbnRlcm5hbCBtZXRob2QgdG8gY29udmVydCB0byBSZWZlcmVuY2VJbWFnZUFQSUludGVybmFsLiAqL1xuICAgIHRvUmVmZXJlbmNlSW1hZ2VBUEkoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUltYWdlQVBJID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlVHlwZTogJ1JFRkVSRU5DRV9UWVBFX0NPTlRFTlQnLFxuICAgICAgICAgICAgcmVmZXJlbmNlSW1hZ2U6IHRoaXMucmVmZXJlbmNlSW1hZ2UsXG4gICAgICAgICAgICByZWZlcmVuY2VJZDogdGhpcy5yZWZlcmVuY2VJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZUltYWdlQVBJO1xuICAgIH1cbn1cbi8qKiBSZXNwb25zZSBtZXNzYWdlIGZvciBBUEkgY2FsbC4gKi9cbmNsYXNzIExpdmVTZXJ2ZXJNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0IHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyBpbiB0aGUgcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCB0ZXh0XG4gICAgICogcGFydHMgd2lsbCBiZSByZXR1cm5lZCwgYW5kIGEgd2FybmluZyB3aWxsIGJlIGxvZ2dlZC5cbiAgICAgKi9cbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGxldCBhbnlUZXh0UGFydEZvdW5kID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG5vblRleHRQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9jID0gKF9iID0gKF9hID0gdGhpcy5zZXJ2ZXJDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubW9kZWxUdXJuKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucGFydHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSAhPT0gJ3RleHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkTmFtZSAhPT0gJ3Rob3VnaHQnICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9uVGV4dFBhcnRzLnB1c2goZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcnQudGhvdWdodCA9PT0gJ2Jvb2xlYW4nICYmIHBhcnQudGhvdWdodCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYW55VGV4dFBhcnRGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBwYXJ0LnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vblRleHRQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHRoZXJlIGFyZSBub24tdGV4dCBwYXJ0cyAke25vblRleHRQYXJ0c30gaW4gdGhlIHJlc3BvbnNlLCByZXR1cm5pbmcgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGV4dCBwYXJ0cy4gUGxlYXNlIHJlZmVyIHRvIHRoZSBub24gdGV4dCBwYXJ0cyBmb3IgYSBmdWxsIHJlc3BvbnNlIGZyb20gbW9kZWwuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFydC50ZXh0ID09PSAnJyBpcyBkaWZmZXJlbnQgZnJvbSBwYXJ0LnRleHQgaXMgbnVsbFxuICAgICAgICByZXR1cm4gYW55VGV4dFBhcnRGb3VuZCA/IHRleHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGlubGluZSBkYXRhIHBhcnRzIGZyb20gdGhlIHNlcnZlciBjb250ZW50IGlmIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIElmIHRoZXJlIGFyZSBub24taW5saW5lIGRhdGEgcGFydHMgaW4gdGhlXG4gICAgICogcmVzcG9uc2UsIHRoZSBjb25jYXRlbmF0aW9uIG9mIGFsbCBpbmxpbmUgZGF0YSBwYXJ0cyB3aWxsIGJlIHJldHVybmVkLCBhbmRcbiAgICAgKiBhIHdhcm5pbmcgd2lsbCBiZSBsb2dnZWQuXG4gICAgICovXG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBsZXQgZGF0YSA9ICcnO1xuICAgICAgICBjb25zdCBub25EYXRhUGFydHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIChfYyA9IChfYiA9IChfYSA9IHRoaXMuc2VydmVyQ29udGVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGVsVHVybikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBhcnRzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJ0KSkge1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgIT09ICdpbmxpbmVEYXRhJyAmJiBmaWVsZFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vbkRhdGFQYXJ0cy5wdXNoKGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnQuaW5saW5lRGF0YSAmJiB0eXBlb2YgcGFydC5pbmxpbmVEYXRhLmRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZGF0YSArPSBhdG9iKHBhcnQuaW5saW5lRGF0YS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uRGF0YVBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgdGhlcmUgYXJlIG5vbi1kYXRhIHBhcnRzICR7bm9uRGF0YVBhcnRzfSBpbiB0aGUgcmVzcG9uc2UsIHJldHVybmluZyBjb25jYXRlbmF0aW9uIG9mIGFsbCBkYXRhIHBhcnRzLiBQbGVhc2UgcmVmZXIgdG8gdGhlIG5vbiBkYXRhIHBhcnRzIGZvciBhIGZ1bGwgcmVzcG9uc2UgZnJvbSBtb2RlbC5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPiAwID8gYnRvYShkYXRhKSA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKiogQ2xpZW50IGdlbmVyYXRlZCByZXNwb25zZSB0byBhIGBUb29sQ2FsbGAgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLlxuXG4gIEluZGl2aWR1YWwgYEZ1bmN0aW9uUmVzcG9uc2VgIG9iamVjdHMgYXJlIG1hdGNoZWQgdG8gdGhlIHJlc3BlY3RpdmVcbiAgYEZ1bmN0aW9uQ2FsbGAgb2JqZWN0cyBieSB0aGUgYGlkYCBmaWVsZC5cblxuICBOb3RlIHRoYXQgaW4gdGhlIHVuYXJ5IGFuZCBzZXJ2ZXItc3RyZWFtaW5nIEdlbmVyYXRlQ29udGVudCBBUElzIGZ1bmN0aW9uXG4gIGNhbGxpbmcgaGFwcGVucyBieSBleGNoYW5naW5nIHRoZSBgQ29udGVudGAgcGFydHMsIHdoaWxlIGluIHRoZSBiaWRpXG4gIEdlbmVyYXRlQ29udGVudCBBUElzIGZ1bmN0aW9uIGNhbGxpbmcgaGFwcGVucyBvdmVyIHRoaXMgZGVkaWNhdGVkIHNldCBvZlxuICBtZXNzYWdlcy5cbiAgICovXG5jbGFzcyBMaXZlQ2xpZW50VG9vbFJlc3BvbnNlIHtcbn1cbi8qKiBQYXJhbWV0ZXJzIGZvciBzZW5kaW5nIHRvb2wgcmVzcG9uc2VzIHRvIHRoZSBsaXZlIEFQSS4gKi9cbmNsYXNzIExpdmVTZW5kVG9vbFJlc3BvbnNlUGFyYW1ldGVycyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKiBUb29sIHJlc3BvbnNlcyB0byBzZW5kIHRvIHRoZSBzZXNzaW9uLiAqL1xuICAgICAgICB0aGlzLmZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgfVxufVxuLyoqIFJlc3BvbnNlIG1lc3NhZ2UgZm9yIHRoZSBMaXZlTXVzaWNDbGllbnRNZXNzYWdlIGNhbGwuICovXG5jbGFzcyBMaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlIHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBhdWRpbyBjaHVuayBmcm9tIHRoZSBzZXJ2ZXIgY29udGVudCwgaWYgcHJlc2VudC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogSWYgdGhlcmUgYXJlIG5vIGF1ZGlvIGNodW5rcyBpbiB0aGUgcmVzcG9uc2UsIHVuZGVmaW5lZCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqL1xuICAgIGdldCBhdWRpb0NodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXJDb250ZW50ICYmXG4gICAgICAgICAgICB0aGlzLnNlcnZlckNvbnRlbnQuYXVkaW9DaHVua3MgJiZcbiAgICAgICAgICAgIHRoaXMuc2VydmVyQ29udGVudC5hdWRpb0NodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJ2ZXJDb250ZW50LmF1ZGlvQ2h1bmtzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiB0TW9kZWwoYXBpQ2xpZW50LCBtb2RlbCkge1xuICAgIGlmICghbW9kZWwgfHwgdHlwZW9mIG1vZGVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIGlmIChhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGlmIChtb2RlbC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzLycpIHx8XG4gICAgICAgICAgICBtb2RlbC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSB8fFxuICAgICAgICAgICAgbW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobW9kZWwuaW5kZXhPZignLycpID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbW9kZWwuc3BsaXQoJy8nLCAyKTtcbiAgICAgICAgICAgIHJldHVybiBgcHVibGlzaGVycy8ke3BhcnRzWzBdfS9tb2RlbHMvJHtwYXJ0c1sxXX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGBwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvJHttb2RlbH1gO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobW9kZWwuc3RhcnRzV2l0aCgnbW9kZWxzLycpIHx8IG1vZGVsLnN0YXJ0c1dpdGgoJ3R1bmVkTW9kZWxzLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYG1vZGVscy8ke21vZGVsfWA7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBtb2RlbCkge1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwoYXBpQ2xpZW50LCBtb2RlbCk7XG4gICAgaWYgKCF0cmFuc2Zvcm1lZE1vZGVsKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSAmJiBhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIC8vIHZlcnRleCBjYWNoZXMgb25seSBzdXBwb3J0IG1vZGVsIG5hbWUgc3RhcnQgd2l0aCBwcm9qZWN0cy5cbiAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2FwaUNsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2FwaUNsaWVudC5nZXRMb2NhdGlvbigpfS8ke3RyYW5zZm9ybWVkTW9kZWx9YDtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtZWRNb2RlbC5zdGFydHNXaXRoKCdtb2RlbHMvJykgJiYgYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICByZXR1cm4gYHByb2plY3RzLyR7YXBpQ2xpZW50LmdldFByb2plY3QoKX0vbG9jYXRpb25zLyR7YXBpQ2xpZW50LmdldExvY2F0aW9uKCl9L3B1Ymxpc2hlcnMvZ29vZ2xlLyR7dHJhbnNmb3JtZWRNb2RlbH1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkTW9kZWw7XG4gICAgfVxufVxuZnVuY3Rpb24gdEJsb2JzKGJsb2JzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYmxvYnMpKSB7XG4gICAgICAgIHJldHVybiBibG9icy5tYXAoKGJsb2IpID0+IHRCbG9iKGJsb2IpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbdEJsb2IoYmxvYnMpXTtcbiAgICB9XG59XG5mdW5jdGlvbiB0QmxvYihibG9iKSB7XG4gICAgaWYgKHR5cGVvZiBibG9iID09PSAnb2JqZWN0JyAmJiBibG9iICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBibG9iO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSBpbnB1dCBhcyBCbG9iLiBVbnN1cHBvcnRlZCBibG9iIHR5cGU6ICR7dHlwZW9mIGJsb2J9YCk7XG59XG5mdW5jdGlvbiB0SW1hZ2VCbG9iKGJsb2IpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJsb2IgPSB0QmxvYihibG9iKTtcbiAgICBpZiAodHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlICYmXG4gICAgICAgIHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZS5zdGFydHNXaXRoKCdpbWFnZS8nKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCbG9iO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1pbWUgdHlwZTogJHt0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGV9YCk7XG59XG5mdW5jdGlvbiB0QXVkaW9CbG9iKGJsb2IpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lZEJsb2IgPSB0QmxvYihibG9iKTtcbiAgICBpZiAodHJhbnNmb3JtZWRCbG9iLm1pbWVUeXBlICYmXG4gICAgICAgIHRyYW5zZm9ybWVkQmxvYi5taW1lVHlwZS5zdGFydHNXaXRoKCdhdWRpby8nKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCbG9iO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG1pbWUgdHlwZTogJHt0cmFuc2Zvcm1lZEJsb2IubWltZVR5cGV9YCk7XG59XG5mdW5jdGlvbiB0UGFydChvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFydFVuaW9uIGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gb3JpZ2luO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9yaWdpbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogb3JpZ2luIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydCB0eXBlOiAke3R5cGVvZiBvcmlnaW59YCk7XG59XG5mdW5jdGlvbiB0UGFydHMob3JpZ2luKSB7XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCB8fFxuICAgICAgICBvcmlnaW4gPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShvcmlnaW4pICYmIG9yaWdpbi5sZW5ndGggPT09IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUGFydExpc3RVbmlvbiBpcyByZXF1aXJlZCcpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBvcmlnaW4ubWFwKChpdGVtKSA9PiB0UGFydChpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBbdFBhcnQob3JpZ2luKV07XG59XG5mdW5jdGlvbiBfaXNDb250ZW50KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdwYXJ0cycgaW4gb3JpZ2luICYmXG4gICAgICAgIEFycmF5LmlzQXJyYXkob3JpZ2luLnBhcnRzKSk7XG59XG5mdW5jdGlvbiBfaXNGdW5jdGlvbkNhbGxQYXJ0KG9yaWdpbikge1xuICAgIHJldHVybiAob3JpZ2luICE9PSBudWxsICYmXG4gICAgICAgIG9yaWdpbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIHR5cGVvZiBvcmlnaW4gPT09ICdvYmplY3QnICYmXG4gICAgICAgICdmdW5jdGlvbkNhbGwnIGluIG9yaWdpbik7XG59XG5mdW5jdGlvbiBfaXNGdW5jdGlvblJlc3BvbnNlUGFydChvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIHRDb250ZW50KG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50VW5pb24gaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKF9pc0NvbnRlbnQob3JpZ2luKSkge1xuICAgICAgICAvLyBfaXNDb250ZW50IGlzIGEgdXRpbGl0eSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGVcbiAgICAgICAgLy8gb3JpZ2luIGlzIGEgQ29udGVudC5cbiAgICAgICAgcmV0dXJuIG9yaWdpbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICBwYXJ0czogdFBhcnRzKG9yaWdpbiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgb3JpZ2luKSB7XG4gICAgaWYgKCFvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJiBBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5mbGF0TWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdENvbnRlbnQoaXRlbSk7XG4gICAgICAgICAgICBpZiAoY29udGVudC5wYXJ0cyAmJlxuICAgICAgICAgICAgICAgIGNvbnRlbnQucGFydHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIGNvbnRlbnQucGFydHNbMF0udGV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb250ZW50LnBhcnRzWzBdLnRleHRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdENvbnRlbnQob3JpZ2luKTtcbiAgICAgICAgaWYgKGNvbnRlbnQucGFydHMgJiZcbiAgICAgICAgICAgIGNvbnRlbnQucGFydHMubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgY29udGVudC5wYXJ0c1swXS50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29udGVudC5wYXJ0c1swXS50ZXh0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbi5tYXAoKGl0ZW0pID0+IHRDb250ZW50KGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0Q29udGVudChvcmlnaW4pXTtcbn1cbmZ1bmN0aW9uIHRDb250ZW50cyhvcmlnaW4pIHtcbiAgICBpZiAob3JpZ2luID09PSBudWxsIHx8XG4gICAgICAgIG9yaWdpbiA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KG9yaWdpbikgJiYgb3JpZ2luLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb250ZW50cyBhcmUgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG9yaWdpbikpIHtcbiAgICAgICAgLy8gSWYgaXQncyBub3QgYW4gYXJyYXksIGl0J3MgYSBzaW5nbGUgY29udGVudCBvciBhIHNpbmdsZSBQYXJ0VW5pb24uXG4gICAgICAgIGlmIChfaXNGdW5jdGlvbkNhbGxQYXJ0KG9yaWdpbikgfHwgX2lzRnVuY3Rpb25SZXNwb25zZVBhcnQob3JpZ2luKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUbyBzcGVjaWZ5IGZ1bmN0aW9uQ2FsbCBvciBmdW5jdGlvblJlc3BvbnNlIHBhcnRzLCBwbGVhc2Ugd3JhcCB0aGVtIGluIGEgQ29udGVudCBvYmplY3QsIHNwZWNpZnlpbmcgdGhlIHJvbGUgZm9yIHRoZW0nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RDb250ZW50KG9yaWdpbildO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBhY2N1bXVsYXRlZFBhcnRzID0gW107XG4gICAgY29uc3QgaXNDb250ZW50QXJyYXkgPSBfaXNDb250ZW50KG9yaWdpblswXSk7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIG9yaWdpbikge1xuICAgICAgICBjb25zdCBpc0NvbnRlbnQgPSBfaXNDb250ZW50KGl0ZW0pO1xuICAgICAgICBpZiAoaXNDb250ZW50ICE9IGlzQ29udGVudEFycmF5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01peGluZyBDb250ZW50IGFuZCBQYXJ0cyBpcyBub3Qgc3VwcG9ydGVkLCBwbGVhc2UgZ3JvdXAgdGhlIHBhcnRzIGludG8gYSB0aGUgYXBwcm9wcmlhdGUgQ29udGVudCBvYmplY3RzIGFuZCBzcGVjaWZ5IHRoZSByb2xlcyBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGBpc0NvbnRlbnRgIGNvbnRhaW5zIHRoZSByZXN1bHQgb2YgX2lzQ29udGVudCwgd2hpY2ggaXMgYSB1dGlsaXR5XG4gICAgICAgICAgICAvLyBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiB0aGUgaXRlbSBpcyBhIENvbnRlbnQuXG4gICAgICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChfaXNGdW5jdGlvbkNhbGxQYXJ0KGl0ZW0pIHx8IF9pc0Z1bmN0aW9uUmVzcG9uc2VQYXJ0KGl0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvIHNwZWNpZnkgZnVuY3Rpb25DYWxsIG9yIGZ1bmN0aW9uUmVzcG9uc2UgcGFydHMsIHBsZWFzZSB3cmFwIHRoZW0sIGFuZCBhbnkgb3RoZXIgcGFydHMsIGluIENvbnRlbnQgb2JqZWN0cyBhcyBhcHByb3ByaWF0ZSwgc3BlY2lmeWluZyB0aGUgcm9sZSBmb3IgdGhlbScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWNjdW11bGF0ZWRQYXJ0cy5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNDb250ZW50QXJyYXkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goeyByb2xlOiAndXNlcicsIHBhcnRzOiB0UGFydHMoYWNjdW11bGF0ZWRQYXJ0cykgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKlxuVHJhbnNmb3JtIHRoZSB0eXBlIGZpZWxkIGZyb20gYW4gYXJyYXkgb2YgdHlwZXMgdG8gYW4gYXJyYXkgb2YgYW55T2YgZmllbGRzLlxuRXhhbXBsZTpcbiAge3R5cGU6IFsnU1RSSU5HJywgJ05VTUJFUiddfVxud2lsbCBiZSB0cmFuc2Zvcm1lZCB0b1xuICB7YW55T2Y6IFt7dHlwZTogJ1NUUklORyd9LCB7dHlwZTogJ05VTUJFUid9XX1cbiovXG5mdW5jdGlvbiBmbGF0dGVuVHlwZUFycmF5VG9BbnlPZih0eXBlTGlzdCwgcmVzdWx0aW5nU2NoZW1hKSB7XG4gICAgaWYgKHR5cGVMaXN0LmluY2x1ZGVzKCdudWxsJykpIHtcbiAgICAgICAgcmVzdWx0aW5nU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbGlzdFdpdGhvdXROdWxsID0gdHlwZUxpc3QuZmlsdGVyKCh0eXBlKSA9PiB0eXBlICE9PSAnbnVsbCcpO1xuICAgIGlmIChsaXN0V2l0aG91dE51bGwubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJlc3VsdGluZ1NjaGVtYVsndHlwZSddID0gT2JqZWN0LnZhbHVlcyhUeXBlKS5pbmNsdWRlcyhsaXN0V2l0aG91dE51bGxbMF0udG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgID8gbGlzdFdpdGhvdXROdWxsWzBdLnRvVXBwZXJDYXNlKClcbiAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVEO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdWx0aW5nU2NoZW1hWydhbnlPZiddID0gW107XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiBsaXN0V2l0aG91dE51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdGluZ1NjaGVtYVsnYW55T2YnXS5wdXNoKHtcbiAgICAgICAgICAgICAgICAndHlwZSc6IE9iamVjdC52YWx1ZXMoVHlwZSkuaW5jbHVkZXMoaS50b1VwcGVyQ2FzZSgpKVxuICAgICAgICAgICAgICAgICAgICA/IGkudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgICAgICA6IFR5cGUuVFlQRV9VTlNQRUNJRklFRCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvY2Vzc0pzb25TY2hlbWEoX2pzb25TY2hlbWEpIHtcbiAgICBjb25zdCBnZW5BSVNjaGVtYSA9IHt9O1xuICAgIGNvbnN0IHNjaGVtYUZpZWxkTmFtZXMgPSBbJ2l0ZW1zJ107XG4gICAgY29uc3QgbGlzdFNjaGVtYUZpZWxkTmFtZXMgPSBbJ2FueU9mJ107XG4gICAgY29uc3QgZGljdFNjaGVtYUZpZWxkTmFtZXMgPSBbJ3Byb3BlcnRpZXMnXTtcbiAgICBpZiAoX2pzb25TY2hlbWFbJ3R5cGUnXSAmJiBfanNvblNjaGVtYVsnYW55T2YnXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgYW5kIGFueU9mIGNhbm5vdCBiZSBib3RoIHBvcHVsYXRlZC4nKTtcbiAgICB9XG4gICAgLypcbiAgICBUaGlzIGlzIHRvIGhhbmRsZSB0aGUgbnVsbGFibGUgYXJyYXkgb3Igb2JqZWN0LiBUaGUgX2pzb25TY2hlbWEgd2lsbFxuICAgIGJlIGluIHRoZSBmb3JtYXQgb2Yge2FueU9mOiBbe3R5cGU6ICdudWxsJ30sIHt0eXBlOiAnb2JqZWN0J31dfS4gVGhlXG4gICAgbG9naWMgaXMgdG8gY2hlY2sgaWYgYW55T2YgaGFzIDIgZWxlbWVudHMgYW5kIG9uZSBvZiB0aGUgZWxlbWVudCBpcyBudWxsLFxuICAgIGlmIHNvLCB0aGUgYW55T2YgZmllbGQgaXMgdW5uZWNlc3NhcnksIHNvIHdlIG5lZWQgdG8gZ2V0IHJpZCBvZiB0aGUgYW55T2ZcbiAgICBmaWVsZCBhbmQgbWFrZSB0aGUgc2NoZW1hIG51bGxhYmxlLiBUaGVuIHVzZSB0aGUgb3RoZXIgZWxlbWVudCBhcyB0aGUgbmV3XG4gICAgX2pzb25TY2hlbWEgZm9yIHByb2Nlc3NpbmcuIFRoaXMgaXMgYmVjYXVzZSB0aGUgYmFja2VuZCBkb2Vzbid0IGhhdmUgYSBudWxsXG4gICAgdHlwZS5cbiAgICBUaGlzIGhhcyB0byBiZSBjaGVja2VkIGJlZm9yZSB3ZSBwcm9jZXNzIGFueSBvdGhlciBmaWVsZHMuXG4gICAgRm9yIGV4YW1wbGU6XG4gICAgICBjb25zdCBvYmplY3ROdWxsYWJsZSA9IHoub2JqZWN0KHtcbiAgICAgICAgbnVsbGFibGVBcnJheTogei5hcnJheSh6LnN0cmluZygpKS5udWxsYWJsZSgpLFxuICAgICAgfSk7XG4gICAgV2lsbCBoYXZlIHRoZSByYXcgX2pzb25TY2hlbWEgYXM6XG4gICAge1xuICAgICAgdHlwZTogJ09CSkVDVCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgbnVsbGFibGVBcnJheToge1xuICAgICAgICAgICAgIGFueU9mOiBbXG4gICAgICAgICAgICAgICAge3R5cGU6ICdudWxsJ30sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICAgICAgICAgIGl0ZW1zOiB7dHlwZTogJ3N0cmluZyd9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlcXVpcmVkOiBbICdudWxsYWJsZUFycmF5JyBdLFxuICAgIH1cbiAgICBXaWxsIHJlc3VsdCBpbiBmb2xsb3dpbmcgc2NoZW1hIGNvbXBhdGlibGUgd2l0aCBHZW1pbmkgQVBJOlxuICAgICAge1xuICAgICAgICB0eXBlOiAnT0JKRUNUJyxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICBudWxsYWJsZUFycmF5OiB7XG4gICAgICAgICAgICAgIG51bGxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICB0eXBlOiAnQVJSQVknLFxuICAgICAgICAgICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXF1aXJlZDogWyAnbnVsbGFibGVBcnJheScgXSxcbiAgICAgIH1cbiAgICAqL1xuICAgIGNvbnN0IGluY29taW5nQW55T2YgPSBfanNvblNjaGVtYVsnYW55T2YnXTtcbiAgICBpZiAoaW5jb21pbmdBbnlPZiAhPSBudWxsICYmIGluY29taW5nQW55T2YubGVuZ3RoID09IDIpIHtcbiAgICAgICAgaWYgKGluY29taW5nQW55T2ZbMF1bJ3R5cGUnXSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVsnbnVsbGFibGUnXSA9IHRydWU7XG4gICAgICAgICAgICBfanNvblNjaGVtYSA9IGluY29taW5nQW55T2ZbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5jb21pbmdBbnlPZlsxXVsndHlwZSddID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgIGdlbkFJU2NoZW1hWydudWxsYWJsZSddID0gdHJ1ZTtcbiAgICAgICAgICAgIF9qc29uU2NoZW1hID0gaW5jb21pbmdBbnlPZlswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoX2pzb25TY2hlbWFbJ3R5cGUnXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZsYXR0ZW5UeXBlQXJyYXlUb0FueU9mKF9qc29uU2NoZW1hWyd0eXBlJ10sIGdlbkFJU2NoZW1hKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhfanNvblNjaGVtYSkpIHtcbiAgICAgICAgLy8gU2tpcCBpZiB0aGUgZmllbGR2YWx1ZSBpcyB1bmRlZmluZWQgb3IgbnVsbC5cbiAgICAgICAgaWYgKGZpZWxkVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkTmFtZSA9PSAndHlwZScpIHtcbiAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3R5cGU6IG51bGwgY2FuIG5vdCBiZSB0aGUgb25seSBwb3NzaWJsZSB0eXBlIGZvciB0aGUgZmllbGQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIHR5cGUgZmllbGQgd2l0aCBhcnJheSBvZiB0eXBlcyBpbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdlbkFJU2NoZW1hWyd0eXBlJ10gPSBPYmplY3QudmFsdWVzKFR5cGUpLmluY2x1ZGVzKGZpZWxkVmFsdWUudG9VcHBlckNhc2UoKSlcbiAgICAgICAgICAgICAgICA/IGZpZWxkVmFsdWUudG9VcHBlckNhc2UoKVxuICAgICAgICAgICAgICAgIDogVHlwZS5UWVBFX1VOU1BFQ0lGSUVEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0pzb25TY2hlbWEoZmllbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGlzdFNjaGVtYUZpZWxkTmFtZXMuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgbGlzdFNjaGVtYUZpZWxkVmFsdWUgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1bJ3R5cGUnXSA9PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuQUlTY2hlbWFbJ251bGxhYmxlJ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdFNjaGVtYUZpZWxkVmFsdWUucHVzaChwcm9jZXNzSnNvblNjaGVtYShpdGVtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID1cbiAgICAgICAgICAgICAgICBsaXN0U2NoZW1hRmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaWN0U2NoZW1hRmllbGROYW1lcy5pbmNsdWRlcyhmaWVsZE5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaWN0U2NoZW1hRmllbGRWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkaWN0U2NoZW1hRmllbGRWYWx1ZVtrZXldID0gcHJvY2Vzc0pzb25TY2hlbWEodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2VuQUlTY2hlbWFbZmllbGROYW1lXSA9XG4gICAgICAgICAgICAgICAgZGljdFNjaGVtYUZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhZGRpdGlvbmFsUHJvcGVydGllcyBpcyBub3QgaW5jbHVkZWQgaW4gSlNPTlNjaGVtYSwgc2tpcHBpbmcgaXQuXG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSAnYWRkaXRpb25hbFByb3BlcnRpZXMnKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnZW5BSVNjaGVtYVtmaWVsZE5hbWVdID0gZmllbGRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2VuQUlTY2hlbWE7XG59XG4vLyB3ZSB0YWtlIHRoZSB1bmtub3duIGluIHRoZSBzY2hlbWEgZmllbGQgYmVjYXVzZSB3ZSB3YW50IGVuYWJsZSB1c2VyIHRvIHBhc3Ncbi8vIHRoZSBvdXRwdXQgb2YgbWFqb3Igc2NoZW1hIGRlY2xhcmF0aW9uIHRvb2xzIHdpdGhvdXQgY2FzdGluZy4gVG9vbHMgc3VjaCBhc1xuLy8gem9kVG9Kc29uU2NoZW1hLCB0eXBlYm94LCB6b2RUb0pzb25TY2hlbWEgZnVuY3Rpb24gY2FuIHJldHVybiBKc29uU2NoZW1hN1R5cGVcbi8vIG9yIG9iamVjdCwgc2VlIGRldGFpbHMgaW5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9TdGVmYW5UZXJkZWxsL3pvZC10by1qc29uLXNjaGVtYS9ibG9iLzcwNTI1ZWZlNTU1Y2QyMjY2OTFlMDkzZDE3MTM3MGEzYjEwOTIxZDEvc3JjL3pvZFRvSnNvblNjaGVtYS50cyNMN1xuLy8gdHlwZWJveCBjYW4gcmV0dXJuIHVua25vd24sIHNlZSBkZXRhaWxzIGluXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc2luY2xhaXJ6eDgxL3R5cGVib3gvYmxvYi81YTU0MzE0MzlmN2Q1Y2E2YjQ5NGQwZDE4ZmJmZDdiMWEzNTZkNjdjL3NyYy90eXBlL2NyZWF0ZS90eXBlLnRzI0wzNVxuLy8gTm90ZTogcHJvcGVyIGpzb24gc2NoZW1hcyB3aXRoIHRoZSAkc2NoZW1hIGZpZWxkIHNldCBuZXZlciBhcnJpdmUgdG8gdGhpc1xuLy8gdHJhbnNmb3JtZXIuIFNjaGVtYXMgd2l0aCAkc2NoZW1hIGFyZSByb3V0ZWQgdG8gdGhlIGVxdWl2YWxlbnQgQVBJIGpzb25cbi8vIHNjaGVtYSBmaWVsZC5cbmZ1bmN0aW9uIHRTY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIHByb2Nlc3NKc29uU2NoZW1hKHNjaGVtYSk7XG59XG5mdW5jdGlvbiB0U3BlZWNoQ29uZmlnKHNwZWVjaENvbmZpZykge1xuICAgIGlmICh0eXBlb2Ygc3BlZWNoQ29uZmlnID09PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gc3BlZWNoQ29uZmlnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2Ygc3BlZWNoQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdm9pY2VDb25maWc6IHtcbiAgICAgICAgICAgICAgICBwcmVidWlsdFZvaWNlQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIHZvaWNlTmFtZTogc3BlZWNoQ29uZmlnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzcGVlY2hDb25maWcgdHlwZTogJHt0eXBlb2Ygc3BlZWNoQ29uZmlnfWApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRMaXZlU3BlZWNoQ29uZmlnKHNwZWVjaENvbmZpZykge1xuICAgIGlmICgnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnIGluIHNwZWVjaENvbmZpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGxpdmUgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gc3BlZWNoQ29uZmlnO1xufVxuZnVuY3Rpb24gdFRvb2wodG9vbCkge1xuICAgIGlmICh0b29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiBvZiB0b29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKSB7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhmdW5jdGlvbkRlY2xhcmF0aW9uLnBhcmFtZXRlcnMpLmluY2x1ZGVzKCckc2NoZW1hJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzID0gcHJvY2Vzc0pzb25TY2hlbWEoZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzSnNvblNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzSnNvblNjaGVtYSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbi5wYXJhbWV0ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZ1bmN0aW9uRGVjbGFyYXRpb24ucGFyYW1ldGVycztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlKS5pbmNsdWRlcygnJHNjaGVtYScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2UgPSBwcm9jZXNzSnNvblNjaGVtYShmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZnVuY3Rpb25EZWNsYXJhdGlvbi5yZXNwb25zZUpzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2VKc29uU2NoZW1hID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbkRlY2xhcmF0aW9uLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvb2w7XG59XG5mdW5jdGlvbiB0VG9vbHModG9vbHMpIHtcbiAgICAvLyBDaGVjayBpZiB0aGUgaW5jb21pbmcgdHlwZSBpcyBkZWZpbmVkLlxuICAgIGlmICh0b29scyA9PT0gdW5kZWZpbmVkIHx8IHRvb2xzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9vbHMgaXMgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRvb2xzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGFuIGFycmF5IG9mIFRvb2xzJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdG9vbCBvZiB0b29scykge1xuICAgICAgICByZXN1bHQucHVzaCh0b29sKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogUHJlcGVuZHMgcmVzb3VyY2UgbmFtZSB3aXRoIHByb2plY3QsIGxvY2F0aW9uLCByZXNvdXJjZV9wcmVmaXggaWYgbmVlZGVkLlxuICpcbiAqIEBwYXJhbSBjbGllbnQgVGhlIEFQSSBjbGllbnQuXG4gKiBAcGFyYW0gcmVzb3VyY2VOYW1lIFRoZSByZXNvdXJjZSBuYW1lLlxuICogQHBhcmFtIHJlc291cmNlUHJlZml4IFRoZSByZXNvdXJjZSBwcmVmaXguXG4gKiBAcGFyYW0gc3BsaXRzQWZ0ZXJQcmVmaXggVGhlIG51bWJlciBvZiBzcGxpdHMgYWZ0ZXIgdGhlIHByZWZpeC5cbiAqIEByZXR1cm5zIFRoZSBjb21wbGV0ZWQgcmVzb3VyY2UgbmFtZS5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAnMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IFRydWVcbiAqIGNsaWVudC5wcm9qZWN0ID0gJ2JhcidcbiAqIGNsaWVudC5sb2NhdGlvbiA9ICd1cy13ZXN0MSdcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJuczogJ3Byb2plY3RzL2Jhci9sb2NhdGlvbnMvdXMtd2VzdDEvY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJ3Byb2plY3RzL2Zvby9sb2NhdGlvbnMvdXMtY2VudHJhbDEvY2FjaGVkQ29udGVudHMvMTIzJ1xuICogcmVzb3VyY2VfcHJlZml4ID0gJ2NhY2hlZENvbnRlbnRzJ1xuICogc3BsaXRzX2FmdGVyX3ByZWZpeCA9IDFcbiAqIGNsaWVudC52ZXJ0ZXhhaSA9IFRydWVcbiAqIGNsaWVudC5wcm9qZWN0ID0gJ2JhcidcbiAqIGNsaWVudC5sb2NhdGlvbiA9ICd1cy13ZXN0MSdcbiAqIF9yZXNvdXJjZV9uYW1lKGNsaWVudCwgcmVzb3VyY2VfbmFtZSwgcmVzb3VyY2VfcHJlZml4LCBzcGxpdHNfYWZ0ZXJfcHJlZml4KVxuICogcmV0dXJuczogJ3Byb2plY3RzL2Zvby9sb2NhdGlvbnMvdXMtY2VudHJhbDEvY2FjaGVkQ29udGVudHMvMTIzJ1xuICogYGBgXG4gKlxuICogYGBgXG4gKiByZXNvdXJjZV9uYW1lID0gJzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBGYWxzZVxuICogX3Jlc291cmNlX25hbWUoY2xpZW50LCByZXNvdXJjZV9uYW1lLCByZXNvdXJjZV9wcmVmaXgsIHNwbGl0c19hZnRlcl9wcmVmaXgpXG4gKiByZXR1cm5zICdjYWNoZWRDb250ZW50cy8xMjMnXG4gKiBgYGBcbiAqXG4gKiBgYGBcbiAqIHJlc291cmNlX25hbWUgPSAnc29tZS93cm9uZy9jYWNoZWRDb250ZW50cy9yZXNvdXJjZS9uYW1lLzEyMydcbiAqIHJlc291cmNlX3ByZWZpeCA9ICdjYWNoZWRDb250ZW50cydcbiAqIHNwbGl0c19hZnRlcl9wcmVmaXggPSAxXG4gKiBjbGllbnQudmVydGV4YWkgPSBGYWxzZVxuICogIyBjbGllbnQudmVydGV4YWkgPSBUcnVlXG4gKiBfcmVzb3VyY2VfbmFtZShjbGllbnQsIHJlc291cmNlX25hbWUsIHJlc291cmNlX3ByZWZpeCwgc3BsaXRzX2FmdGVyX3ByZWZpeClcbiAqIC0+ICdzb21lL3dyb25nL3Jlc291cmNlL25hbWUvMTIzJ1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHJlc291cmNlTmFtZShjbGllbnQsIHJlc291cmNlTmFtZSwgcmVzb3VyY2VQcmVmaXgsIHNwbGl0c0FmdGVyUHJlZml4ID0gMSkge1xuICAgIGNvbnN0IHNob3VsZEFwcGVuZFByZWZpeCA9ICFyZXNvdXJjZU5hbWUuc3RhcnRzV2l0aChgJHtyZXNvdXJjZVByZWZpeH0vYCkgJiZcbiAgICAgICAgcmVzb3VyY2VOYW1lLnNwbGl0KCcvJykubGVuZ3RoID09PSBzcGxpdHNBZnRlclByZWZpeDtcbiAgICBpZiAoY2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAocmVzb3VyY2VOYW1lLnN0YXJ0c1dpdGgoJ3Byb2plY3RzLycpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb3VyY2VOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKCdsb2NhdGlvbnMvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBgcHJvamVjdHMvJHtjbGllbnQuZ2V0UHJvamVjdCgpfS8ke3Jlc291cmNlTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc291cmNlTmFtZS5zdGFydHNXaXRoKGAke3Jlc291cmNlUHJlZml4fS9gKSkge1xuICAgICAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2NsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2NsaWVudC5nZXRMb2NhdGlvbigpfS8ke3Jlc291cmNlTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNob3VsZEFwcGVuZFByZWZpeCkge1xuICAgICAgICAgICAgcmV0dXJuIGBwcm9qZWN0cy8ke2NsaWVudC5nZXRQcm9qZWN0KCl9L2xvY2F0aW9ucy8ke2NsaWVudC5nZXRMb2NhdGlvbigpfS8ke3Jlc291cmNlUHJlZml4fS8ke3Jlc291cmNlTmFtZX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2hvdWxkQXBwZW5kUHJlZml4KSB7XG4gICAgICAgIHJldHVybiBgJHtyZXNvdXJjZVByZWZpeH0vJHtyZXNvdXJjZU5hbWV9YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc291cmNlTmFtZTtcbn1cbmZ1bmN0aW9uIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIG5hbWUpIHtcbiAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbmFtZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgfVxuICAgIHJldHVybiByZXNvdXJjZU5hbWUoYXBpQ2xpZW50LCBuYW1lLCAnY2FjaGVkQ29udGVudHMnKTtcbn1cbmZ1bmN0aW9uIHRUdW5pbmdKb2JTdGF0dXMoc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSAnU1RBVEVfVU5TUEVDSUZJRUQnOlxuICAgICAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfVU5TUEVDSUZJRUQnO1xuICAgICAgICBjYXNlICdDUkVBVElORyc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9SVU5OSU5HJztcbiAgICAgICAgY2FzZSAnQUNUSVZFJzpcbiAgICAgICAgICAgIHJldHVybiAnSk9CX1NUQVRFX1NVQ0NFRURFRCc7XG4gICAgICAgIGNhc2UgJ0ZBSUxFRCc6XG4gICAgICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9GQUlMRUQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHN0YXR1cztcbiAgICB9XG59XG5mdW5jdGlvbiB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpIHtcbiAgICByZXR1cm4gdEJ5dGVzJDEoZnJvbUltYWdlQnl0ZXMpO1xufVxuZnVuY3Rpb24gX2lzRmlsZShvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnbmFtZScgaW4gb3JpZ2luKTtcbn1cbmZ1bmN0aW9uIGlzR2VuZXJhdGVkVmlkZW8ob3JpZ2luKSB7XG4gICAgcmV0dXJuIChvcmlnaW4gIT09IG51bGwgJiZcbiAgICAgICAgb3JpZ2luICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgdHlwZW9mIG9yaWdpbiA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJ3ZpZGVvJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gaXNWaWRlbyhvcmlnaW4pIHtcbiAgICByZXR1cm4gKG9yaWdpbiAhPT0gbnVsbCAmJlxuICAgICAgICBvcmlnaW4gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndXJpJyBpbiBvcmlnaW4pO1xufVxuZnVuY3Rpb24gdEZpbGVOYW1lKGZyb21OYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBuYW1lO1xuICAgIGlmIChfaXNGaWxlKGZyb21OYW1lKSkge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWUubmFtZTtcbiAgICB9XG4gICAgaWYgKGlzVmlkZW8oZnJvbU5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSBmcm9tTmFtZS51cmk7XG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzR2VuZXJhdGVkVmlkZW8oZnJvbU5hbWUpKSB7XG4gICAgICAgIG5hbWUgPSAoX2EgPSBmcm9tTmFtZS52aWRlbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVyaTtcbiAgICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGZyb21OYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBuYW1lID0gZnJvbU5hbWU7XG4gICAgfVxuICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZXh0cmFjdCBmaWxlIG5hbWUgZnJvbSB0aGUgcHJvdmlkZWQgaW5wdXQuJyk7XG4gICAgfVxuICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgY29uc3Qgc3VmZml4ID0gbmFtZS5zcGxpdCgnZmlsZXMvJylbMV07XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3VmZml4Lm1hdGNoKC9bYS16MC05XSsvKTtcbiAgICAgICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBleHRyYWN0IGZpbGUgbmFtZSBmcm9tIFVSSSAke25hbWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG1hdGNoWzBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChuYW1lLnN0YXJ0c1dpdGgoJ2ZpbGVzLycpKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnNwbGl0KCdmaWxlcy8nKVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiB0TW9kZWxzVXJsKGFwaUNsaWVudCwgYmFzZU1vZGVscykge1xuICAgIGxldCByZXM7XG4gICAgaWYgKGFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgcmVzID0gYmFzZU1vZGVscyA/ICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMnIDogJ21vZGVscyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXMgPSBiYXNlTW9kZWxzID8gJ21vZGVscycgOiAndHVuZWRNb2RlbHMnO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gdEV4dHJhY3RNb2RlbHMocmVzcG9uc2UpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbJ21vZGVscycsICd0dW5lZE1vZGVscycsICdwdWJsaXNoZXJNb2RlbHMnXSkge1xuICAgICAgICBpZiAoaGFzRmllbGQocmVzcG9uc2UsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbmZ1bmN0aW9uIGhhc0ZpZWxkKGRhdGEsIGZpZWxkTmFtZSkge1xuICAgIHJldHVybiBkYXRhICE9PSBudWxsICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiBmaWVsZE5hbWUgaW4gZGF0YTtcbn1cbmZ1bmN0aW9uIG1jcFRvR2VtaW5pVG9vbChtY3BUb29sLCBjb25maWcgPSB7fSkge1xuICAgIGNvbnN0IG1jcFRvb2xTY2hlbWEgPSBtY3BUb29sO1xuICAgIGNvbnN0IGZ1bmN0aW9uRGVjbGFyYXRpb24gPSB7XG4gICAgICAgIG5hbWU6IG1jcFRvb2xTY2hlbWFbJ25hbWUnXSxcbiAgICAgICAgZGVzY3JpcHRpb246IG1jcFRvb2xTY2hlbWFbJ2Rlc2NyaXB0aW9uJ10sXG4gICAgICAgIHBhcmFtZXRlcnNKc29uU2NoZW1hOiBtY3BUb29sU2NoZW1hWydpbnB1dFNjaGVtYSddLFxuICAgIH07XG4gICAgaWYgKG1jcFRvb2xTY2hlbWFbJ291dHB1dFNjaGVtYSddKSB7XG4gICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb25bJ3Jlc3BvbnNlSnNvblNjaGVtYSddID0gbWNwVG9vbFNjaGVtYVsnb3V0cHV0U2NoZW1hJ107XG4gICAgfVxuICAgIGlmIChjb25maWcuYmVoYXZpb3IpIHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvblsnYmVoYXZpb3InXSA9IGNvbmZpZy5iZWhhdmlvcjtcbiAgICB9XG4gICAgY29uc3QgZ2VtaW5pVG9vbCA9IHtcbiAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgICAgIGZ1bmN0aW9uRGVjbGFyYXRpb24sXG4gICAgICAgIF0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2VtaW5pVG9vbDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBsaXN0IG9mIE1DUCB0b29scyB0byBhIHNpbmdsZSBHZW1pbmkgdG9vbCB3aXRoIGEgbGlzdCBvZiBmdW5jdGlvblxuICogZGVjbGFyYXRpb25zLlxuICovXG5mdW5jdGlvbiBtY3BUb29sc1RvR2VtaW5pVG9vbChtY3BUb29scywgY29uZmlnID0ge30pIHtcbiAgICBjb25zdCBmdW5jdGlvbkRlY2xhcmF0aW9ucyA9IFtdO1xuICAgIGNvbnN0IHRvb2xOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IG1jcFRvb2wgb2YgbWNwVG9vbHMpIHtcbiAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgIGlmICh0b29sTmFtZXMuaGFzKG1jcFRvb2xOYW1lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZnVuY3Rpb24gbmFtZSAke21jcFRvb2xOYW1lfSBmb3VuZCBpbiBNQ1AgdG9vbHMuIFBsZWFzZSBlbnN1cmUgZnVuY3Rpb24gbmFtZXMgYXJlIHVuaXF1ZS5gKTtcbiAgICAgICAgfVxuICAgICAgICB0b29sTmFtZXMuYWRkKG1jcFRvb2xOYW1lKTtcbiAgICAgICAgY29uc3QgZ2VtaW5pVG9vbCA9IG1jcFRvR2VtaW5pVG9vbChtY3BUb29sLCBjb25maWcpO1xuICAgICAgICBpZiAoZ2VtaW5pVG9vbC5mdW5jdGlvbkRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAgZnVuY3Rpb25EZWNsYXJhdGlvbnMucHVzaCguLi5nZW1pbmlUb29sLmZ1bmN0aW9uRGVjbGFyYXRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmdW5jdGlvbkRlY2xhcmF0aW9uczogZnVuY3Rpb25EZWNsYXJhdGlvbnMgfTtcbn1cbi8vIFRyYW5zZm9ybXMgYSBzb3VyY2UgaW5wdXQgaW50byBhIEJhdGNoSm9iU291cmNlIG9iamVjdCB3aXRoIHZhbGlkYXRpb24uXG5mdW5jdGlvbiB0QmF0Y2hKb2JTb3VyY2UoY2xpZW50LCBzcmMpIHtcbiAgICBsZXQgc291cmNlT2JqO1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoY2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKCdnczovLycpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlT2JqID0geyBmb3JtYXQ6ICdqc29ubCcsIGdjc1VyaTogW3NyY10gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNyYy5zdGFydHNXaXRoKCdicTovLycpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlT2JqID0geyBmb3JtYXQ6ICdiaWdxdWVyeScsIGJpZ3F1ZXJ5VXJpOiBzcmMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgc3RyaW5nIHNvdXJjZSBmb3IgVmVydGV4IEFJOiAke3NyY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE1MREVWXG4gICAgICAgICAgICBpZiAoc3JjLnN0YXJ0c1dpdGgoJ2ZpbGVzLycpKSB7XG4gICAgICAgICAgICAgICAgc291cmNlT2JqID0geyBmaWxlTmFtZTogc3JjIH07IC8vIERlZmF1bHQgdG8gZmlsZU5hbWUgZm9yIHN0cmluZyBpbnB1dFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBzdHJpbmcgc291cmNlIGZvciBHZW1pbmkgQVBJOiAke3NyY31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgaWYgKGNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5saW5lZFJlcXVlc3RbXSBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2VPYmogPSB7IGlubGluZWRSZXF1ZXN0czogc3JjIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBJdCdzIGFscmVhZHkgYSBCYXRjaEpvYlNvdXJjZSBvYmplY3RcbiAgICAgICAgc291cmNlT2JqID0gc3JjO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0aW9uIGxvZ2ljXG4gICAgY29uc3QgdmVydGV4U291cmNlc0NvdW50ID0gW3NvdXJjZU9iai5nY3NVcmksIHNvdXJjZU9iai5iaWdxdWVyeVVyaV0uZmlsdGVyKEJvb2xlYW4pLmxlbmd0aDtcbiAgICBjb25zdCBtbGRldlNvdXJjZXNDb3VudCA9IFtcbiAgICAgICAgc291cmNlT2JqLmlubGluZWRSZXF1ZXN0cyxcbiAgICAgICAgc291cmNlT2JqLmZpbGVOYW1lLFxuICAgIF0uZmlsdGVyKEJvb2xlYW4pLmxlbmd0aDtcbiAgICBpZiAoY2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBpZiAobWxkZXZTb3VyY2VzQ291bnQgPiAwIHx8IHZlcnRleFNvdXJjZXNDb3VudCAhPT0gMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeGFjdGx5IG9uZSBvZiBgZ2NzVXJpYCBvciBgYmlncXVlcnlVcmlgIG11c3QgYmUgc2V0IGZvciBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE1MREVWXG4gICAgICAgIGlmICh2ZXJ0ZXhTb3VyY2VzQ291bnQgPiAwIHx8IG1sZGV2U291cmNlc0NvdW50ICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4YWN0bHkgb25lIG9mIGBpbmxpbmVkUmVxdWVzdHNgLCBgZmlsZU5hbWVgLCAnICtcbiAgICAgICAgICAgICAgICAnbXVzdCBiZSBzZXQgZm9yIEdlbWluaSBBUEkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZU9iajtcbn1cbmZ1bmN0aW9uIHRCYXRjaEpvYkRlc3RpbmF0aW9uKGRlc3QpIHtcbiAgICBpZiAodHlwZW9mIGRlc3QgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICBjb25zdCBkZXN0U3RyaW5nID0gZGVzdDtcbiAgICBpZiAoZGVzdFN0cmluZy5zdGFydHNXaXRoKCdnczovLycpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6ICdqc29ubCcsXG4gICAgICAgICAgICBnY3NVcmk6IGRlc3RTdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlc3RTdHJpbmcuc3RhcnRzV2l0aCgnYnE6Ly8nKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiAnYmlncXVlcnknLFxuICAgICAgICAgICAgYmlncXVlcnlVcmk6IGRlc3RTdHJpbmcsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRlc3RpbmF0aW9uOiAke2Rlc3RTdHJpbmd9YCk7XG4gICAgfVxufVxuZnVuY3Rpb24gdFJlY3ZCYXRjaEpvYkRlc3RpbmF0aW9uKGRlc3QpIHtcbiAgICAvLyBFbnN1cmUgZGVzdCBpcyBhIG5vbi1udWxsIG9iamVjdCBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICBpZiAodHlwZW9mIGRlc3QgIT09ICdvYmplY3QnIHx8IGRlc3QgPT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIG5vdCBhbiBvYmplY3QsIGl0IGNhbm5vdCBiZSBhIHZhbGlkIEJhdGNoSm9iRGVzdGluYXRpb25cbiAgICAgICAgLy8gYmFzZWQgb24gdGhlIG9wZXJhdGlvbnMgcGVyZm9ybWVkLiBSZXR1cm4gaXQgY2FzdCwgb3IgaGFuZGxlIGFzIGFuIGVycm9yLlxuICAgICAgICAvLyBDYXN0aW5nIGFuIGVtcHR5IG9iamVjdCBtaWdodCBiZSBhIHNhZmUgZGVmYXVsdC5cbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvLyBDYXN0IHRvIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHRvIGFsbG93IHN0cmluZyBwcm9wZXJ0eSBhY2Nlc3MuXG4gICAgY29uc3Qgb2JqID0gZGVzdDtcbiAgICAvLyBTYWZlbHkgYWNjZXNzIG5lc3RlZCBwcm9wZXJ0aWVzLlxuICAgIGNvbnN0IGlubGluZVJlc3BvbnNlc1ZhbCA9IG9ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgIGlmICh0eXBlb2YgaW5saW5lUmVzcG9uc2VzVmFsICE9PSAnb2JqZWN0JyB8fCBpbmxpbmVSZXNwb25zZXNWYWwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIGNvbnN0IGlubGluZVJlc3BvbnNlc09iaiA9IGlubGluZVJlc3BvbnNlc1ZhbDtcbiAgICBjb25zdCByZXNwb25zZXNBcnJheSA9IGlubGluZVJlc3BvbnNlc09ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShyZXNwb25zZXNBcnJheSkgfHwgcmVzcG9uc2VzQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiBhbnkgcmVzcG9uc2UgaGFzIHRoZSAnZW1iZWRkaW5nJyBwcm9wZXJ0eS5cbiAgICBsZXQgaGFzRW1iZWRkaW5nID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCByZXNwb25zZUl0ZW0gb2YgcmVzcG9uc2VzQXJyYXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZUl0ZW0gIT09ICdvYmplY3QnIHx8IHJlc3BvbnNlSXRlbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzcG9uc2VJdGVtT2JqID0gcmVzcG9uc2VJdGVtO1xuICAgICAgICBjb25zdCByZXNwb25zZVZhbCA9IHJlc3BvbnNlSXRlbU9ialsncmVzcG9uc2UnXTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNwb25zZVZhbCAhPT0gJ29iamVjdCcgfHwgcmVzcG9uc2VWYWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlT2JqID0gcmVzcG9uc2VWYWw7XG4gICAgICAgIC8vIENoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIHRoZSAnZW1iZWRkaW5nJyBrZXkuXG4gICAgICAgIGlmIChyZXNwb25zZU9ialsnZW1iZWRkaW5nJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaGFzRW1iZWRkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBlcmZvcm0gdGhlIHRyYW5zZm9ybWF0aW9uIGlmIGFuIGVtYmVkZGluZyB3YXMgZm91bmQuXG4gICAgaWYgKGhhc0VtYmVkZGluZykge1xuICAgICAgICBvYmpbJ2lubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMnXSA9IG9ialsnaW5saW5lZFJlc3BvbnNlcyddO1xuICAgICAgICBkZWxldGUgb2JqWydpbmxpbmVkUmVzcG9uc2VzJ107XG4gICAgfVxuICAgIC8vIENhc3QgdGhlIChwb3RlbnRpYWxseSkgbW9kaWZpZWQgb2JqZWN0IHRvIHRoZSB0YXJnZXQgdHlwZS5cbiAgICByZXR1cm4gZGVzdDtcbn1cbmZ1bmN0aW9uIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBuYW1lKSB7XG4gICAgY29uc3QgbmFtZVN0cmluZyA9IG5hbWU7XG4gICAgaWYgKCFhcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgIGNvbnN0IG1sZGV2UGF0dGVybiA9IC9iYXRjaGVzXFwvW14vXSskLztcbiAgICAgICAgaWYgKG1sZGV2UGF0dGVybi50ZXN0KG5hbWVTdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZVN0cmluZy5zcGxpdCgnLycpLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGJhdGNoIGpvYiBuYW1lOiAke25hbWVTdHJpbmd9LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZlcnRleFBhdHRlcm4gPSAvXnByb2plY3RzXFwvW14vXStcXC9sb2NhdGlvbnNcXC9bXi9dK1xcL2JhdGNoUHJlZGljdGlvbkpvYnNcXC9bXi9dKyQvO1xuICAgIGlmICh2ZXJ0ZXhQYXR0ZXJuLnRlc3QobmFtZVN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVTdHJpbmcuc3BsaXQoJy8nKS5wb3AoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoL15cXGQrJC8udGVzdChuYW1lU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gbmFtZVN0cmluZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBiYXRjaCBqb2IgbmFtZTogJHtuYW1lU3RyaW5nfS5gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0Sm9iU3RhdGUoc3RhdGUpIHtcbiAgICBjb25zdCBzdGF0ZVN0cmluZyA9IHN0YXRlO1xuICAgIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX1VOU1BFQ0lGSUVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9VTlNQRUNJRklFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfUEVORElORycpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUEVORElORyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfUlVOTklORycpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfUlVOTklORyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfU1VDQ0VFREVEJykge1xuICAgICAgICByZXR1cm4gJ0pPQl9TVEFURV9TVUNDRUVERUQnO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdGF0ZVN0cmluZyA9PT0gJ0JBVENIX1NUQVRFX0ZBSUxFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRkFJTEVEJztcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RhdGVTdHJpbmcgPT09ICdCQVRDSF9TVEFURV9DQU5DRUxMRUQnKSB7XG4gICAgICAgIHJldHVybiAnSk9CX1NUQVRFX0NBTkNFTExFRCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXRlU3RyaW5nID09PSAnQkFUQ0hfU1RBVEVfRVhQSVJFRCcpIHtcbiAgICAgICAgcmV0dXJuICdKT0JfU1RBVEVfRVhQSVJFRCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGVTdHJpbmc7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VzRmlsZSddKTtcbiAgICBpZiAoZnJvbUZpbGVOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZU5hbWUnXSwgZnJvbUZpbGVOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZWRSZXNwb25zZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVzcG9uc2VzJyxcbiAgICAgICAgJ2lubGluZWRSZXNwb25zZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlc3BvbnNlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tSW5saW5lZFJlc3BvbnNlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmxpbmVkUmVzcG9uc2VGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVkUmVzcG9uc2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcycsXG4gICAgICAgICdpbmxpbmVkUmVzcG9uc2VzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUlubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lZEVtYmVkQ29udGVudFJlc3BvbnNlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYkRlc3RpbmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcmVkaWN0aW9uc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2djc0Rlc3RpbmF0aW9uJyxcbiAgICAgICAgJ291dHB1dFVyaVByZWZpeCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLFxuICAgICAgICAnb3V0cHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWRpY3Rpb25zRm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NEZXN0aW5hdGlvbicsICdvdXRwdXRVcmlQcmVmaXgnXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5RGVzdGluYXRpb24nLCAnb3V0cHV0VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlTmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRSZXNwb25zZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lubGluZWRSZXNwb25zZXMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzJ10pICE9PVxuICAgICAgICB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2Rpc3BsYXlOYW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YScsICdzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2NyZWF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ2VuZFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21ldGFkYXRhJyxcbiAgICAgICAgJ3VwZGF0ZVRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJywgJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0YWRhdGEnLCAnb3V0cHV0J10pO1xuICAgIGlmIChmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc3QnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvbkZyb21NbGRldih0UmVjdkJhdGNoSm9iRGVzdGluYXRpb24oZnJvbURlc3QpKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJhdGNoSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdEpvYlN0YXRlKGZyb21TdGF0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBqb2JFcnJvckZyb21WZXJ0ZXgoZnJvbUVycm9yKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5wdXRDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcmMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcmMnXSwgYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4KGZyb21TcmMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc3QgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dENvbmZpZyddKTtcbiAgICBpZiAoZnJvbURlc3QgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXN0J10sIGJhdGNoSm9iRGVzdGluYXRpb25Gcm9tVmVydGV4KHRSZWN2QmF0Y2hKb2JEZXN0aW5hdGlvbihmcm9tRGVzdCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luc3RhbmNlc0Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzU291cmNlJywgJ3VyaXMnXSk7XG4gICAgaWYgKGZyb21HY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnY3NVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JpZ3F1ZXJ5U291cmNlJyxcbiAgICAgICAgJ2lucHV0VXJpJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJpZ3F1ZXJ5VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlncXVlcnlVcmknXSwgZnJvbUJpZ3F1ZXJ5VXJpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ3F1ZXJ5VXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVOYW1lJ10sIGZyb21GaWxlTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVkUmVxdWVzdHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmxpbmVkUmVxdWVzdHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5saW5lZFJlcXVlc3RzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21JbmxpbmVkUmVxdWVzdHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lZFJlcXVlc3RUb01sZGV2KGFwaUNsaWVudCwgaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0cycsICdyZXF1ZXN0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBiYXRjaEpvYlNvdXJjZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Gb3JtYXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Zvcm1hdCddKTtcbiAgICBpZiAoZnJvbUZvcm1hdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc0Zvcm1hdCddLCBmcm9tRm9ybWF0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzU291cmNlJywgJ3VyaXMnXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CaWdxdWVyeVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmlncXVlcnlVcmknXSk7XG4gICAgaWYgKGZyb21CaWdxdWVyeVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JpZ3F1ZXJ5U291cmNlJywgJ2lucHV0VXJpJ10sIGZyb21CaWdxdWVyeVVyaSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWxlTmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBWZXJ0ZXggQUkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZWRSZXF1ZXN0cyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5saW5lZFJlcXVlc3RzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdEJhdGNoSm9iTmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50J10pO1xuICAgIGlmIChmcm9tQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnQnXSwgY29udGVudEZyb21NbGRldiQyKGZyb21Db250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaXRhdGlvbk1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2l0YXRpb25NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbk1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25NZXRhZGF0YSddLCBjaXRhdGlvbk1ldGFkYXRhRnJvbU1sZGV2JDEoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHRNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybENvbnRleHRNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0TWV0YWRhdGEnXSwgdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDIoZnJvbVVybENvbnRleHRNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXZnTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F2Z0xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tQXZnTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdmdMb2dwcm9icyddLCBmcm9tQXZnTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdncm91bmRpbmdNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hcm91bmRpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dyb3VuZGluZ01ldGFkYXRhJ10sIGZyb21Hcm91bmRpbmdNZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5kZXgnXSk7XG4gICAgaWYgKGZyb21JbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luZGV4J10sIGZyb21JbmRleCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2dwcm9ic1Jlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvZ3Byb2JzUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxvZ3Byb2JzUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9ncHJvYnNSZXN1bHQnXSwgZnJvbUxvZ3Byb2JzUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVJhdGluZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlSYXRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNhZmV0eVJhdGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlSYXRpbmdzJ10sIGZyb21TYWZldHlSYXRpbmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2l0YXRpb25NZXRhZGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaXRhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NpdGF0aW9uU291cmNlcyddKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9ucyddLCBmcm9tQ2l0YXRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUVudmlyb25tZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnZpcm9ubWVudCddKTtcbiAgICBpZiAoZnJvbUVudmlyb25tZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW52aXJvbm1lbnQnXSwgZnJvbUVudmlyb25tZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnXSwgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRFbWJlZGRpbmdGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmFsdWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWx1ZXMnXSk7XG4gICAgaWYgKGZyb21WYWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2YWx1ZXMnXSwgZnJvbVZhbHVlcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnYmF0Y2gnLCAnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzdCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVzdCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXN0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXN0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVzdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydvdXRwdXRDb25maWcnXSwgYmF0Y2hKb2JEZXN0aW5hdGlvblRvVmVydGV4KHRCYXRjaEpvYkRlc3RpbmF0aW9uKGZyb21EZXN0KSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2gnLCAnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb01sZGV2KGFwaUNsaWVudCwgdEJhdGNoSm9iU291cmNlKGFwaUNsaWVudCwgZnJvbVNyYykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQmF0Y2hKb2JDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNyYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3JjJ10pO1xuICAgIGlmIChmcm9tU3JjICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRDb25maWcnXSwgYmF0Y2hKb2JTb3VyY2VUb1ZlcnRleCh0QmF0Y2hKb2JTb3VyY2UoYXBpQ2xpZW50LCBmcm9tU3JjKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjcmVhdGVCYXRjaEpvYkNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlRW1iZWRkaW5nc0JhdGNoSm9iQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydiYXRjaCcsICdkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcmMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NyYyddKTtcbiAgICBpZiAoZnJvbVNyYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JhdGNoJywgJ2lucHV0Q29uZmlnJ10sIGVtYmVkZGluZ3NCYXRjaEpvYlNvdXJjZVRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tU3JjKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYkNvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlUmVzb3VyY2VKb2JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgam9iRXJyb3JGcm9tTWxkZXYoZnJvbUVycm9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Eb25lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb25lJ10pO1xuICAgIGlmIChmcm9tRG9uZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RvbmUnXSwgZnJvbURvbmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBqb2JFcnJvckZyb21WZXJ0ZXgoZnJvbUVycm9yKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudEJhdGNoVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAncmVxdWVzdCcsICdjb250ZW50J10sIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2JDEoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGFza1R5cGUnXSwgZnJvbVRhc2tUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRvVHJ1bmNhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRkaW5nc0JhdGNoSm9iU291cmNlVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZU5hbWUnXSk7XG4gICAgaWYgKGZyb21GaWxlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVfbmFtZSddLCBmcm9tRmlsZU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lZFJlcXVlc3RzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5saW5lZFJlcXVlc3RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUlubGluZWRSZXF1ZXN0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3RzJ10sIGVtYmVkQ29udGVudEJhdGNoVG9NbGRldihhcGlDbGllbnQsIGZyb21JbmxpbmVkUmVxdWVzdHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldiQxKGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQ0KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgc2NoZW1hVG9NbGRldiQxKHRTY2hlbWEoZnJvbVJlc3BvbnNlU2NoZW1hKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm91dGluZ0NvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncm91dGluZ0NvbmZpZyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbFNlbGVjdGlvbkNvbmZpZyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbW9kZWxTZWxlY3Rpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNhZmV0eVNldHRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5U2V0dGluZ3MnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2FmZXR5U2V0dGluZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNhZmV0eVNldHRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmV0eVNldHRpbmdUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb01sZGV2JDQodFRvb2woaXRlbSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29sQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29sQ29uZmlnJ10sIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2JDModFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMyhmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb01sZGV2JDEoZnJvbUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVsVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10pO1xuICAgIGlmIChmcm9tTW9kZWxWZXJzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxWZXJzaW9uJ10sIGZyb21Nb2RlbFZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvbXB0RmVlZGJhY2sgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRGZWVkYmFjaycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRGZWVkYmFjayAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdEZlZWRiYWNrJ10sIGZyb21Qcm9tcHRGZWVkYmFjayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZUlkJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSWQnXSwgZnJvbVJlc3BvbnNlSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRCYXRjaEpvYk5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0QmF0Y2hKb2JOYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQ0KGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYkNChmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkRW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgc2luZ2xlRW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGpvYkVycm9yRnJvbU1sZGV2KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbmxpbmVkUmVxdWVzdFRvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0JywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVlc3QnLCAnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvTWxkZXYkMShhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGlubGluZWRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldiQxKGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBqb2JFcnJvckZyb21NbGRldihmcm9tRXJyb3IpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gam9iRXJyb3JGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RldGFpbHMnXSk7XG4gICAgaWYgKGZyb21EZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGV0YWlscyddLCBmcm9tRGV0YWlscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb2RlJ10pO1xuICAgIGlmIChmcm9tQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGUnXSwgZnJvbUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gam9iRXJyb3JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29kZSddKTtcbiAgICBpZiAoZnJvbUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlJ10sIGZyb21Db2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21lc3NhZ2UnXSk7XG4gICAgaWYgKGZyb21NZXNzYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVzc2FnZSddLCBmcm9tTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxhdExuZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWx0ZXIgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0QmF0Y2hKb2JzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEJhdGNoSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmF0Y2hKb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvcGVyYXRpb25zJ10pO1xuICAgIGlmIChmcm9tQmF0Y2hKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21CYXRjaEpvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hKb2JGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXRjaEpvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhdGNoSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2JhdGNoUHJlZGljdGlvbkpvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQmF0Y2hKb2JzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21CYXRjaEpvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmF0Y2hKb2JGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmF0Y2hKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyVm9pY2VDb25maWdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3BlYWtlclZvaWNlQ29uZmlncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TcGVha2VyVm9pY2VDb25maWdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TcGVha2VyVm9pY2VDb25maWdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbU1sZGV2JDIoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21NbGRldiQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhRnJvbU1sZGV2JDIoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxGcm9tTWxkZXYkMihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2JDQoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb01sZGV2JDQoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvTWxkZXYkNChmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYkNChmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkNChmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZXRyaWV2YWxDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvTWxkZXYkMihmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRob2QnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKTtcbiAgICBpZiAoZnJvbURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0J10sIGZyb21EZWZhdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaXRlbXMnXSk7XG4gICAgaWYgKGZyb21JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2l0ZW1zJ10sIGZyb21JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhJdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4SXRlbXMnXSk7XG4gICAgaWYgKGZyb21NYXhJdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heEl0ZW1zJ10sIGZyb21NYXhJdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXR0ZXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXR0ZXJuJ10pO1xuICAgIGlmIChmcm9tUGF0dGVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhdHRlcm4nXSwgZnJvbVBhdHRlcm4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNpbmdsZUVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbWJlZGRpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VtYmVkZGluZyddKTtcbiAgICBpZiAoZnJvbUVtYmVkZGluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VtYmVkZGluZyddLCBjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2JDEoZnJvbUVtYmVkZGluZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10sIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQzKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRoaW5raW5nQ29uZmlnVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbmNsdWRlVGhvdWdodHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlVGhvdWdodHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5jbHVkZVRob3VnaHRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5jbHVkZVRob3VnaHRzJ10sIGZyb21JbmNsdWRlVGhvdWdodHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhpbmtpbmdCdWRnZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aGlua2luZ0J1ZGdldCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaGlua2luZ0J1ZGdldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RoaW5raW5nQnVkZ2V0J10sIGZyb21UaGlua2luZ0J1ZGdldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxpbmdDb25maWcnXSwgZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9NbGRldiQyKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9NbGRldiQyKGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkNChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkNChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDQoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDQoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2dsZU1hcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9NbGRldiQ0KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBjb21wdXRlclVzZVRvTWxkZXYkNChmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVybE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxNZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbVVybE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21VcmxNZXRhZGF0YTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cmxNZXRhZGF0YUZyb21NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYkNCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybE1ldGFkYXRhRnJvbU1sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YUZyb21NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldiQ0KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2b2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYkMyhmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbnZhciBQYWdlZEl0ZW07XG4oZnVuY3Rpb24gKFBhZ2VkSXRlbSkge1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQkFUQ0hfSk9CU1wiXSA9IFwiYmF0Y2hKb2JzXCI7XG4gICAgUGFnZWRJdGVtW1wiUEFHRURfSVRFTV9NT0RFTFNcIl0gPSBcIm1vZGVsc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fVFVOSU5HX0pPQlNcIl0gPSBcInR1bmluZ0pvYnNcIjtcbiAgICBQYWdlZEl0ZW1bXCJQQUdFRF9JVEVNX0ZJTEVTXCJdID0gXCJmaWxlc1wiO1xuICAgIFBhZ2VkSXRlbVtcIlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTXCJdID0gXCJjYWNoZWRDb250ZW50c1wiO1xufSkoUGFnZWRJdGVtIHx8IChQYWdlZEl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBQYWdlciBjbGFzcyBmb3IgaXRlcmF0aW5nIHRocm91Z2ggcGFnaW5hdGVkIHJlc3VsdHMuXG4gKi9cbmNsYXNzIFBhZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCByZXF1ZXN0LCByZXNwb25zZSwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gW107XG4gICAgICAgIHRoaXMucGFyYW1zSW50ZXJuYWwgPSB7fTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0SW50ZXJuYWwgPSByZXF1ZXN0O1xuICAgICAgICB0aGlzLmluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcyk7XG4gICAgfVxuICAgIGluaXQobmFtZSwgcmVzcG9uc2UsIHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLm5hbWVJbnRlcm5hbCA9IG5hbWU7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsID0gcmVzcG9uc2VbdGhpcy5uYW1lSW50ZXJuYWxdIHx8IFtdO1xuICAgICAgICB0aGlzLnNka0h0dHBSZXNwb25zZUludGVybmFsID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZTtcbiAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCA9IDA7XG4gICAgICAgIGxldCByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIGlmICghcGFyYW1zIHx8IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zID0geyBjb25maWc6IHt9IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVxdWVzdFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVxdWVzdFBhcmFtc1snY29uZmlnJ10pIHtcbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXNbJ2NvbmZpZyddWydwYWdlVG9rZW4nXSA9IHJlc3BvbnNlWyduZXh0UGFnZVRva2VuJ107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXJhbXNJbnRlcm5hbCA9IHJlcXVlc3RQYXJhbXM7XG4gICAgICAgIHRoaXMucGFnZUludGVybmFsU2l6ZSA9XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSByZXF1ZXN0UGFyYW1zWydjb25maWcnXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWydwYWdlU2l6ZSddKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnBhZ2VJbnRlcm5hbC5sZW5ndGg7XG4gICAgfVxuICAgIGluaXROZXh0UGFnZShyZXNwb25zZSkge1xuICAgICAgICB0aGlzLmluaXQodGhpcy5uYW1lSW50ZXJuYWwsIHJlc3BvbnNlLCB0aGlzLnBhcmFtc0ludGVybmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwYWdlLCB3aGljaCBpcyBhIGxpc3Qgb2YgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBmaXJzdCBwYWdlIGlzIHJldHJpZXZlZCB3aGVuIHRoZSBwYWdlciBpcyBjcmVhdGVkLiBUaGUgcmV0dXJuZWQgbGlzdCBvZlxuICAgICAqIGl0ZW1zIGNvdWxkIGJlIGEgc3Vic2V0IG9mIHRoZSBlbnRpcmUgbGlzdC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFnZUludGVybmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0eXBlIG9mIHBhZ2VkIGl0ZW0gKGZvciBleGFtcGxlLCBgYGJhdGNoX2pvYnNgYCkuXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hbWVJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBwYWdlIGZldGNoZWQgZWFjaCB0aW1lIGJ5IHRoaXMgcGFnZXIuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBudW1iZXIgb2YgaXRlbXMgaW4gdGhlIHBhZ2UgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwYWdlIGxlbmd0aC5cbiAgICAgKi9cbiAgICBnZXQgcGFnZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGhlYWRlcnMgb2YgdGhlIEFQSSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBnZXQgc2RrSHR0cFJlc3BvbnNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZGtIdHRwUmVzcG9uc2VJbnRlcm5hbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFyYW1ldGVycyB3aGVuIG1ha2luZyB0aGUgQVBJIHJlcXVlc3QgZm9yIHRoZSBuZXh0IHBhZ2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFBhcmFtZXRlcnMgY29udGFpbiBhIHNldCBvZiBvcHRpb25hbCBjb25maWdzIHRoYXQgY2FuIGJlXG4gICAgICogdXNlZCB0byBjdXN0b21pemUgdGhlIEFQSSByZXF1ZXN0LiBGb3IgZXhhbXBsZSwgdGhlIGBwYWdlVG9rZW5gIHBhcmFtZXRlclxuICAgICAqIGNvbnRhaW5zIHRoZSB0b2tlbiB0byByZXF1ZXN0IHRoZSBuZXh0IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zSW50ZXJuYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyBpbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqL1xuICAgIGdldCBwYWdlTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlSW50ZXJuYWwubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAgKi9cbiAgICBnZXRJdGVtKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VJbnRlcm5hbFtpbmRleF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXN5bmMgaXRlcmF0b3IgdGhhdCBzdXBwb3J0IGl0ZXJhdGluZyB0aHJvdWdoIGFsbCBpdGVtc1xuICAgICAqIHJldHJpZXZlZCBmcm9tIHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBpdGVyYXRvciB3aWxsIGF1dG9tYXRpY2FsbHkgZmV0Y2ggdGhlIG5leHQgcGFnZSBpZiB0aGVyZSBhcmUgbW9yZSBpdGVtc1xuICAgICAqIHRvIGZldGNoIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBwYWdlcikge1xuICAgICAqICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pZHhJbnRlcm5hbCA+PSB0aGlzLnBhZ2VMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uZXh0UGFnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLmdldEl0ZW0odGhpcy5pZHhJbnRlcm5hbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZHhJbnRlcm5hbCArPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBpdGVtLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVybjogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIG5leHQgcGFnZSBvZiBpdGVtcy4gVGhpcyBtYWtlcyBhIG5ldyBBUEkgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBJZiB0aGVyZSBhcmUgbm8gbW9yZSBwYWdlcyB0byBmZXRjaC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHBhZ2VyID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7cGFnZVNpemU6IDEwfX0pO1xuICAgICAqIGxldCBwYWdlID0gcGFnZXIucGFnZTtcbiAgICAgKiB3aGlsZSAodHJ1ZSkge1xuICAgICAqICAgZm9yIChjb25zdCBmaWxlIG9mIHBhZ2UpIHtcbiAgICAgKiAgICAgY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiAgIH1cbiAgICAgKiAgIGlmICghcGFnZXIuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAqICAgICBicmVhaztcbiAgICAgKiAgIH1cbiAgICAgKiAgIHBhZ2UgPSBhd2FpdCBwYWdlci5uZXh0UGFnZSgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBuZXh0UGFnZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05leHRQYWdlKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gbW9yZSBwYWdlcyB0byBmZXRjaC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdEludGVybmFsKHRoaXMucGFyYW1zKTtcbiAgICAgICAgdGhpcy5pbml0TmV4dFBhZ2UocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG1vcmUgcGFnZXMgdG8gZmV0Y2ggZnJvbSB0aGUgQVBJLlxuICAgICAqL1xuICAgIGhhc05leHRQYWdlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wYXJhbXNbJ2NvbmZpZyddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbJ3BhZ2VUb2tlbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBCYXRjaGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjcmVhdGUgYmF0Y2ggam9iIHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmJhdGNoZXMuY3JlYXRlKHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIHNyYzoge2djc1VyaTogJ2dzOi8vYnVja2V0L3BhdGgvdG8vZmlsZS5qc29ubCcsIGZvcm1hdDogJ2pzb25sJ30sXG4gICAgICAgICAqICAgY29uZmlnOiB7XG4gICAgICAgICAqICAgICBkZXN0OiB7Z2NzVXJpOiAnZ3M6Ly9idWNrZXQvcGF0aC9vdXRwdXQvZGlyZWN0b3J5JywgZm9ybWF0OiAnanNvbmwnfSxcbiAgICAgICAgICogICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jcmVhdGUgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvcm1hdCBkZXN0aW5hdGlvbiBpZiBub3QgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAvLyBDYXN0IHBhcmFtcy5zcmMgYXMgVmVydGV4IEFJIHBhdGggZG9lcyBub3QgaGFuZGxlIElubGluZWRSZXF1ZXN0W11cbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnID0gdGhpcy5mb3JtYXREZXN0aW5hdGlvbihwYXJhbXMuc3JjLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTUxERVZcbiAgICAgICAgICAgIGNvbnN0IHNyYyA9IHBhcmFtcy5zcmM7XG4gICAgICAgICAgICBjb25zdCBpc19pbmxpbmVkID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3JjKSB8fCBzcmMuaW5saW5lZFJlcXVlc3RzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWlzX2lubGluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5saW5lZCBnZW5lcmF0ZSBjb250ZW50IHJlcXVlc3RzIGhhbmRsaW5nXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZUlubGluZWRHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KHBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gcmVzdWx0LnBhdGg7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0Qm9keSA9IHJlc3VsdC5ib2R5O1xuICAgICAgICAgICAgY29uc3QgcXVlcnlQYXJhbXMgPSBjcmVhdGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpWydfcXVlcnknXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogKipFeHBlcmltZW50YWwqKiBDcmVhdGVzIGFuIGVtYmVkZGluZyBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGVtYmVkZGluZyBiYXRjaCBqb2IgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiBUaGUgY3JlYXRlZCBiYXRjaCBqb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuYmF0Y2hlcy5jcmVhdGVFbWJlZGRpbmdzKHtcbiAgICAgICAgICogICBtb2RlbDogJ3RleHQtZW1iZWRkaW5nLTAwNCcsXG4gICAgICAgICAqICAgc3JjOiB7ZmlsZU5hbWU6ICdmaWxlcy9teV9lbWJlZGRpbmdfaW5wdXQnfSxcbiAgICAgICAgICogfSk7XG4gICAgICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNyZWF0ZUVtYmVkZGluZ3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdiYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3MoKSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWZXJ0ZXggQUkgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGVzLmNyZWF0ZUVtYmVkZGluZ3MuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNTERFVlxuICAgICAgICAgICAgY29uc3Qgc3JjID0gcGFyYW1zLnNyYztcbiAgICAgICAgICAgIGNvbnN0IGlzX2lubGluZWQgPSBzcmMuaW5saW5lZFJlcXVlc3RzICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoIWlzX2lubGluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFbWJlZGRpbmdzSW50ZXJuYWwocGFyYW1zKTsgLy8gRml4ZWQgdHlwbyBoZXJlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbmxpbmVkIGVtYmVkIGNvbnRlbnQgcmVxdWVzdHMgaGFuZGxpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY3JlYXRlSW5saW5lZEVtYmVkQ29udGVudFJlcXVlc3QocGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSByZXN1bHQucGF0aDtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RCb2R5ID0gcmVzdWx0LmJvZHk7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IGNyZWF0ZUVtYmVkZGluZ3NCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpWydfcXVlcnknXSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVxdWVzdEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYmF0Y2ggam9iIGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGJhdGNoIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IGJhdGNoSm9icyA9IGF3YWl0IGFpLmJhdGNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBiYXRjaEpvYiBvZiBiYXRjaEpvYnMpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhiYXRjaEpvYik7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQkFUQ0hfSk9CUywgKHgpID0+IHRoaXMubGlzdEludGVybmFsKHgpLCBhd2FpdCB0aGlzLmxpc3RJbnRlcm5hbChwYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGlubGluZWQgZ2VuZXJhdGUgY29udGVudCByZXF1ZXN0c1xuICAgIGNyZWF0ZUlubGluZWRHZW5lcmF0ZUNvbnRlbnRSZXF1ZXN0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgLy8gVXNlIGluc3RhbmNlIGFwaUNsaWVudFxuICAgICAgICBwYXJhbXMpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBib2R5WydfdXJsJ107XG4gICAgICAgIGNvbnN0IHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YmF0Y2hHZW5lcmF0ZUNvbnRlbnQnLCB1cmxQYXJhbXMpO1xuICAgICAgICBjb25zdCBiYXRjaCA9IGJvZHlbJ2JhdGNoJ107XG4gICAgICAgIGNvbnN0IGlucHV0Q29uZmlnID0gYmF0Y2hbJ2lucHV0Q29uZmlnJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzV3JhcHBlciA9IGlucHV0Q29uZmlnWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCByZXF1ZXN0cyA9IHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXTtcbiAgICAgICAgY29uc3QgbmV3UmVxdWVzdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGljdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpOyAvLyBDbG9uZVxuICAgICAgICAgICAgaWYgKHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3lzdGVtSW5zdHJ1Y3Rpb25WYWx1ZSA9IHJlcXVlc3REaWN0WydzeXN0ZW1JbnN0cnVjdGlvbiddO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0Q29udGVudCA9IHJlcXVlc3REaWN0WydyZXF1ZXN0J107XG4gICAgICAgICAgICAgICAgcmVxdWVzdENvbnRlbnRbJ3N5c3RlbUluc3RydWN0aW9uJ10gPSBzeXN0ZW1JbnN0cnVjdGlvblZhbHVlO1xuICAgICAgICAgICAgICAgIHJlcXVlc3REaWN0WydyZXF1ZXN0J10gPSByZXF1ZXN0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld1JlcXVlc3RzLnB1c2gocmVxdWVzdERpY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RzV3JhcHBlclsncmVxdWVzdHMnXSA9IG5ld1JlcXVlc3RzO1xuICAgICAgICBkZWxldGUgYm9keVsnY29uZmlnJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgcmV0dXJuIHsgcGF0aCwgYm9keSB9O1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gaGFuZGxlIGlubGluZWQgZW1iZWRkaW5nIHJlcXVlc3RzXG4gICAgY3JlYXRlSW5saW5lZEVtYmVkQ29udGVudFJlcXVlc3QocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgLy8gVXNlIGluc3RhbmNlIGFwaUNsaWVudFxuICAgICAgICBwYXJhbXMpO1xuICAgICAgICBjb25zdCB1cmxQYXJhbXMgPSBib2R5WydfdXJsJ107XG4gICAgICAgIGNvbnN0IHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YXN5bmNCYXRjaEVtYmVkQ29udGVudCcsIHVybFBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gYm9keVsnYmF0Y2gnXTtcbiAgICAgICAgY29uc3QgaW5wdXRDb25maWcgPSBiYXRjaFsnaW5wdXRDb25maWcnXTtcbiAgICAgICAgY29uc3QgcmVxdWVzdHNXcmFwcGVyID0gaW5wdXRDb25maWdbJ3JlcXVlc3RzJ107XG4gICAgICAgIGNvbnN0IHJlcXVlc3RzID0gcmVxdWVzdHNXcmFwcGVyWydyZXF1ZXN0cyddO1xuICAgICAgICBjb25zdCBuZXdSZXF1ZXN0cyA9IFtdO1xuICAgICAgICBkZWxldGUgcmVxdWVzdHNXcmFwcGVyWydjb25maWcnXTsgLy8gUmVtb3ZlIHRvcC1sZXZlbCBjb25maWdcbiAgICAgICAgZm9yIChjb25zdCByZXF1ZXN0IG9mIHJlcXVlc3RzKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0RGljdCA9IE9iamVjdC5hc3NpZ24oe30sIHJlcXVlc3QpOyAvLyBDbG9uZVxuICAgICAgICAgICAgY29uc3QgaW5uZXJSZXF1ZXN0ID0gcmVxdWVzdERpY3RbJ3JlcXVlc3QnXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHJlcXVlc3REaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSAhPT0gJ3JlcXVlc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyUmVxdWVzdFtrZXldID0gcmVxdWVzdERpY3Rba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0W2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3UmVxdWVzdHMucHVzaChyZXF1ZXN0RGljdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdHNXcmFwcGVyWydyZXF1ZXN0cyddID0gbmV3UmVxdWVzdHM7XG4gICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICByZXR1cm4geyBwYXRoLCBib2R5IH07XG4gICAgfVxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBnZXQgdGhlIGZpcnN0IEdDUyBVUklcbiAgICBnZXRHY3NVcmkoc3JjKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHNyYy5zdGFydHNXaXRoKCdnczovLycpID8gc3JjIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzcmMpICYmIHNyYy5nY3NVcmkgJiYgc3JjLmdjc1VyaS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLmdjc1VyaVswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IHRoZSBCaWdRdWVyeSBVUklcbiAgICBnZXRCaWdxdWVyeVVyaShzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjLnN0YXJ0c1dpdGgoJ2JxOi8vJykgPyBzcmMgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIHJldHVybiBzcmMuYmlncXVlcnlVcmk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLy8gRnVuY3Rpb24gdG8gZm9ybWF0IHRoZSBkZXN0aW5hdGlvbiBjb25maWd1cmF0aW9uIGZvciBWZXJ0ZXggQUlcbiAgICBmb3JtYXREZXN0aW5hdGlvbihzcmMsIGNvbmZpZykge1xuICAgICAgICBjb25zdCBuZXdDb25maWcgPSBjb25maWcgPyBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpIDoge307XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcFN0ciA9IERhdGUubm93KCkudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKCFuZXdDb25maWcuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIG5ld0NvbmZpZy5kaXNwbGF5TmFtZSA9IGBnZW5haUJhdGNoSm9iXyR7dGltZXN0YW1wU3RyfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0NvbmZpZy5kZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdjc1VyaSA9IHRoaXMuZ2V0R2NzVXJpKHNyYyk7XG4gICAgICAgICAgICBjb25zdCBiaWdxdWVyeVVyaSA9IHRoaXMuZ2V0QmlncXVlcnlVcmkoc3JjKTtcbiAgICAgICAgICAgIGlmIChnY3NVcmkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2NzVXJpLmVuZHNXaXRoKCcuanNvbmwnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgLmpzb25sIGZpbGVzLCByZW1vdmUgc3VmZml4IGFuZCBhZGQgL2Rlc3RcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtnY3NVcmkuc2xpY2UoMCwgLTYpfS9kZXN0YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGZvciBvdGhlciBHQ1MgVVJJc1xuICAgICAgICAgICAgICAgICAgICBuZXdDb25maWcuZGVzdCA9IGAke2djc1VyaX1fZGVzdF8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGJpZ3F1ZXJ5VXJpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29uZmlnLmRlc3QgPSBgJHtiaWdxdWVyeVVyaX1fZGVzdF8ke3RpbWVzdGFtcFN0cn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBzb3VyY2UgZm9yIFZlcnRleCBBSTogTm8gR0NTIG9yIEJpZ1F1ZXJ5IFVSSSBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3Q29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoR2VuZXJhdGVDb250ZW50JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBiYXRjaEpvYkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY3JlYXRlIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgY3JlYXRlIGJhdGNoIGpvYiByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlRW1iZWRkaW5nc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVFbWJlZGRpbmdzQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06YXN5bmNCYXRjaEVtYmVkQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBiYXRjaCBqb2IgY29uZmlndXJhdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBiYXRjaCBqb2IuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5nZXQoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZ2V0KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMve25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGJhdGNoSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZXRCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gYmF0Y2hKb2JGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhIGJhdGNoIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNhbmNlbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuYmF0Y2hlcy5jYW5jZWwoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdiYXRjaFByZWRpY3Rpb25Kb2JzL3tuYW1lfTpjYW5jZWwnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsQmF0Y2hKb2JQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoZXMve25hbWV9OmNhbmNlbCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2JhdGNoUHJlZGljdGlvbkpvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RCYXRjaEpvYnNSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0QmF0Y2hKb2JzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RCYXRjaEpvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbGlzdEJhdGNoSm9ic1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEJhdGNoSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgYmF0Y2ggam9iLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZGVsZXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgZW1wdHkgcmVzcG9uc2UgcmV0dXJuZWQgYnkgdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5iYXRjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUJhdGNoSm9iUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hQcmVkaWN0aW9uSm9icy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZVJlc291cmNlSm9iRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBkZWxldGVCYXRjaEpvYlBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYmF0Y2hlcy97bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZVJlc291cmNlSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5mdW5jdGlvbiBhcGlLZXlDb25maWdUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlTdHJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleVN0cmluZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleVN0cmluZyddLCBmcm9tQXBpS2V5U3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0aENvbmZpZ1RvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10sIGFwaUtleUNvbmZpZ1RvVmVydGV4JDIoZnJvbUFwaUtleUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0aFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1dGhUeXBlJ10pO1xuICAgIGlmIChmcm9tQXV0aFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoVHlwZSddLCBmcm9tQXV0aFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnJ10sIGZyb21Hb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaHR0cEJhc2ljQXV0aENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21IdHRwQmFzaWNBdXRoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaHR0cEJhc2ljQXV0aENvbmZpZyddLCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PYXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2F1dGhDb25maWcnXSk7XG4gICAgaWYgKGZyb21PYXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10sIGZyb21PYXV0aENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PaWRjQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvaWRjQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2lkY0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ29pZGNDb25maWcnXSwgZnJvbU9pZGNDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaXNwbGF5TmFtZSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwaXJlVGltZSddLCBmcm9tRXhwaXJlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Vc2FnZU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXNhZ2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Vc2FnZU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXNhZ2VNZXRhZGF0YSddLCBmcm9tVXNhZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgZnJvbVVzYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlclVzZVRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyddLCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJ10sIGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50VG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvTWxkZXYkMyh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMyhpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9NbGRldiQxKGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ttc0tleU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ttc0tleU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb1ZlcnRleCQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCQyKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Ub29scztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0b29scyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbENvbmZpZyddLCB0b29sQ29uZmlnVG9WZXJ0ZXgkMShmcm9tVG9vbENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tS21zS2V5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsna21zS2V5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUttc0tleU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZW5jcnlwdGlvbl9zcGVjJywgJ2ttc0tleU5hbWUnXSwgZnJvbUttc0tleU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCB0Q2FjaGVzTW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgdENhY2hlc01vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNyZWF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FeGNsdWRlRG9tYWlucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVEb21haW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVEb21haW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSwgZnJvbUV4Y2x1ZGVEb21haW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnXSwgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsaW5nQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFsbG93ZWRGdW5jdGlvbk5hbWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWxsb3dlZEZ1bmN0aW9uTmFtZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbGxvd2VkRnVuY3Rpb25OYW1lcyddLCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CZWhhdmlvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSk7XG4gICAgaWYgKGZyb21CZWhhdmlvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JlaGF2aW9yJ10sIGZyb21CZWhhdmlvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVycyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFyYW1ldGVycyddKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzJ10sIGZyb21QYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncGFyYW1ldGVyc0pzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJhbWV0ZXJzSnNvblNjaGVtYSddLCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3BvbnNlJ10pO1xuICAgIGlmIChmcm9tUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZSddLCBmcm9tUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlSnNvblNjaGVtYSddLCBmcm9tUmVzcG9uc2VKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25EZWNsYXJhdGlvblRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVNYXBzVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0aENvbmZpZyddKTtcbiAgICBpZiAoZnJvbUF1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdXRoQ29uZmlnJ10sIGF1dGhDb25maWdUb1ZlcnRleCQyKGZyb21BdXRoQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMyhmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMihmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb01sZGV2JDMoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGNsdWRlRG9tYWlucyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhjbHVkZURvbWFpbnMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvVmVydGV4JDIoZnJvbVRpbWVSYW5nZUZpbHRlcikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZURvbWFpbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlRG9tYWlucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlRG9tYWlucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10sIGZyb21FeGNsdWRlRG9tYWlucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldiQzKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9WZXJ0ZXgkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdGl0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxhdGl0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0aXR1ZGUnXSwgZnJvbUxhdGl0dWRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxvbmdpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbG9uZ2l0dWRlJ10pO1xuICAgIGlmIChmcm9tTG9uZ2l0dWRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbG9uZ2l0dWRlJ10sIGZyb21Mb25naXR1ZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsYXRMbmdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdENhY2hlZENvbnRlbnRzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdENhY2hlZENvbnRlbnRzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0Q2FjaGVkQ29udGVudHNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FjaGVkQ29udGVudHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkQ29udGVudEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlZENvbnRlbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENvbnRlbnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMyhmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYkMyhmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQzKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQzKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQzKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQyKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleCQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgkMihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvVmVydGV4JDIoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZXRyaWV2YWxDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvTWxkZXYkMShmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0TG5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYXRMbmcnXSk7XG4gICAgaWYgKGZyb21MYXRMbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRMbmcnXSwgbGF0TG5nVG9WZXJ0ZXgkMShmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbENvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2JDEoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbENvbmZpZyddLCByZXRyaWV2YWxDb25maWdUb01sZGV2JDEoZnJvbVJldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleCQxKGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShmcm9tUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDMoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JldHJpZXZhbCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9NbGRldiQzKGZyb21Hb29nbGVTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2hSZXRyaWV2YWwnXSwgZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQzKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYkMygpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb01sZGV2JDMoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZhbCddLCBmcm9tUmV0cmlldmFsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvVmVydGV4JDIoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleCQyKGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleCQyKGZyb21FbnRlcnByaXNlV2ViU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVNYXBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlTWFwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSwgZ29vZ2xlTWFwc1RvVmVydGV4JDIoZnJvbUdvb2dsZU1hcHMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9WZXJ0ZXgkMigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb1ZlcnRleCQyKGZyb21Db21wdXRlclVzZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb24nXSwgZnJvbUNvZGVFeGVjdXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UdGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R0bCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVR0bCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dGwnXSwgZnJvbVR0bCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeHBpcmVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleHBpcmVUaW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydleHBpcmVUaW1lJ10sIGZyb21FeHBpcmVUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVR0bCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHRsJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHRsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R0bCddLCBmcm9tVHRsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbU5hbWUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlQ2FjaGVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRDYWNoZWRDb250ZW50TmFtZShhcGlDbGllbnQsIGZyb21OYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZUNhY2hlZENvbnRlbnRDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb01sZGV2JDMoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9WZXJ0ZXgkMigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb01sZGV2JDMoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIENhY2hlcyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpc3RzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3QuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHBhZ2luYXRlZCByZXN1bHRzIG9mIHRoZSBsaXN0IG9mIGNhY2hlZCBjb250ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgY2FjaGVkQ29udGVudHMgPSBhd2FpdCBhaS5jYWNoZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMn19KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBjYWNoZWRDb250ZW50IG9mIGNhY2hlZENvbnRlbnRzKSB7XG4gICAgICAgICAqICAgY29uc29sZS5sb2coY2FjaGVkQ29udGVudCk7XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fQ0FDSEVEX0NPTlRFTlRTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjYWNoZWQgY29udGVudHMgcmVzb3VyY2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIENvbnRleHQgY2FjaGluZyBpcyBvbmx5IHN1cHBvcnRlZCBmb3Igc3BlY2lmaWMgbW9kZWxzLiBTZWUgW0dlbWluaVxuICAgICAqIERldmVsb3BlciBBUEkgcmVmZXJlbmNlXShodHRwczovL2FpLmdvb2dsZS5kZXYvZ2VtaW5pLWFwaS9kb2NzL2NhY2hpbmc/bGFuZz1ub2RlL2NvbnRleHQtY2FjKVxuICAgICAqIGFuZCBbVmVydGV4IEFJIHJlZmVyZW5jZV0oaHR0cHM6Ly9jbG91ZC5nb29nbGUuY29tL3ZlcnRleC1haS9nZW5lcmF0aXZlLWFpL2RvY3MvY29udGV4dC1jYWNoZS9jb250ZXh0LWNhY2hlLW92ZXJ2aWV3I3N1cHBvcnRlZF9tb2RlbHMpXG4gICAgICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmVhdGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIGNhY2hlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbnRlbnRzID0gLi4uOyAvLyBJbml0aWFsaXplIHRoZSBjb250ZW50IHRvIGNhY2hlLlxuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkuY2FjaGVzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gtMDAxJyxcbiAgICAgKiAgIGNvbmZpZzoge1xuICAgICAqICAgICdjb250ZW50cyc6IGNvbnRlbnRzLFxuICAgICAqICAgICdkaXNwbGF5TmFtZSc6ICd0ZXN0IGNhY2hlJyxcbiAgICAgKiAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnV2hhdCBpcyB0aGUgc3VtIG9mIHRoZSB0d28gcGRmcz8nLFxuICAgICAqICAgICd0dGwnOiAnODY0MDBzJyxcbiAgICAgKiAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY3JlYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ2NhY2hlZENvbnRlbnRzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjYWNoZWRDb250ZW50RnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdjYWNoZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZ2V0IHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgY2FjaGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmdldCh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldENhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0Q2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNhY2hlZENvbnRlbnRGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRlbGV0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkuY2FjaGVzLmRlbGV0ZSh7bmFtZTogJy4uLid9KTsgLy8gVGhlIHNlcnZlci1nZW5lcmF0ZWQgcmVzb3VyY2UgbmFtZS5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUNhY2hlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZUNhY2hlZENvbnRlbnRQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0RFTEVURScsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRGVsZXRlQ2FjaGVkQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGNhY2hlZCBjb250ZW50IGNvbmZpZ3VyYXRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdXBkYXRlIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBjYWNoZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLmNhY2hlcy51cGRhdGUoe1xuICAgICAqICAgbmFtZTogJy4uLicsICAvLyBUaGUgc2VydmVyLWdlbmVyYXRlZCByZXNvdXJjZSBuYW1lLlxuICAgICAqICAgY29uZmlnOiB7J3R0bCc6ICc3NjAwcyd9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVDYWNoZWRDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlQ2FjaGVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gY2FjaGVkQ29udGVudEZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBsaXN0SW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGxpc3RDYWNoZWRDb250ZW50c1BhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0Q2FjaGVkQ29udGVudHNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnY2FjaGVkQ29udGVudHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RDYWNoZWRDb250ZW50c1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xyXG5cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcmVzcG9uc2UgaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZS5jYW5kaWRhdGVzID09IHVuZGVmaW5lZCB8fCByZXNwb25zZS5jYW5kaWRhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2EgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGVudDtcbiAgICBpZiAoY29udGVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWRDb250ZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gaXNWYWxpZENvbnRlbnQoY29udGVudCkge1xuICAgIGlmIChjb250ZW50LnBhcnRzID09PSB1bmRlZmluZWQgfHwgY29udGVudC5wYXJ0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgY29udGVudC5wYXJ0cykge1xuICAgICAgICBpZiAocGFydCA9PT0gdW5kZWZpbmVkIHx8IE9iamVjdC5rZXlzKHBhcnQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGhpc3RvcnkgY29udGFpbnMgdGhlIGNvcnJlY3Qgcm9sZXMuXG4gKlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGlzdG9yeSBkb2VzIG5vdCBzdGFydCB3aXRoIGEgdXNlciB0dXJuLlxuICogQHRocm93cyBFcnJvciBpZiB0aGUgaGlzdG9yeSBjb250YWlucyBhbiBpbnZhbGlkIHJvbGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KSB7XG4gICAgLy8gRW1wdHkgaGlzdG9yeSBpcyB2YWxpZC5cbiAgICBpZiAoaGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbnRlbnQgb2YgaGlzdG9yeSkge1xuICAgICAgICBpZiAoY29udGVudC5yb2xlICE9PSAndXNlcicgJiYgY29udGVudC5yb2xlICE9PSAnbW9kZWwnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJvbGUgbXVzdCBiZSB1c2VyIG9yIG1vZGVsLCBidXQgZ290ICR7Y29udGVudC5yb2xlfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRXh0cmFjdHMgdGhlIGN1cmF0ZWQgKHZhbGlkKSBoaXN0b3J5IGZyb20gYSBjb21wcmVoZW5zaXZlIGhpc3RvcnkuXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBtb2RlbCBtYXkgc29tZXRpbWVzIGdlbmVyYXRlIGludmFsaWQgb3IgZW1wdHkgY29udGVudHMoZS5nLiwgZHVlIHRvIHNhZnR5XG4gKiBmaWx0ZXJzIG9yIHJlY2l0YXRpb24pLiBFeHRyYWN0aW5nIHZhbGlkIHR1cm5zIGZyb20gdGhlIGhpc3RvcnlcbiAqIGVuc3VyZXMgdGhhdCBzdWJzZXF1ZW50IHJlcXVlc3RzIGNvdWxkIGJlIGFjY3BldGVkIGJ5IHRoZSBtb2RlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEN1cmF0ZWRIaXN0b3J5KGNvbXByZWhlbnNpdmVIaXN0b3J5KSB7XG4gICAgaWYgKGNvbXByZWhlbnNpdmVIaXN0b3J5ID09PSB1bmRlZmluZWQgfHwgY29tcHJlaGVuc2l2ZUhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgY3VyYXRlZEhpc3RvcnkgPSBbXTtcbiAgICBjb25zdCBsZW5ndGggPSBjb21wcmVoZW5zaXZlSGlzdG9yeS5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgICAgIGlmIChjb21wcmVoZW5zaXZlSGlzdG9yeVtpXS5yb2xlID09PSAndXNlcicpIHtcbiAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnB1c2goY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0pO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBbXTtcbiAgICAgICAgICAgIGxldCBpc1ZhbGlkID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgbGVuZ3RoICYmIGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldLnJvbGUgPT09ICdtb2RlbCcpIHtcbiAgICAgICAgICAgICAgICBtb2RlbE91dHB1dC5wdXNoKGNvbXByZWhlbnNpdmVIaXN0b3J5W2ldKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZCAmJiAhaXNWYWxpZENvbnRlbnQoY29tcHJlaGVuc2l2ZUhpc3RvcnlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICBjdXJhdGVkSGlzdG9yeS5wdXNoKC4uLm1vZGVsT3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCB1c2VyIGlucHV0IHdoZW4gbW9kZWwgY29udGVudCBpcyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGN1cmF0ZWRIaXN0b3J5LnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdXJhdGVkSGlzdG9yeTtcbn1cbi8qKlxuICogQSB1dGlsaXR5IGNsYXNzIHRvIGNyZWF0ZSBhIGNoYXQgc2Vzc2lvbi5cbiAqL1xuY2xhc3MgQ2hhdHMge1xuICAgIGNvbnN0cnVjdG9yKG1vZGVsc01vZHVsZSwgYXBpQ2xpZW50KSB7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoZSBjb25maWcgaW4gdGhlIHBhcmFtcyB3aWxsIGJlIHVzZWQgZm9yIGFsbCByZXF1ZXN0cyB3aXRoaW4gdGhlIGNoYXRcbiAgICAgKiBzZXNzaW9uIHVubGVzcyBvdmVycmlkZGVuIGJ5IGEgcGVyLXJlcXVlc3QgYGNvbmZpZ2AgaW5cbiAgICAgKiBAc2VlIHtAbGluayB0eXBlcy5TZW5kTWVzc2FnZVBhcmFtZXRlcnMjY29uZmlnfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciBjcmVhdGluZyBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBBIG5ldyBjaGF0IHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgY2hhdCA9IGFpLmNoYXRzLmNyZWF0ZSh7XG4gICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICogICBjb25maWc6IHtcbiAgICAgKiAgICAgdGVtcGVyYXR1cmU6IDAuNSxcbiAgICAgKiAgICAgbWF4T3V0cHV0VG9rZW5zOiAxMDI0LFxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGNyZWF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDaGF0KHRoaXMuYXBpQ2xpZW50LCB0aGlzLm1vZGVsc01vZHVsZSwgcGFyYW1zLm1vZGVsLCBwYXJhbXMuY29uZmlnLCBcbiAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSBoaXN0b3J5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBoaXN0b3J5IG91dHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGNoYXQgc2Vzc2lvbi5cbiAgICAgICAgc3RydWN0dXJlZENsb25lKHBhcmFtcy5oaXN0b3J5KSk7XG4gICAgfVxufVxuLyoqXG4gKiBDaGF0IHNlc3Npb24gdGhhdCBlbmFibGVzIHNlbmRpbmcgbWVzc2FnZXMgdG8gdGhlIG1vZGVsIHdpdGggcHJldmlvdXNcbiAqIGNvbnZlcnNhdGlvbiBjb250ZXh0LlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGUgc2Vzc2lvbiBtYWludGFpbnMgYWxsIHRoZSB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kIG1vZGVsLlxuICovXG5jbGFzcyBDaGF0IHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIG1vZGVsc01vZHVsZSwgbW9kZWwsIGNvbmZpZyA9IHt9LCBoaXN0b3J5ID0gW10pIHtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgICAgIHRoaXMubW9kZWxzTW9kdWxlID0gbW9kZWxzTW9kdWxlO1xuICAgICAgICB0aGlzLm1vZGVsID0gbW9kZWw7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBoaXN0b3J5O1xuICAgICAgICAvLyBBIHByb21pc2UgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZXNzYWdlIGJlaW5nIHNlbnQgdG8gdGhlXG4gICAgICAgIC8vIG1vZGVsLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHZhbGlkYXRlSGlzdG9yeShoaXN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIG1lc3NhZ2UgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZVxuICAgICAqIHNlbmRpbmcgdGhlIG5leHQgbWVzc2FnZS5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIENoYXQjc2VuZE1lc3NhZ2VTdHJlYW19IGZvciBzdHJlYW1pbmcgbWV0aG9kLlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBzZW5kaW5nIG1lc3NhZ2VzIHdpdGhpbiBhIGNoYXQgc2Vzc2lvbi5cbiAgICAgKiBAcmV0dXJucyBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZS50ZXh0KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBzZW5kTWVzc2FnZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBhd2FpdCB0aGlzLnNlbmRQcm9taXNlO1xuICAgICAgICBjb25zdCBpbnB1dENvbnRlbnQgPSB0Q29udGVudChwYXJhbXMubWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHRoaXMubW9kZWxzTW9kdWxlLmdlbmVyYXRlQ29udGVudCh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmdldEhpc3RvcnkodHJ1ZSkuY29uY2F0KGlucHV0Q29udGVudCksXG4gICAgICAgICAgICBjb25maWc6IChfYSA9IHBhcmFtcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVzcG9uc2VQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IChfYiA9IChfYSA9IHJlc3BvbnNlLmNhbmRpZGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBBRkMgaW5wdXQgY29udGFpbnMgdGhlIGVudGlyZSBjdXJhdGVkIGNoYXQgaGlzdG9yeSBpblxuICAgICAgICAgICAgLy8gYWRkaXRpb24gdG8gdGhlIG5ldyB1c2VyIGlucHV0LCB3ZSBuZWVkIHRvIHRydW5jYXRlIHRoZSBBRkMgaGlzdG9yeVxuICAgICAgICAgICAgLy8gdG8gZGVkdXBsaWNhdGUgdGhlIGV4aXN0aW5nIGNoYXQgaGlzdG9yeS5cbiAgICAgICAgICAgIGNvbnN0IGZ1bGxBdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gcmVzcG9uc2UuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRIaXN0b3J5KHRydWUpLmxlbmd0aDtcbiAgICAgICAgICAgIGxldCBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID0gW107XG4gICAgICAgICAgICBpZiAoZnVsbEF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPVxuICAgICAgICAgICAgICAgICAgICAoX2MgPSBmdWxsQXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeS5zbGljZShpbmRleCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbW9kZWxPdXRwdXQgPSBvdXRwdXRDb250ZW50ID8gW291dHB1dENvbnRlbnRdIDogW107XG4gICAgICAgICAgICB0aGlzLnJlY29yZEhpc3RvcnkoaW5wdXRDb250ZW50LCBtb2RlbE91dHB1dCwgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZFByb21pc2UuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVzZXRzIHNlbmRQcm9taXNlIHRvIGF2b2lkIHN1YnNlcXVlbnQgY2FsbHMgZmFpbGluZ1xuICAgICAgICAgICAgdGhpcy5zZW5kUHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlUHJvbWlzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBtb2RlbCBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UgaW4gY2h1bmtzLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHdhaXQgZm9yIHRoZSBwcmV2aW91cyBtZXNzYWdlIHRvIGJlIHByb2Nlc3NlZCBiZWZvcmVcbiAgICAgKiBzZW5kaW5nIHRoZSBuZXh0IG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBDaGF0I3NlbmRNZXNzYWdlfSBmb3Igbm9uLXN0cmVhbWluZyBtZXRob2QuXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIHBhcmFtZXRlcnMgZm9yIHNlbmRpbmcgdGhlIG1lc3NhZ2UuXG4gICAgICogQHJldHVybiBUaGUgbW9kZWwncyByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBjaGF0ID0gYWkuY2hhdHMuY3JlYXRlKHttb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnfSk7XG4gICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjaGF0LnNlbmRNZXNzYWdlU3RyZWFtKHtcbiAgICAgKiAgIG1lc3NhZ2U6ICdXaHkgaXMgdGhlIHNreSBibHVlPydcbiAgICAgKiB9KTtcbiAgICAgKiBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHJlc3BvbnNlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyhjaHVuay50ZXh0KTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VuZE1lc3NhZ2VTdHJlYW0ocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kUHJvbWlzZTtcbiAgICAgICAgY29uc3QgaW5wdXRDb250ZW50ID0gdENvbnRlbnQocGFyYW1zLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBzdHJlYW1SZXNwb25zZSA9IHRoaXMubW9kZWxzTW9kdWxlLmdlbmVyYXRlQ29udGVudFN0cmVhbSh7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiB0aGlzLmdldEhpc3RvcnkodHJ1ZSkuY29uY2F0KGlucHV0Q29udGVudCksXG4gICAgICAgICAgICBjb25maWc6IChfYSA9IHBhcmFtcy5jb25maWcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29uZmlnLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gUmVzb2x2ZSB0aGUgaW50ZXJuYWwgdHJhY2tpbmcgb2Ygc2VuZCBjb21wbGV0aW9uIHByb21pc2UgLSBgc2VuZFByb21pc2VgXG4gICAgICAgIC8vIGZvciBib3RoIHN1Y2Nlc3MgYW5kIGZhaWx1cmUgcmVzcG9uc2UuIFRoZSBhY3R1YWwgZmFpbHVyZSBpcyBzdGlsbFxuICAgICAgICAvLyBwcm9wYWdhdGVkIGJ5IHRoZSBgYXdhaXQgc3RyZWFtUmVzcG9uc2VgLlxuICAgICAgICB0aGlzLnNlbmRQcm9taXNlID0gc3RyZWFtUmVzcG9uc2VcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHVuZGVmaW5lZClcbiAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHN0cmVhbVJlc3BvbnNlO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnByb2Nlc3NTdHJlYW1SZXNwb25zZShyZXNwb25zZSwgaW5wdXRDb250ZW50KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2hhdCBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBUaGUgaGlzdG9yeSBpcyBhIGxpc3Qgb2YgY29udGVudHMgYWx0ZXJuYXRpbmcgYmV0d2VlbiB1c2VyIGFuZCBtb2RlbC5cbiAgICAgKlxuICAgICAqIFRoZXJlIGFyZSB0d28gdHlwZXMgb2YgaGlzdG9yeTpcbiAgICAgKiAtIFRoZSBgY3VyYXRlZCBoaXN0b3J5YCBjb250YWlucyBvbmx5IHRoZSB2YWxpZCB0dXJucyBiZXR3ZWVuIHVzZXIgYW5kXG4gICAgICogbW9kZWwsIHdoaWNoIHdpbGwgYmUgaW5jbHVkZWQgaW4gdGhlIHN1YnNlcXVlbnQgcmVxdWVzdHMgc2VudCB0byB0aGUgbW9kZWwuXG4gICAgICogLSBUaGUgYGNvbXByZWhlbnNpdmUgaGlzdG9yeWAgY29udGFpbnMgYWxsIHR1cm5zLCBpbmNsdWRpbmcgaW52YWxpZCBvclxuICAgICAqICAgZW1wdHkgbW9kZWwgb3V0cHV0cywgcHJvdmlkaW5nIGEgY29tcGxldGUgcmVjb3JkIG9mIHRoZSBoaXN0b3J5LlxuICAgICAqXG4gICAgICogVGhlIGhpc3RvcnkgaXMgdXBkYXRlZCBhZnRlciByZWNlaXZpbmcgdGhlIHJlc3BvbnNlIGZyb20gdGhlIG1vZGVsLFxuICAgICAqIGZvciBzdHJlYW1pbmcgcmVzcG9uc2UsIGl0IG1lYW5zIHJlY2VpdmluZyB0aGUgbGFzdCBjaHVuayBvZiB0aGUgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBUaGUgYGNvbXByZWhlbnNpdmUgaGlzdG9yeWAgaXMgcmV0dXJuZWQgYnkgZGVmYXVsdC4gVG8gZ2V0IHRoZSBgY3VyYXRlZFxuICAgICAqIGhpc3RvcnlgLCBzZXQgdGhlIGBjdXJhdGVkYCBwYXJhbWV0ZXIgdG8gYHRydWVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGN1cmF0ZWQgLSB3aGV0aGVyIHRvIHJldHVybiB0aGUgY3VyYXRlZCBoaXN0b3J5IG9yIHRoZSBjb21wcmVoZW5zaXZlXG4gICAgICogICAgIGhpc3RvcnkuXG4gICAgICogQHJldHVybiBIaXN0b3J5IGNvbnRlbnRzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwgZm9yIHRoZSBlbnRpcmVcbiAgICAgKiAgICAgY2hhdCBzZXNzaW9uLlxuICAgICAqL1xuICAgIGdldEhpc3RvcnkoY3VyYXRlZCA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGhpc3RvcnkgPSBjdXJhdGVkXG4gICAgICAgICAgICA/IGV4dHJhY3RDdXJhdGVkSGlzdG9yeSh0aGlzLmhpc3RvcnkpXG4gICAgICAgICAgICA6IHRoaXMuaGlzdG9yeTtcbiAgICAgICAgLy8gRGVlcCBjb3B5IHRoZSBoaXN0b3J5IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBoaXN0b3J5IG91dHNpZGUgb2YgdGhlXG4gICAgICAgIC8vIGNoYXQgc2Vzc2lvbi5cbiAgICAgICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZShoaXN0b3J5KTtcbiAgICB9XG4gICAgcHJvY2Vzc1N0cmVhbVJlc3BvbnNlKHN0cmVhbVJlc3BvbnNlLCBpbnB1dENvbnRlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogcHJvY2Vzc1N0cmVhbVJlc3BvbnNlXzEoKSB7XG4gICAgICAgICAgICB2YXIgX2MsIGVfMSwgX2QsIF9lO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0Q29udGVudCA9IFtdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIHN0cmVhbVJlc3BvbnNlXzEgPSBfX2FzeW5jVmFsdWVzKHN0cmVhbVJlc3BvbnNlKSwgc3RyZWFtUmVzcG9uc2VfMV8xOyBzdHJlYW1SZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KHN0cmVhbVJlc3BvbnNlXzEubmV4dCgpKSwgX2MgPSBzdHJlYW1SZXNwb25zZV8xXzEuZG9uZSwgIV9jOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2UgPSBzdHJlYW1SZXNwb25zZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkUmVzcG9uc2UoY2h1bmspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hID0gY2h1bmsuY2FuZGlkYXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRDb250ZW50LnB1c2goY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX2YgJiYgIV9jICYmIChfZCA9IHN0cmVhbVJlc3BvbnNlXzEucmV0dXJuKSkgeWllbGQgX19hd2FpdChfZC5jYWxsKHN0cmVhbVJlc3BvbnNlXzEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWNvcmRIaXN0b3J5KGlucHV0Q29udGVudCwgb3V0cHV0Q29udGVudCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWNvcmRIaXN0b3J5KHVzZXJJbnB1dCwgbW9kZWxPdXRwdXQsIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkpIHtcbiAgICAgICAgbGV0IG91dHB1dENvbnRlbnRzID0gW107XG4gICAgICAgIGlmIChtb2RlbE91dHB1dC5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBtb2RlbE91dHB1dC5ldmVyeSgoY29udGVudCkgPT4gY29udGVudC5yb2xlICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICBvdXRwdXRDb250ZW50cyA9IG1vZGVsT3V0cHV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXBwZW5kcyBhbiBlbXB0eSBjb250ZW50IHdoZW4gbW9kZWwgcmV0dXJucyBlbXB0eSByZXNwb25zZSwgc28gdGhhdCB0aGVcbiAgICAgICAgICAgIC8vIGhpc3RvcnkgaXMgYWx3YXlzIGFsdGVybmF0aW5nIGJldHdlZW4gdXNlciBhbmQgbW9kZWwuXG4gICAgICAgICAgICBvdXRwdXRDb250ZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICByb2xlOiAnbW9kZWwnLFxuICAgICAgICAgICAgICAgIHBhcnRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ICYmXG4gICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKC4uLmV4dHJhY3RDdXJhdGVkSGlzdG9yeShhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnkucHVzaCh1c2VySW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKC4uLm91dHB1dENvbnRlbnRzKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogQVBJIGVycm9ycyByYWlzZWQgYnkgdGhlIEdlbkFJIEFQSS5cbiAqL1xuY2xhc3MgQXBpRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLm1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBpRXJyb3InO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IG9wdGlvbnMuc3RhdHVzO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQXBpRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIENvZGUgZ2VuZXJhdGVkIGJ5IHRoZSBHb29nbGUgR2VuIEFJIFNESyBnZW5lcmF0b3IgRE8gTk9UIEVESVQuXG5mdW5jdGlvbiBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGUnXSk7XG4gICAgaWYgKGZyb21GaWxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZSddLCBmaWxlVG9NbGRldihmcm9tRmlsZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWxlUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ2ZpbGUnXSwgdEZpbGVOYW1lKGZyb21OYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNpemVCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2l6ZUJ5dGVzJ10pO1xuICAgIGlmIChmcm9tU2l6ZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2l6ZUJ5dGVzJ10sIGZyb21TaXplQnl0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGlyYXRpb25UaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhwaXJhdGlvblRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhwaXJhdGlvblRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleHBpcmF0aW9uVGltZSddLCBmcm9tRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXBkYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXBkYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbVVwZGF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cGRhdGVUaW1lJ10sIGZyb21VcGRhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNoYTI1Nkhhc2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NoYTI1Nkhhc2gnXSk7XG4gICAgaWYgKGZyb21TaGEyNTZIYXNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2hhMjU2SGFzaCddLCBmcm9tU2hhMjU2SGFzaCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvd25sb2FkVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkb3dubG9hZFVyaSddKTtcbiAgICBpZiAoZnJvbURvd25sb2FkVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG93bmxvYWRVcmknXSwgZnJvbURvd25sb2FkVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgZnJvbVN0YXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNvdXJjZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc291cmNlJ10pO1xuICAgIGlmIChmcm9tU291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc291cmNlJ10sIGZyb21Tb3VyY2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgZnJvbVZpZGVvTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmaWxlU3RhdHVzRnJvbU1sZGV2KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlU3RhdHVzRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVTdGF0dXNUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXRhaWxzJ10pO1xuICAgIGlmIChmcm9tRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RldGFpbHMnXSwgZnJvbURldGFpbHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVzc2FnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVzc2FnZSddKTtcbiAgICBpZiAoZnJvbU1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXNzYWdlJ10sIGZyb21NZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvZGUnXSk7XG4gICAgaWYgKGZyb21Db2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZSddLCBmcm9tQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2l6ZUJ5dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzaXplQnl0ZXMnXSk7XG4gICAgaWYgKGZyb21TaXplQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaXplQnl0ZXMnXSwgZnJvbVNpemVCeXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhwaXJhdGlvblRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleHBpcmF0aW9uVGltZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeHBpcmF0aW9uVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4cGlyYXRpb25UaW1lJ10sIGZyb21FeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2hhMjU2SGFzaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2hhMjU2SGFzaCddKTtcbiAgICBpZiAoZnJvbVNoYTI1Nkhhc2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzaGEyNTZIYXNoJ10sIGZyb21TaGEyNTZIYXNoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG93bmxvYWRVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rvd25sb2FkVXJpJ10pO1xuICAgIGlmIChmcm9tRG93bmxvYWRVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb3dubG9hZFVyaSddLCBmcm9tRG93bmxvYWRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXRlJ10pO1xuICAgIGlmIChmcm9tU3RhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0ZSddLCBmcm9tU3RhdGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzb3VyY2UnXSwgZnJvbVNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCBmcm9tVmlkZW9NZXRhZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZpbGVTdGF0dXNUb01sZGV2KGZyb21FcnJvcikpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRGaWxlUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdmaWxlJ10sIHRGaWxlTmFtZShmcm9tTmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0RmlsZXNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdEZpbGVzUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdEZpbGVzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVzJ10pO1xuICAgIGlmIChmcm9tRmlsZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZpbGVzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIEZpbGVzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgYWxsIGN1cnJlbnQgcHJvamVjdCBmaWxlcyBmcm9tIHRoZSBzZXJ2aWNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBsaXN0IHJlcXVlc3RcbiAgICAgICAgICogQHJldHVybiBUaGUgcGFnaW5hdGVkIHJlc3VsdHMgb2YgdGhlIGxpc3Qgb2YgZmlsZXNcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHByaW50cyB0aGUgbmFtZXMgb2YgYWxsIGZpbGVzIGZyb20gdGhlIHNlcnZpY2UsIHRoZVxuICAgICAgICAgKiBzaXplIG9mIGVhY2ggcGFnZSBpcyAxMC5cbiAgICAgICAgICpcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgbGlzdFJlc3BvbnNlID0gYXdhaXQgYWkuZmlsZXMubGlzdCh7Y29uZmlnOiB7J3BhZ2VTaXplJzogMTB9fSk7XG4gICAgICAgICAqIGZvciBhd2FpdCAoY29uc3QgZmlsZSBvZiBsaXN0UmVzcG9uc2UpIHtcbiAgICAgICAgICogICBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saXN0ID0gYXN5bmMgKHBhcmFtcyA9IHt9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBhZ2VyKFBhZ2VkSXRlbS5QQUdFRF9JVEVNX0ZJTEVTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKHBhcmFtcyksIHBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBHZW1pbmkgQVBJLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBhdmFpbGFibGUgaW4gVmVydGV4IEFJLlxuICAgICAqIFN1cHBvcnRlZCB1cGxvYWQgc291cmNlczpcbiAgICAgKiAtIE5vZGUuanM6IEZpbGUgcGF0aCAoc3RyaW5nKSBvciBCbG9iIG9iamVjdC5cbiAgICAgKiAtIEJyb3dzZXI6IEJsb2Igb2JqZWN0IChlLmcuLCBGaWxlKS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIGBtaW1lVHlwZWAgY2FuIGJlIHNwZWNpZmllZCBpbiB0aGUgYGNvbmZpZ2AgcGFyYW1ldGVyLiBJZiBvbWl0dGVkOlxuICAgICAqICAtIEZvciBmaWxlIHBhdGggKHN0cmluZykgaW5wdXRzLCB0aGUgYG1pbWVUeXBlYCB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlXG4gICAgICogICAgIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAqICAtIEZvciBCbG9iIG9iamVjdCBpbnB1dHMsIHRoZSBgbWltZVR5cGVgIHdpbGwgYmUgc2V0IHRvIHRoZSBCbG9iJ3MgYHR5cGVgXG4gICAgICogICAgIHByb3BlcnR5LlxuICAgICAqIFNvbWV4IGVhbXBsZXMgZm9yIGZpbGUgZXh0ZW5zaW9uIHRvIG1pbWVUeXBlIG1hcHBpbmc6XG4gICAgICogLnR4dCAtPiB0ZXh0L3BsYWluXG4gICAgICogLmpzb24gLT4gYXBwbGljYXRpb24vanNvblxuICAgICAqIC5qcGcgIC0+IGltYWdlL2pwZWdcbiAgICAgKiAucG5nIC0+IGltYWdlL3BuZ1xuICAgICAqIC5tcDMgLT4gYXVkaW8vbXBlZ1xuICAgICAqIC5tcDQgLT4gdmlkZW8vbXA0XG4gICAgICpcbiAgICAgKiBUaGlzIHNlY3Rpb24gY2FuIGNvbnRhaW4gbXVsdGlwbGUgcGFyYWdyYXBocyBhbmQgY29kZSBleGFtcGxlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGVcbiAgICAgKiAgICAgICAgYHR5cGVzLlVwbG9hZEZpbGVQYXJhbWV0ZXJzYCBpbnRlcmZhY2UuXG4gICAgICogICAgICAgICBAc2VlIHtAbGluayB0eXBlcy5VcGxvYWRGaWxlUGFyYW1ldGVycyNjb25maWd9IGZvciB0aGUgb3B0aW9uYWxcbiAgICAgKiAgICAgICAgIGNvbmZpZyBpbiB0aGUgcGFyYW1ldGVycy5cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYHR5cGVzLkZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICogdGhlIGBtaW1lVHlwZWAgY2FuIGJlIHByb3ZpZGVkIGluIHRoZSBgcGFyYW1zLmNvbmZpZ2AgcGFyYW1ldGVyLlxuICAgICAqIEB0aHJvd3MgQW4gZXJyb3Igb2NjdXJzIGlmIGEgc3VpdGFibGUgdXBsb2FkIGxvY2F0aW9uIGNhbm5vdCBiZSBlc3RhYmxpc2hlZC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogVGhlIGZvbGxvd2luZyBjb2RlIHVwbG9hZHMgYSBmaWxlIHRvIEdlbWluaSBBUEkuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGZpbGUgPSBhd2FpdCBhaS5maWxlcy51cGxvYWQoe2ZpbGU6ICdmaWxlLnR4dCcsIGNvbmZpZzoge1xuICAgICAqICAgbWltZVR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgKiB9fSk7XG4gICAgICogY29uc29sZS5sb2coZmlsZS5uYW1lKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWQocGFyYW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVmVydGV4IEFJIGRvZXMgbm90IHN1cHBvcnQgdXBsb2FkaW5nIGZpbGVzLiBZb3UgY2FuIHNoYXJlIGZpbGVzIHRocm91Z2ggYSBHQ1MgYnVja2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgLnVwbG9hZEZpbGUocGFyYW1zLmZpbGUsIHBhcmFtcy5jb25maWcpXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBmaWxlRnJvbU1sZGV2KHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHJldHVybiBmaWxlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRG93bmxvYWRzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUgYXN5bmNocm9ub3VzbHkgdG8gYSBsb2NhdGlvbiBzcGVjaWZpZWQgaW5cbiAgICAgKiB0aGUgYHBhcmFtc2Agb2JqZWN0LiBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIG9uIE5vZGUgZW52aXJvbm1lbnQsIHRvXG4gICAgICogZG93bmxvYWQgZmlsZXMgaW4gdGhlIGJyb3dzZXIsIHVzZSBhIGJyb3dzZXIgY29tcGxpYW50IG1ldGhvZCBsaWtlIGFuIDxhPlxuICAgICAqIHRhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGRvd25sb2FkIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkb3dubG9hZHMgYW4gZXhhbXBsZSBmaWxlIG5hbWVkIFwiZmlsZXMvbWVob3pweGY4NzdkXCIgYXNcbiAgICAgKiBcImZpbGUudHh0XCIuXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGF3YWl0IGFpLmZpbGVzLmRvd25sb2FkKHtmaWxlOiBmaWxlLm5hbWUsIGRvd25sb2FkUGF0aDogJ2ZpbGUudHh0J30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRvd25sb2FkKHBhcmFtcykge1xuICAgICAgICBhd2FpdCB0aGlzLmFwaUNsaWVudC5kb3dubG9hZEZpbGUocGFyYW1zKTtcbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0RmlsZXNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RGaWxlc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdEZpbGVzUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVGaWxlUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNyZWF0ZUZpbGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IENyZWF0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmaWxlIGluZm9ybWF0aW9uIGZyb20gdGhlIHNlcnZpY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgcmVxdWVzdFxuICAgICAqIEByZXR1cm4gVGhlIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgdHlwZXMuRmlsZSBvYmplY3QgcmVxdWVzdGVkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IGNvbmZpZzogR2V0RmlsZVBhcmFtZXRlcnMgPSB7XG4gICAgICogICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgKiB9O1xuICAgICAqIGZpbGUgPSBhd2FpdCBhaS5maWxlcy5nZXQoY29uZmlnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhmaWxlLm5hbWUpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0RmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcy97ZmlsZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZmlsZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEgcmVtb3RlbHkgc3RvcmVkIGZpbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkZWxldGUgcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSBEZWxldGVGaWxlUmVzcG9uc2UsIHRoZSByZXNwb25zZSBmb3IgdGhlIGRlbGV0ZSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIFRoZSBmb2xsb3dpbmcgY29kZSBkZWxldGVzIGFuIGV4YW1wbGUgZmlsZSBuYW1lZCBcImZpbGVzL21laG96cHhmODc3ZFwiLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBhaS5maWxlcy5kZWxldGUoe25hbWU6IGZpbGUubmFtZX0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGRlbGV0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZGVsZXRlRmlsZVBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCdmaWxlcy97ZmlsZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZUZpbGVSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZUZpbGVSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGFjdGl2aXR5RW5kVG9NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGFjdGl2aXR5RW5kVG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhY3Rpdml0eVN0YXJ0VG9NbGRldigpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGFjdGl2aXR5U3RhcnRUb1ZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGFwaUtleUNvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleVN0cmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5U3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10sIGZyb21BcGlLZXlTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb0NodW5rRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzb3VyY2VNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Tb3VyY2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NvdXJjZU1ldGFkYXRhJ10sIGxpdmVNdXNpY1NvdXJjZU1ldGFkYXRhRnJvbU1sZGV2KGZyb21Tb3VyY2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2JDEoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCgpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dGhDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BcGlLZXlDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUFwaUtleUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FwaUtleUNvbmZpZyddLCBhcGlLZXlDb25maWdUb1ZlcnRleCQxKGZyb21BcGlLZXlDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dGhUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoVHlwZSddKTtcbiAgICBpZiAoZnJvbUF1dGhUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aFR5cGUnXSwgZnJvbUF1dGhUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyddLCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2h0dHBCYXNpY0F1dGhDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2h0dHBCYXNpY0F1dGhDb25maWcnXSwgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvYXV0aENvbmZpZyddLCBmcm9tT2F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2lkY0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2lkY0NvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9pZGNDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvaWRjQ29uZmlnJ10sIGZyb21PaWRjQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc2FibGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNhYmxlZCddKTtcbiAgICBpZiAoZnJvbURpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzYWJsZWQnXSwgZnJvbURpc2FibGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmaXhQYWRkaW5nTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmaXhQYWRkaW5nTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZml4UGFkZGluZ01zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZml4UGFkZGluZ01zJ10sIGZyb21QcmVmaXhQYWRkaW5nTXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzaWxlbmNlRHVyYXRpb25NcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TaWxlbmNlRHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpbGVuY2VEdXJhdGlvbk1zJ10sIGZyb21TaWxlbmNlRHVyYXRpb25Ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc2FibGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNhYmxlZCddKTtcbiAgICBpZiAoZnJvbURpc2FibGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzYWJsZWQnXSwgZnJvbURpc2FibGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mU3BlZWNoU2Vuc2l0aXZpdHknXSwgZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tRW5kT2ZTcGVlY2hTZW5zaXRpdml0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QcmVmaXhQYWRkaW5nTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVmaXhQYWRkaW5nTXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlZml4UGFkZGluZ01zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlZml4UGFkZGluZ01zJ10sIGZyb21QcmVmaXhQYWRkaW5nTXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2lsZW5jZUR1cmF0aW9uTXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzaWxlbmNlRHVyYXRpb25NcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TaWxlbmNlRHVyYXRpb25NcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NpbGVuY2VEdXJhdGlvbk1zJ10sIGZyb21TaWxlbmNlRHVyYXRpb25Ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlclVzZVRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRW52aXJvbm1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vudmlyb25tZW50J10pO1xuICAgIGlmIChmcm9tRW52aXJvbm1lbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnZpcm9ubWVudCddLCBmcm9tRW52aXJvbm1lbnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyddLCBmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZXJVc2VUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJ10sIGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRGcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDIoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0VG9WZXJ0ZXgkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Sb2xlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyb2xlJ10pO1xuICAgIGlmIChmcm9tUm9sZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvbGUnXSwgZnJvbVJvbGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRyaWdnZXJUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmlnZ2VyVG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyaWdnZXJUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmlnZ2VyVG9rZW5zJ10sIGZyb21UcmlnZ2VyVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNsaWRpbmdXaW5kb3cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzbGlkaW5nV2luZG93JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNsaWRpbmdXaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzbGlkaW5nV2luZG93J10sIHNsaWRpbmdXaW5kb3dUb01sZGV2JDEoZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRyaWdnZXJUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0cmlnZ2VyVG9rZW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyaWdnZXJUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0cmlnZ2VyVG9rZW5zJ10sIGZyb21UcmlnZ2VyVG9rZW5zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNsaWRpbmdXaW5kb3cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzbGlkaW5nV2luZG93JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNsaWRpbmdXaW5kb3cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzbGlkaW5nV2luZG93J10sIHNsaWRpbmdXaW5kb3dUb1ZlcnRleChmcm9tU2xpZGluZ1dpbmRvdykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHluYW1pY1RocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1RocmVzaG9sZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNUaHJlc2hvbGQnXSwgZnJvbUR5bmFtaWNUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YUZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbEZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsRnJvbVZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkJ10pO1xuICAgIGlmIChmcm9tSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZCddLCBmcm9tSWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXJncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXJncyddKTtcbiAgICBpZiAoZnJvbUFyZ3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhcmdzJ10sIGZyb21BcmdzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJlaGF2aW9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKTtcbiAgICBpZiAoZnJvbUJlaGF2aW9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmVoYXZpb3InXSwgZnJvbUJlaGF2aW9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmVoYXZpb3IgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZU1hcHNUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhDb25maWcnXSwgYXV0aENvbmZpZ1RvVmVydGV4JDEoZnJvbUF1dGhDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlU2VhcmNoUmV0cmlldmFsVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1JldHJpZXZhbENvbmZpZyddLCBkeW5hbWljUmV0cmlldmFsQ29uZmlnVG9NbGRldiQyKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleCQxKGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYkMihmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UaW1lUmFuZ2VGaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aW1lUmFuZ2VGaWx0ZXInLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGltZVJhbmdlRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGltZVJhbmdlRmlsdGVyJ10sIGludGVydmFsVG9WZXJ0ZXgkMShmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlRG9tYWlucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVEb21haW5zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4Y2x1ZGVEb21haW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSwgZnJvbUV4Y2x1ZGVEb21haW5zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW50ZXJ2YWxUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZyddLCBmcm9tR2VuZXJhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1vZGFsaXRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAncmVzcG9uc2VNb2RhbGl0aWVzJ10sIGZyb21SZXNwb25zZU1vZGFsaXRpZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wUCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wUCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcFAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BQJ10sIGZyb21Ub3BQKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcEsgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcEsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub3BLICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAndG9wSyddLCBmcm9tVG9wSyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWVkaWFSZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWVkaWFSZXNvbHV0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1lZGlhUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ21lZGlhUmVzb2x1dGlvbiddLCBmcm9tTWVkaWFSZXNvbHV0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2JDIodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMihmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuYWJsZUFmZmVjdGl2ZURpYWxvZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnXSwgZnJvbUVuYWJsZUFmZmVjdGl2ZURpYWxvZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb01sZGV2JDIodENvbnRlbnQoZnJvbVN5c3RlbUluc3RydWN0aW9uKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2JDEoZnJvbVNlc3Npb25SZXN1bXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2lucHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJ10sIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYkMSgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCByZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiQxKGZyb21SZWFsdGltZUlucHV0Q29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbiddLCBjb250ZXh0V2luZG93Q29tcHJlc3Npb25Db25maWdUb01sZGV2JDEoZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvYWN0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb2FjdGl2aXR5J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvYWN0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncHJvYWN0aXZpdHknXSwgcHJvYWN0aXZpdHlDb25maWdUb01sZGV2JDEoZnJvbVByb2FjdGl2aXR5KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvVmVydGV4JDEodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9WZXJ0ZXgkMSh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9WZXJ0ZXgkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb1ZlcnRleChmcm9tU2Vzc2lvblJlc3VtcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnaW5wdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9WZXJ0ZXgoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ291dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCByZWFsdGltZUlucHV0Q29uZmlnVG9WZXJ0ZXgoZnJvbVJlYWx0aW1lSW5wdXRDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvbnRleHRXaW5kb3dDb21wcmVzc2lvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJ10sIGNvbnRleHRXaW5kb3dDb21wcmVzc2lvbkNvbmZpZ1RvVmVydGV4KGZyb21Db250ZXh0V2luZG93Q29tcHJlc3Npb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb2FjdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9hY3Rpdml0eSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb2FjdGl2aXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ3Byb2FjdGl2aXR5J10sIHByb2FjdGl2aXR5Q29uZmlnVG9WZXJ0ZXgoZnJvbVByb2FjdGl2aXR5KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29uZmlnJ10sIGxpdmVDb25uZWN0Q29uZmlnVG9NbGRldiQxKGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0UGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0NsaWVudENvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVdlaWdodGVkUHJvbXB0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3dlaWdodGVkUHJvbXB0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21XZWlnaHRlZFByb21wdHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVdlaWdodGVkUHJvbXB0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB3ZWlnaHRlZFByb21wdEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodGVkUHJvbXB0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRDb250ZW50VG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tV2VpZ2h0ZWRQcm9tcHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2VpZ2h0ZWRQcm9tcHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdlaWdodGVkUHJvbXB0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tV2VpZ2h0ZWRQcm9tcHRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodGVkUHJvbXB0VG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodGVkUHJvbXB0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRNZXNzYWdlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2V0dXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NldHVwJ10pO1xuICAgIGlmIChmcm9tU2V0dXAgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cCddLCBsaXZlTXVzaWNDbGllbnRTZXR1cFRvTWxkZXYoZnJvbVNldHVwKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DbGllbnRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2xpZW50Q29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DbGllbnRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2xpZW50Q29udGVudCddLCBsaXZlTXVzaWNDbGllbnRDb250ZW50VG9NbGRldihmcm9tQ2xpZW50Q29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211c2ljR2VuZXJhdGlvbkNvbmZpZyddLCBsaXZlTXVzaWNHZW5lcmF0aW9uQ29uZmlnVG9NbGRldihmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QbGF5YmFja0NvbnRyb2wgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwbGF5YmFja0NvbnRyb2wnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGxheWJhY2tDb250cm9sICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGxheWJhY2tDb250cm9sJ10sIGZyb21QbGF5YmFja0NvbnRyb2wpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNDbGllbnRTZXR1cFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWwnXSwgZnJvbU1vZGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljRmlsdGVyZWRQcm9tcHRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXJlZFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2ZpbHRlcmVkUmVhc29uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbHRlcmVkUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsdGVyZWRSZWFzb24nXSwgZnJvbUZpbHRlcmVkUmVhc29uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGVtcGVyYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10pO1xuICAgIGlmIChmcm9tVGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZW1wZXJhdHVyZSddLCBmcm9tVGVtcGVyYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAoZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HdWlkYW5jZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ3VpZGFuY2UnXSk7XG4gICAgaWYgKGZyb21HdWlkYW5jZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2d1aWRhbmNlJ10sIGZyb21HdWlkYW5jZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcG0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JwbSddKTtcbiAgICBpZiAoZnJvbUJwbSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JwbSddLCBmcm9tQnBtKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlbnNpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlbnNpdHknXSk7XG4gICAgaWYgKGZyb21EZW5zaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVuc2l0eSddLCBmcm9tRGVuc2l0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CcmlnaHRuZXNzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydicmlnaHRuZXNzJ10pO1xuICAgIGlmIChmcm9tQnJpZ2h0bmVzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSwgZnJvbUJyaWdodG5lc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NjYWxlJ10pO1xuICAgIGlmIChmcm9tU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY2FsZSddLCBmcm9tU2NhbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZUJhc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVCYXNzJ10pO1xuICAgIGlmIChmcm9tTXV0ZUJhc3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlQmFzcyddLCBmcm9tTXV0ZUJhc3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXV0ZURydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtdXRlRHJ1bXMnXSk7XG4gICAgaWYgKGZyb21NdXRlRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXRlRHJ1bXMnXSwgZnJvbU11dGVEcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Pbmx5QmFzc0FuZERydW1zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb25seUJhc3NBbmREcnVtcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Pbmx5QmFzc0FuZERydW1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb25seUJhc3NBbmREcnVtcyddLCBmcm9tT25seUJhc3NBbmREcnVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uTW9kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVzaWNHZW5lcmF0aW9uTW9kZSddLCBmcm9tTXVzaWNHZW5lcmF0aW9uTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVNdXNpY0dlbmVyYXRpb25Db25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAoZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydndWlkYW5jZSddKTtcbiAgICBpZiAoZnJvbUd1aWRhbmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3VpZGFuY2UnXSwgZnJvbUd1aWRhbmNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJwbSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYnBtJ10pO1xuICAgIGlmIChmcm9tQnBtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnBtJ10sIGZyb21CcG0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVuc2l0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVuc2l0eSddKTtcbiAgICBpZiAoZnJvbURlbnNpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZW5zaXR5J10sIGZyb21EZW5zaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJyaWdodG5lc3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JyaWdodG5lc3MnXSk7XG4gICAgaWYgKGZyb21CcmlnaHRuZXNzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYnJpZ2h0bmVzcyddLCBmcm9tQnJpZ2h0bmVzcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY2FsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2NhbGUnXSk7XG4gICAgaWYgKGZyb21TY2FsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NjYWxlJ10sIGZyb21TY2FsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXRlQmFzcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXV0ZUJhc3MnXSk7XG4gICAgaWYgKGZyb21NdXRlQmFzcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211dGVCYXNzJ10sIGZyb21NdXRlQmFzcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdXRlRHJ1bXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ211dGVEcnVtcyddKTtcbiAgICBpZiAoZnJvbU11dGVEcnVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211dGVEcnVtcyddLCBmcm9tTXV0ZURydW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU9ubHlCYXNzQW5kRHJ1bXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvbmx5QmFzc0FuZERydW1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU9ubHlCYXNzQW5kRHJ1bXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvbmx5QmFzc0FuZERydW1zJ10sIGZyb21Pbmx5QmFzc0FuZERydW1zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbk1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdXNpY0dlbmVyYXRpb25Nb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11c2ljR2VuZXJhdGlvbk1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Nb2RlJ10sIGZyb21NdXNpY0dlbmVyYXRpb25Nb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2VydmVyQ29udGVudEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXVkaW9DaHVua3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvQ2h1bmtzJ10pO1xuICAgIGlmIChmcm9tQXVkaW9DaHVua3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUF1ZGlvQ2h1bmtzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF1ZGlvQ2h1bmtGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb0NodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZXR1cENvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2V0dXBDb21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXR1cENvbXBsZXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXBDb21wbGV0ZSddLCBsaXZlTXVzaWNTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgbGl2ZU11c2ljU2VydmVyQ29udGVudEZyb21NbGRldihmcm9tU2VydmVyQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyZWRQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaWx0ZXJlZFByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GaWx0ZXJlZFByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbHRlcmVkUHJvbXB0J10sIGxpdmVNdXNpY0ZpbHRlcmVkUHJvbXB0RnJvbU1sZGV2KGZyb21GaWx0ZXJlZFByb21wdCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZU11c2ljU2V0Q29uZmlnUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211c2ljR2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdXNpY0dlbmVyYXRpb25Db25maWcnXSwgbGl2ZU11c2ljR2VuZXJhdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tV2VpZ2h0ZWRQcm9tcHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2VpZ2h0ZWRQcm9tcHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdlaWdodGVkUHJvbXB0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tV2VpZ2h0ZWRQcm9tcHRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdlaWdodGVkUHJvbXB0VG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodGVkUHJvbXB0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlTXVzaWNTb3VyY2VNZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2xpZW50Q29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NsaWVudENvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2xpZW50Q29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NsaWVudENvbnRlbnQnXSwgbGl2ZU11c2ljQ2xpZW50Q29udGVudEZyb21NbGRldihmcm9tQ2xpZW50Q29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVzaWNHZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVzaWNHZW5lcmF0aW9uQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11c2ljR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211c2ljR2VuZXJhdGlvbkNvbmZpZyddLCBsaXZlTXVzaWNHZW5lcmF0aW9uQ29uZmlnRnJvbU1sZGV2KGZyb21NdXNpY0dlbmVyYXRpb25Db25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1lZGlhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZWRpYSddKTtcbiAgICBpZiAoZnJvbU1lZGlhICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRCbG9icyhmcm9tTWVkaWEpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYUNodW5rcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2F1ZGlvJ10pO1xuICAgIGlmIChmcm9tQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpbyddLCB0QXVkaW9CbG9iKGZyb21BdWRpbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9TdHJlYW1FbmQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1N0cmVhbUVuZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1N0cmVhbUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvU3RyZWFtRW5kJ10sIGZyb21BdWRpb1N0cmVhbUVuZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHRJbWFnZUJsb2IoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWN0aXZpdHlTdGFydCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2FjdGl2aXR5U3RhcnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQWN0aXZpdHlTdGFydCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5U3RhcnQnXSwgYWN0aXZpdHlTdGFydFRvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUVuZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUVuZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FjdGl2aXR5RW5kJ10sIGFjdGl2aXR5RW5kVG9NbGRldigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21NZWRpYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWVkaWEnXSk7XG4gICAgaWYgKGZyb21NZWRpYSAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0QmxvYnMoZnJvbU1lZGlhKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFDaHVua3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpbyddKTtcbiAgICBpZiAoZnJvbUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXVkaW8nXSwgdEF1ZGlvQmxvYihmcm9tQXVkaW8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1ZGlvU3RyZWFtRW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYXVkaW9TdHJlYW1FbmQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQXVkaW9TdHJlYW1FbmQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhdWRpb1N0cmVhbUVuZCddLCBmcm9tQXVkaW9TdHJlYW1FbmQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlbyddLCB0SW1hZ2VCbG9iKGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5U3RhcnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eVN0YXJ0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eVN0YXJ0J10sIGFjdGl2aXR5U3RhcnRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5RW5kID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhY3Rpdml0eUVuZCddKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5RW5kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlFbmQnXSwgYWN0aXZpdHlFbmRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckNvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsVHVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxUdXJuJ10pO1xuICAgIGlmIChmcm9tTW9kZWxUdXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxUdXJuJ10sIGNvbnRlbnRGcm9tTWxkZXYkMShmcm9tTW9kZWxUdXJuKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db21wbGV0ZSddLCBmcm9tVHVybkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUludGVycnVwdGVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbnRlcnJ1cHRlZCddKTtcbiAgICBpZiAoZnJvbUludGVycnVwdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSwgZnJvbUludGVycnVwdGVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRpb25Db21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db21wbGV0ZSddLCBmcm9tR2VuZXJhdGlvbkNvbXBsZXRlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlucHV0VHJhbnNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2lucHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbnB1dFRyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnB1dFRyYW5zY3JpcHRpb24nXSwgdHJhbnNjcmlwdGlvbkZyb21NbGRldihmcm9tSW5wdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0VHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VHJhbnNjcmlwdGlvbiddLCB0cmFuc2NyaXB0aW9uRnJvbU1sZGV2KGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0TWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxDb250ZXh0TWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dE1ldGFkYXRhJ10sIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldiQxKGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db21wbGV0ZVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1cm5Db21wbGV0ZVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UdXJuQ29tcGxldGVSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ29tcGxldGVSZWFzb24nXSwgZnJvbVR1cm5Db21wbGV0ZVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21XYWl0aW5nRm9ySW5wdXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd3YWl0aW5nRm9ySW5wdXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tV2FpdGluZ0ZvcklucHV0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnd2FpdGluZ0ZvcklucHV0J10sIGZyb21XYWl0aW5nRm9ySW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyQ29udGVudEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsVHVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxUdXJuJ10pO1xuICAgIGlmIChmcm9tTW9kZWxUdXJuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxUdXJuJ10sIGNvbnRlbnRGcm9tVmVydGV4JDEoZnJvbU1vZGVsVHVybikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVybkNvbXBsZXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dXJuQ29tcGxldGUnXSk7XG4gICAgaWYgKGZyb21UdXJuQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dXJuQ29tcGxldGUnXSwgZnJvbVR1cm5Db21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnRlcnJ1cHRlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW50ZXJydXB0ZWQnXSk7XG4gICAgaWYgKGZyb21JbnRlcnJ1cHRlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ludGVycnVwdGVkJ10sIGZyb21JbnRlcnJ1cHRlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hcm91bmRpbmdNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dyb3VuZGluZ01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdyb3VuZGluZ01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ3JvdW5kaW5nTWV0YWRhdGEnXSwgZnJvbUdyb3VuZGluZ01ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db21wbGV0ZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0aW9uQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29tcGxldGUnXSwgZnJvbUdlbmVyYXRpb25Db21wbGV0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRyYW5zY3JpcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUcmFuc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUcmFuc2NyaXB0aW9uJ10sIHRyYW5zY3JpcHRpb25Gcm9tVmVydGV4KGZyb21JbnB1dFRyYW5zY3JpcHRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFRyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRUcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU91dHB1dFRyYW5zY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXRUcmFuc2NyaXB0aW9uJ10sIHRyYW5zY3JpcHRpb25Gcm9tVmVydGV4KGZyb21PdXRwdXRUcmFuc2NyaXB0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ29tcGxldGVSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dXJuQ29tcGxldGVSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVybkNvbXBsZXRlUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvbXBsZXRlUmVhc29uJ10sIGZyb21UdXJuQ29tcGxldGVSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tV2FpdGluZ0ZvcklucHV0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnd2FpdGluZ0ZvcklucHV0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVdhaXRpbmdGb3JJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dhaXRpbmdGb3JJbnB1dCddLCBmcm9tV2FpdGluZ0ZvcklucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlckdvQXdheUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZUxlZnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpbWVMZWZ0J10pO1xuICAgIGlmIChmcm9tVGltZUxlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lTGVmdCddLCBmcm9tVGltZUxlZnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyR29Bd2F5RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZUxlZnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RpbWVMZWZ0J10pO1xuICAgIGlmIChmcm9tVGltZUxlZnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lTGVmdCddLCBmcm9tVGltZUxlZnQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2V0dXBDb21wbGV0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NldHVwQ29tcGxldGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2V0dXBDb21wbGV0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NldHVwQ29tcGxldGUnXSwgbGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXJ2ZXJDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2VydmVyQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2ZXJDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VydmVyQ29udGVudCddLCBsaXZlU2VydmVyQ29udGVudEZyb21NbGRldihmcm9tU2VydmVyQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbENhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDYWxsJ10pO1xuICAgIGlmIChmcm9tVG9vbENhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sQ2FsbCddLCBsaXZlU2VydmVyVG9vbENhbGxGcm9tTWxkZXYoZnJvbVRvb2xDYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGxDYW5jZWxsYXRpb24nXSwgbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbU1sZGV2KGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNhZ2VNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VzYWdlTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXNhZ2VNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VzYWdlTWV0YWRhdGEnXSwgdXNhZ2VNZXRhZGF0YUZyb21NbGRldihmcm9tVXNhZ2VNZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29Bd2F5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb0F3YXknXSk7XG4gICAgaWYgKGZyb21Hb0F3YXkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb0F3YXknXSwgbGl2ZVNlcnZlckdvQXdheUZyb21NbGRldihmcm9tR29Bd2F5KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnXSwgbGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbU1sZGV2KGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlU2VydmVyTWVzc2FnZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNldHVwQ29tcGxldGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXR1cENvbXBsZXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNldHVwQ29tcGxldGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZXR1cENvbXBsZXRlJ10sIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbVZlcnRleChmcm9tU2V0dXBDb21wbGV0ZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmVyQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlcnZlckNvbnRlbnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VydmVyQ29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZlckNvbnRlbnQnXSwgbGl2ZVNlcnZlckNvbnRlbnRGcm9tVmVydGV4KGZyb21TZXJ2ZXJDb250ZW50KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbENhbGwnXSk7XG4gICAgaWYgKGZyb21Ub29sQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xDYWxsJ10sIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21WZXJ0ZXgoZnJvbVRvb2xDYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29sQ2FsbENhbmNlbGxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rvb2xDYWxsQ2FuY2VsbGF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRvb2xDYWxsQ2FuY2VsbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9vbENhbGxDYW5jZWxsYXRpb24nXSwgbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbVZlcnRleChmcm9tVG9vbENhbGxDYW5jZWxsYXRpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21Vc2FnZU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb0F3YXkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvQXdheSddKTtcbiAgICBpZiAoZnJvbUdvQXdheSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvQXdheSddLCBsaXZlU2VydmVyR29Bd2F5RnJvbVZlcnRleChmcm9tR29Bd2F5KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZXNzaW9uUmVzdW1wdGlvblVwZGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nlc3Npb25SZXN1bXB0aW9uVXBkYXRlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNlc3Npb25SZXN1bXB0aW9uVXBkYXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2Vzc2lvblJlc3VtcHRpb25VcGRhdGUnXSwgbGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbVZlcnRleChmcm9tU2Vzc2lvblJlc3VtcHRpb25VcGRhdGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OZXdIYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25ld0hhbmRsZSddKTtcbiAgICBpZiAoZnJvbU5ld0hhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25ld0hhbmRsZSddLCBmcm9tTmV3SGFuZGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3VtYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzdW1hYmxlJ10pO1xuICAgIGlmIChmcm9tUmVzdW1hYmxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzdW1hYmxlJ10sIGZyb21SZXN1bWFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCddLCBmcm9tTGFzdENvbnN1bWVkQ2xpZW50TWVzc2FnZUluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclNlc3Npb25SZXN1bXB0aW9uVXBkYXRlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmV3SGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduZXdIYW5kbGUnXSk7XG4gICAgaWYgKGZyb21OZXdIYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXdIYW5kbGUnXSwgZnJvbU5ld0hhbmRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXN1bWFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Jlc3VtYWJsZSddKTtcbiAgICBpZiAoZnJvbVJlc3VtYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3VtYWJsZSddLCBmcm9tUmVzdW1hYmxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXN0Q29uc3VtZWRDbGllbnRNZXNzYWdlSW5kZXgnXSwgZnJvbUxhc3RDb25zdW1lZENsaWVudE1lc3NhZ2VJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJTZXR1cENvbXBsZXRlRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclNldHVwQ29tcGxldGVGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZXNzaW9uSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Nlc3Npb25JZCddKTtcbiAgICBpZiAoZnJvbVNlc3Npb25JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nlc3Npb25JZCddLCBmcm9tU2Vzc2lvbklkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lkcyddKTtcbiAgICBpZiAoZnJvbUlkcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkcyddLCBmcm9tSWRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsQ2FuY2VsbGF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSWRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZHMnXSk7XG4gICAgaWYgKGZyb21JZHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpZHMnXSwgZnJvbUlkcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVTZXJ2ZXJUb29sQ2FsbEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25DYWxscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGl2ZVNlcnZlclRvb2xDYWxsRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uQ2FsbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25DYWxscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxGcm9tVmVydGV4JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGFsaXR5VG9rZW5Db3VudEZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGFsaXR5J10pO1xuICAgIGlmIChmcm9tTW9kYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RhbGl0eSddLCBmcm9tTW9kYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGFsaXR5J10pO1xuICAgIGlmIChmcm9tTW9kYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RhbGl0eSddLCBmcm9tTW9kYWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5Db3VudCddKTtcbiAgICBpZiAoZnJvbVRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b2tlbkNvdW50J10sIGZyb21Ub2tlbkNvdW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDIoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzcGVha2VyVm9pY2VDb25maWdzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3MgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVNwZWFrZXJWb2ljZUNvbmZpZ3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldiQyKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlclZvaWNlQ29uZmlncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwYXJ0RnJvbU1sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iRnJvbU1sZGV2JDEoZnJvbUlubGluZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlRGF0YSddKTtcbiAgICBpZiAoZnJvbUZpbGVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZURhdGEnXSwgZmlsZURhdGFGcm9tTWxkZXYkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbEZyb21NbGRldiQxKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydEZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgkMShmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iRnJvbVZlcnRleCQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhRnJvbVZlcnRleCQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsRnJvbVZlcnRleCQxKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYkMihmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQyKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQyKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQyKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFUb1ZlcnRleCQxKGZyb21WaWRlb01ldGFkYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aG91Z2h0J10pO1xuICAgIGlmIChmcm9tVGhvdWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHQnXSwgZnJvbVRob3VnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5saW5lRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW5saW5lRGF0YSddKTtcbiAgICBpZiAoZnJvbUlubGluZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmxpbmVEYXRhJ10sIGJsb2JUb1ZlcnRleCQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgkMShmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbFRvVmVydGV4JDEoZnJvbUZ1bmN0aW9uQ2FsbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NvZGVFeGVjdXRpb25SZXN1bHQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvZGVFeGVjdXRpb25SZXN1bHQnXSwgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhlY3V0YWJsZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGVjdXRhYmxlQ29kZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGVjdXRhYmxlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4ZWN1dGFibGVDb2RlJ10sIGZyb21FeGVjdXRhYmxlQ29kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvblJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvblJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25SZXNwb25zZSddLCBmcm9tRnVuY3Rpb25SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlTmFtZSddKTtcbiAgICBpZiAoZnJvbVZvaWNlTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlTmFtZSddLCBmcm9tVm9pY2VOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvYWN0aXZlQXVkaW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9hY3RpdmVBdWRpbycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9hY3RpdmVBdWRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb2FjdGl2ZUF1ZGlvJ10sIGZyb21Qcm9hY3RpdmVBdWRpbyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByb2FjdGl2aXR5Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2FjdGl2ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvYWN0aXZlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvYWN0aXZlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9hY3RpdmVBdWRpbyddLCBmcm9tUHJvYWN0aXZlQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24nXSwgYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub01sZGV2JDEoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BY3Rpdml0eUhhbmRsaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYWN0aXZpdHlIYW5kbGluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BY3Rpdml0eUhhbmRsaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYWN0aXZpdHlIYW5kbGluZyddLCBmcm9tQWN0aXZpdHlIYW5kbGluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdXJuQ292ZXJhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddKTtcbiAgICBpZiAoZnJvbVR1cm5Db3ZlcmFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1cm5Db3ZlcmFnZSddLCBmcm9tVHVybkNvdmVyYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVhbHRpbWVJbnB1dENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24nXSwgYXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb25Ub1ZlcnRleChmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5SGFuZGxpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eUhhbmRsaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5SGFuZGxpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUhhbmRsaW5nJ10sIGZyb21BY3Rpdml0eUhhbmRsaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db3ZlcmFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVybkNvdmVyYWdlJ10pO1xuICAgIGlmIChmcm9tVHVybkNvdmVyYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvdmVyYWdlJ10sIGZyb21UdXJuQ292ZXJhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSGFuZGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydoYW5kbGUnXSk7XG4gICAgaWYgKGZyb21IYW5kbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydoYW5kbGUnXSwgZnJvbUhhbmRsZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RyYW5zcGFyZW50J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFuc3BhcmVudCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2hhbmRsZSddKTtcbiAgICBpZiAoZnJvbUhhbmRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2hhbmRsZSddLCBmcm9tSGFuZGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRyYW5zcGFyZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKTtcbiAgICBpZiAoZnJvbVRyYW5zcGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJhbnNwYXJlbnQnXSwgZnJvbVRyYW5zcGFyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFyZ2V0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21UYXJnZXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSwgZnJvbVRhcmdldFRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3dUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFyZ2V0VG9rZW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSk7XG4gICAgaWYgKGZyb21UYXJnZXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0YXJnZXRUb2tlbnMnXSwgZnJvbVRhcmdldFRva2Vucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlYWtlciddKTtcbiAgICBpZiAoZnJvbVNwZWFrZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyJ10sIGZyb21TcGVha2VyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDIoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyddLCBtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMihmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb1ZlcnRleCQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9WZXJ0ZXgkMShmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW5jbHVkZVRob3VnaHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVRob3VnaHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUluY2x1ZGVUaG91Z2h0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luY2x1ZGVUaG91Z2h0cyddLCBmcm9tSW5jbHVkZVRob3VnaHRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQnVkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdCdWRnZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdCdWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0J1ZGdldCddLCBmcm9tVGhpbmtpbmdCdWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0aGlua2luZ0NvbmZpZ1RvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDIoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDIoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2dsZU1hcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9NbGRldiQyKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBjb21wdXRlclVzZVRvTWxkZXYkMihmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub1ZlcnRleCQxKGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsJ10sIGZyb21SZXRyaWV2YWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVTZWFyY2gnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZWFyY2gnXSwgZ29vZ2xlU2VhcmNoVG9WZXJ0ZXgkMShmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4JDEoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VudGVycHJpc2VXZWJTZWFyY2gnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudGVycHJpc2VXZWJTZWFyY2gnXSwgZW50ZXJwcmlzZVdlYlNlYXJjaFRvVmVydGV4JDEoZnJvbUVudGVycHJpc2VXZWJTZWFyY2gpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZU1hcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSk7XG4gICAgaWYgKGZyb21Hb29nbGVNYXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlTWFwcyddLCBnb29nbGVNYXBzVG9WZXJ0ZXgkMShmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb1ZlcnRleCQxKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBjb21wdXRlclVzZVRvVmVydGV4JDEoZnJvbUNvbXB1dGVyVXNlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvbiddLCBmcm9tQ29kZUV4ZWN1dGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRyYW5zY3JpcHRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoZWQnXSk7XG4gICAgaWYgKGZyb21GaW5pc2hlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaGVkJ10sIGZyb21GaW5pc2hlZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRyYW5zY3JpcHRpb25Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmluaXNoZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaGVkJ10pO1xuICAgIGlmIChmcm9tRmluaXNoZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hlZCddLCBmcm9tRmluaXNoZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0TWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbU1sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxNZXRhZGF0YSddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9NbGRldiQyKCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvVmVydGV4JDEoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21SZXRyaWV2ZWRVcmwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddKTtcbiAgICBpZiAoZnJvbVJldHJpZXZlZFVybCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JldHJpZXZlZFVybCddLCBmcm9tUmV0cmlldmVkVXJsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybFJldHJpZXZhbFN0YXR1cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybFJldHJpZXZhbFN0YXR1cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxSZXRyaWV2YWxTdGF0dXMnXSwgZnJvbVVybFJldHJpZXZhbFN0YXR1cyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVzYWdlTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9tcHRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbkNvdW50J10sIGZyb21Qcm9tcHRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZWRDb250ZW50VG9rZW5Db3VudCddLCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Byb21wdFRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlVG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZVRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhY2hlVG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYWNoZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlVG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVJlc3BvbnNlVG9rZW5zRGV0YWlscztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RhbGl0eVRva2VuQ291bnRGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZVRva2Vuc0RldGFpbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVRvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVzYWdlTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvbXB0VG9rZW5Db3VudCddLCBmcm9tUHJvbXB0VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2FjaGVkQ29udGVudFRva2VuQ291bnQnXSwgZnJvbUNhY2hlZENvbnRlbnRUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NhbmRpZGF0ZXNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5Db3VudCddLCBmcm9tUmVzcG9uc2VUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xVc2VQcm9tcHRUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndG9vbFVzZVByb21wdFRva2VuQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b29sVXNlUHJvbXB0VG9rZW5Db3VudCddLCBmcm9tVG9vbFVzZVByb21wdFRva2VuQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodHNUb2tlbkNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodHNUb2tlbkNvdW50JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRzVG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRzVG9rZW5Db3VudCddLCBmcm9tVGhvdWdodHNUb2tlbkNvdW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvdGFsVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RvdGFsVG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub3RhbFRva2VuQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VuQ291bnQnXSwgZnJvbVRvdGFsVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9tcHRUb2tlbnNEZXRhaWxzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGFsaXR5VG9rZW5Db3VudEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZVRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZVRva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2FjaGVUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DYWNoZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FuZGlkYXRlc1Rva2Vuc0RldGFpbHMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VUb2tlbnNEZXRhaWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZXNwb25zZVRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlVG9rZW5zRGV0YWlscyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0b29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Ub29sVXNlUHJvbXB0VG9rZW5zRGV0YWlscyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbFVzZVByb21wdFRva2Vuc0RldGFpbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kYWxpdHlUb2tlbkNvdW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rvb2xVc2VQcm9tcHRUb2tlbnNEZXRhaWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UcmFmZmljVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJhZmZpY1R5cGUnXSk7XG4gICAgaWYgKGZyb21UcmFmZmljVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyYWZmaWNUeXBlJ10sIGZyb21UcmFmZmljVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YUZyb21WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvTWxkZXYkMihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9NZXRhZGF0YVRvVmVydGV4JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQyKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9WZXJ0ZXgkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWJ1aWx0Vm9pY2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZWJ1aWx0Vm9pY2VDb25maWcnXSwgcHJlYnVpbHRWb2ljZUNvbmZpZ1RvVmVydGV4JDEoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gd2VpZ2h0ZWRQcm9tcHRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21XZWlnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3dlaWdodCddKTtcbiAgICBpZiAoZnJvbVdlaWdodCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3dlaWdodCddLCBmcm9tV2VpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gd2VpZ2h0ZWRQcm9tcHRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21UZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZXh0J10pO1xuICAgIGlmIChmcm9tVGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RleHQnXSwgZnJvbVRleHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tV2VpZ2h0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd3ZWlnaHQnXSk7XG4gICAgaWYgKGZyb21XZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd3ZWlnaHQnXSwgZnJvbVdlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuZnVuY3Rpb24gYXBpS2V5Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleVN0cmluZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5U3RyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5U3RyaW5nJ10sIGZyb21BcGlLZXlTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRoQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFwaUtleUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXBpS2V5Q29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXBpS2V5Q29uZmlnJ10sIGFwaUtleUNvbmZpZ1RvVmVydGV4KGZyb21BcGlLZXlDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF1dGhUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoVHlwZSddKTtcbiAgICBpZiAoZnJvbUF1dGhUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXV0aFR5cGUnXSwgZnJvbUF1dGhUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlcnZpY2VBY2NvdW50Q29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VydmljZUFjY291bnRDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVTZXJ2aWNlQWNjb3VudENvbmZpZyddLCBmcm9tR29vZ2xlU2VydmljZUFjY291bnRDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2h0dHBCYXNpY0F1dGhDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSHR0cEJhc2ljQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2h0dHBCYXNpY0F1dGhDb25maWcnXSwgZnJvbUh0dHBCYXNpY0F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2F1dGhDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ29hdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tT2F1dGhDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvYXV0aENvbmZpZyddLCBmcm9tT2F1dGhDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT2lkY0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb2lkY0NvbmZpZyddKTtcbiAgICBpZiAoZnJvbU9pZGNDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvaWRjQ29uZmlnJ10sIGZyb21PaWRjQ29uZmlnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGF0YSddKTtcbiAgICBpZiAoZnJvbURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkYXRhJ10sIGZyb21EYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYkZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGJsb2JUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBibG9iVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAoZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RhdGEnXSk7XG4gICAgaWYgKGZyb21EYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGF0YSddLCBmcm9tRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udGVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudCddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50J10sIGNvbnRlbnRGcm9tTWxkZXYoZnJvbUNvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNpdGF0aW9uTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjaXRhdGlvbk1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNpdGF0aW9uTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbk1ldGFkYXRhJ10sIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2VuQ291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaW5pc2hSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddKTtcbiAgICBpZiAoZnJvbUZpbmlzaFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbmlzaFJlYXNvbiddLCBmcm9tRmluaXNoUmVhc29uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHRNZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3VybENvbnRleHRNZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0TWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0TWV0YWRhdGEnXSwgdXJsQ29udGV4dE1ldGFkYXRhRnJvbU1sZGV2KGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCBmcm9tU2FmZXR5UmF0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNhbmRpZGF0ZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnQnXSk7XG4gICAgaWYgKGZyb21Db250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudCddLCBjb250ZW50RnJvbVZlcnRleChmcm9tQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2l0YXRpb25NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2NpdGF0aW9uTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NpdGF0aW9uTWV0YWRhdGEnXSwgY2l0YXRpb25NZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbUNpdGF0aW9uTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaE1lc3NhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmaW5pc2hNZXNzYWdlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZpbmlzaE1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaW5pc2hNZXNzYWdlJ10sIGZyb21GaW5pc2hNZXNzYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbmlzaFJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmluaXNoUmVhc29uJ10pO1xuICAgIGlmIChmcm9tRmluaXNoUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmluaXNoUmVhc29uJ10sIGZyb21GaW5pc2hSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dE1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsQ29udGV4dE1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHRNZXRhZGF0YSddLCB1cmxDb250ZXh0TWV0YWRhdGFGcm9tVmVydGV4KGZyb21VcmxDb250ZXh0TWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUF2Z0xvZ3Byb2JzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdmdMb2dwcm9icyddKTtcbiAgICBpZiAoZnJvbUF2Z0xvZ3Byb2JzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXZnTG9ncHJvYnMnXSwgZnJvbUF2Z0xvZ3Byb2JzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdyb3VuZGluZ01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ3JvdW5kaW5nTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR3JvdW5kaW5nTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydncm91bmRpbmdNZXRhZGF0YSddLCBmcm9tR3JvdW5kaW5nTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5kZXggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2luZGV4J10pO1xuICAgIGlmIChmcm9tSW5kZXggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmRleCddLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnNSZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdsb2dwcm9ic1Jlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Mb2dwcm9ic1Jlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvZ3Byb2JzUmVzdWx0J10sIGZyb21Mb2dwcm9ic1Jlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlSYXRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5UmF0aW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TYWZldHlSYXRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5UmF0aW5ncyddLCBmcm9tU2FmZXR5UmF0aW5ncyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNoZWNrcG9pbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRJZCddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRJZCddLCBmcm9tQ2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaCddKTtcbiAgICBpZiAoZnJvbUVwb2NoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXBvY2gnXSwgZnJvbUVwb2NoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0ZXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0ZXAnXSk7XG4gICAgaWYgKGZyb21TdGVwICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RlcCddLCBmcm9tU3RlcCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNpdGF0aW9uTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNpdGF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2l0YXRpb25Tb3VyY2VzJ10pO1xuICAgIGlmIChmcm9tQ2l0YXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2l0YXRpb25zJ10sIGZyb21DaXRhdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjaXRhdGlvbk1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2l0YXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaXRhdGlvbnMnXSk7XG4gICAgaWYgKGZyb21DaXRhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjaXRhdGlvbnMnXSwgZnJvbUNpdGF0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29tcHV0ZVRva2Vuc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRva2Vuc0luZm8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rva2Vuc0luZm8nXSk7XG4gICAgaWYgKGZyb21Ub2tlbnNJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5zSW5mbyddLCBmcm9tVG9rZW5zSW5mbyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVyVXNlVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJ10sIGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlclVzZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21FbnZpcm9ubWVudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW52aXJvbm1lbnQnXSk7XG4gICAgaWYgKGZyb21FbnZpcm9ubWVudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vudmlyb25tZW50J10sIGZyb21FbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhjbHVkZWRQcmVkZWZpbmVkRnVuY3Rpb25zJ10sIGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WYWx1ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZhbHVlcyddKTtcbiAgICBpZiAoZnJvbVZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbHVlcyddLCBmcm9tVmFsdWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudEVtYmVkZGluZ0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZhbHVlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmFsdWVzJ10pO1xuICAgIGlmIChmcm9tVmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmFsdWVzJ10sIGZyb21WYWx1ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhdGlzdGljcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGlzdGljcyddKTtcbiAgICBpZiAoZnJvbVN0YXRpc3RpY3MgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGF0aXN0aWNzJ10sIGNvbnRlbnRFbWJlZGRpbmdTdGF0aXN0aWNzRnJvbVZlcnRleChmcm9tU3RhdGlzdGljcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb250ZW50RW1iZWRkaW5nU3RhdGlzdGljc0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRydW5jYXRlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHJ1bmNhdGVkJ10pO1xuICAgIGlmIChmcm9tVHJ1bmNhdGVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHJ1bmNhdGVkJ10sIGZyb21UcnVuY2F0ZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9rZW5Db3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9rZW5fY291bnQnXSk7XG4gICAgaWYgKGZyb21Ub2tlbkNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9rZW5Db3VudCddLCBmcm9tVG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhcnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJ0cyddKTtcbiAgICBpZiAoZnJvbVBhcnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21QYXJ0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0RnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydEZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFydHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcnRzJ10pO1xuICAgIGlmIChmcm9tUGFydHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVBhcnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGVudFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFydHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJvbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvbGUnXSk7XG4gICAgaWYgKGZyb21Sb2xlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncm9sZSddLCBmcm9tUm9sZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29udHJvbFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRyb2xUeXBlJ10pO1xuICAgIGlmIChmcm9tQ29udHJvbFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250cm9sVHlwZSddLCBmcm9tQ29udHJvbFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5hYmxlQ29udHJvbEltYWdlQ29tcHV0YXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVDb250cm9sJ10sIGZyb21FbmFibGVDb250cm9sSW1hZ2VDb21wdXRhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3lzdGVtSW5zdHJ1Y3Rpb24gcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Rvb2xzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlbmVyYXRpb25Db25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY291bnRUb2tlbnNDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TeXN0ZW1JbnN0cnVjdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVN5c3RlbUluc3RydWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N5c3RlbUluc3RydWN0aW9uJ10sIGNvbnRlbnRUb1ZlcnRleCh0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVG9vbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0aW9uQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0aW9uQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZnJvbUdlbmVyYXRpb25Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBjb3VudFRva2Vuc0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRDb250ZW50cyhmcm9tQ29udGVudHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRUb1ZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGNvdW50VG9rZW5zQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FjaGVkQ29udGVudFRva2VuQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50VG9rZW5Db3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhY2hlZENvbnRlbnRUb2tlbkNvdW50J10sIGZyb21DYWNoZWRDb250ZW50VG9rZW5Db3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG90YWxUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvdGFsVG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVG90YWxUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0b3RhbFRva2VucyddLCBmcm9tVG90YWxUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBkZWxldGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZGVsZXRlTW9kZWxSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZSddKTtcbiAgICBpZiAoZnJvbU1vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlJ10sIGZyb21Nb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUR5bmFtaWNUaHJlc2hvbGQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljVGhyZXNob2xkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljVGhyZXNob2xkJ10sIGZyb21EeW5hbWljVGhyZXNob2xkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZWRpdEltYWdlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FZGl0TW9kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZWRpdE1vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FZGl0TW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VkaXRNb2RlJ10sIGZyb21FZGl0TW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlU3RlcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VTdGVwcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhc2VTdGVwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VkaXRDb25maWcnLCAnYmFzZVN0ZXBzJ10sIGZyb21CYXNlU3RlcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlZGl0SW1hZ2VQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVmZXJlbmNlSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21SZWZlcmVuY2VJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlSW1hZ2VBUElJbnRlcm5hbFRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBlZGl0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVkaXRJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZEltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdlbmVyYXRlZEltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlZEltYWdlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhc2tUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0YXNrVHlwZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRhc2tUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGFza1R5cGUnXSwgZnJvbVRhc2tUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3JlcXVlc3RzW10nLCAndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dERpbWVuc2lvbmFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0RGltZW5zaW9uYWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncmVxdWVzdHNbXScsICdvdXRwdXREaW1lbnNpb25hbGl0eSddLCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWltZVR5cGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXV0b1RydW5jYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhdXRvVHJ1bmNhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50Q29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGFza1R5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rhc2tUeXBlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGFza1R5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzW10nLCAndGFza190eXBlJ10sIGZyb21UYXNrVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICd0aXRsZSddLCBmcm9tVGl0bGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0RGltZW5zaW9uYWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXREaW1lbnNpb25hbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dERpbWVuc2lvbmFsaXR5J10sIGZyb21PdXRwdXREaW1lbnNpb25hbGl0eSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbXScsICdtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXV0b1RydW5jYXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRvVHJ1bmNhdGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BdXRvVHJ1bmNhdGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhdXRvVHJ1bmNhdGUnXSwgZnJvbUF1dG9UcnVuY2F0ZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudE1ldGFkYXRhRnJvbU1sZGV2KCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50TWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21CaWxsYWJsZUNoYXJhY3RlckNvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmlsbGFibGVDaGFyYWN0ZXJDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21CaWxsYWJsZUNoYXJhY3RlckNvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmlsbGFibGVDaGFyYWN0ZXJDb3VudCddLCBmcm9tQmlsbGFibGVDaGFyYWN0ZXJDb3VudCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVtYmVkQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50cyddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWVzdHNbXScsICdjb250ZW50J10sIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVtYmVkQ29udGVudENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWxGb3JFbWJlZENvbnRlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXF1ZXN0c1tdJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbEZvckVtYmVkQ29udGVudCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbnN0YW5jZXNbXScsICdjb250ZW50J10sIHRDb250ZW50c0ZvckVtYmVkKGFwaUNsaWVudCwgZnJvbUNvbnRlbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGVtYmVkQ29udGVudENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbWJlZGRpbmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbWJlZGRpbmdzJ10pO1xuICAgIGlmIChmcm9tRW1iZWRkaW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW1iZWRkaW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50RW1iZWRkaW5nRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21NbGRldigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZW1iZWRDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW1iZWRkaW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWRpY3Rpb25zW10nLFxuICAgICAgICAnZW1iZWRkaW5ncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FbWJlZGRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FbWJlZGRpbmdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRFbWJlZGRpbmdGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW1iZWRkaW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBlbWJlZENvbnRlbnRNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU1ldGFkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGVuZHBvaW50RnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kcG9pbnQnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXBsb3llZE1vZGVsSWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZXBsb3llZE1vZGVsSWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRGVwbG95ZWRNb2RlbElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVwbG95ZWRNb2RlbElkJ10sIGZyb21EZXBsb3llZE1vZGVsSWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbnRlcnByaXNlV2ViU2VhcmNoVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBlbnRpdHlMYWJlbEZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhYmVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbCddKTtcbiAgICBpZiAoZnJvbUxhYmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWwnXSwgZnJvbUxhYmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjb3JlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzY29yZSddKTtcbiAgICBpZiAoZnJvbVNjb3JlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2NvcmUnXSwgZnJvbVNjb3JlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZVVyaSddKTtcbiAgICBpZiAoZnJvbUZpbGVVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlVXJpJ10sIGZyb21GaWxlVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZmlsZURhdGFUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmaWxlRGF0YVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21EaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSk7XG4gICAgaWYgKGZyb21EaXNwbGF5TmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWxlVXJpJ10pO1xuICAgIGlmIChmcm9tRmlsZVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVVcmknXSwgZnJvbUZpbGVVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaWQnXSk7XG4gICAgaWYgKGZyb21JZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lkJ10sIGZyb21JZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21BcmdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhcmdzJ10pO1xuICAgIGlmIChmcm9tQXJncyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FyZ3MnXSwgZnJvbUFyZ3MpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZnVuY3Rpb25DYWxsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbGluZ0NvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWxsb3dlZEZ1bmN0aW9uTmFtZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhbGxvd2VkRnVuY3Rpb25OYW1lcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2FsbG93ZWRGdW5jdGlvbk5hbWVzJ10sIGZyb21BbGxvd2VkRnVuY3Rpb25OYW1lcyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJlaGF2aW9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiZWhhdmlvciddKTtcbiAgICBpZiAoZnJvbUJlaGF2aW9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmVoYXZpb3InXSwgZnJvbUJlaGF2aW9yKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmVoYXZpb3InXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlaGF2aW9yIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXJhbWV0ZXJzJ10pO1xuICAgIGlmIChmcm9tUGFyYW1ldGVycyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSwgZnJvbVBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFyYW1ldGVyc0pzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwYXJhbWV0ZXJzSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcmFtZXRlcnNKc29uU2NoZW1hJ10sIGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGZyb21SZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldiQxKHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgc2NoZW1hVG9NbGRldih0U2NoZW1hKGZyb21SZXNwb25zZVNjaGVtYSkpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JvdXRpbmdDb25maWcgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWxTZWxlY3Rpb25Db25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21vZGVsU2VsZWN0aW9uQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzYWZldHlTZXR0aW5ncyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9vbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9vbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdFRvb2xzKGZyb21Ub29scyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9vbFRvTWxkZXYkMSh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvTWxkZXYoZnJvbVRvb2xDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYWJlbHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhY2hlZENvbnRlbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYWNoZWRDb250ZW50JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNhY2hlZENvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnY2FjaGVkQ29udGVudCddLCB0Q2FjaGVkQ29udGVudE5hbWUoYXBpQ2xpZW50LCBmcm9tQ2FjaGVkQ29udGVudCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlTW9kYWxpdGllcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTW9kYWxpdGllcyddLCBmcm9tUmVzcG9uc2VNb2RhbGl0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1lZGlhUmVzb2x1dGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21lZGlhUmVzb2x1dGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NZWRpYVJlc29sdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZWRpYVJlc29sdXRpb24nXSwgZnJvbU1lZGlhUmVzb2x1dGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TcGVlY2hDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddKTtcbiAgICBpZiAoZnJvbVNwZWVjaENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWVjaENvbmZpZyddLCBzcGVlY2hDb25maWdUb01sZGV2JDEodFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdWRpb1RpbWVzdGFtcCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXVkaW9UaW1lc3RhbXAgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvTWxkZXYkMShmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb01sZGV2KGZyb21JbWFnZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZUNvbnRlbnRDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN5c3RlbUluc3RydWN0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3lzdGVtSW5zdHJ1Y3Rpb24nXSwgY29udGVudFRvVmVydGV4KHRDb250ZW50KGZyb21TeXN0ZW1JbnN0cnVjdGlvbikpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRlbXBlcmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0ZW1wZXJhdHVyZSddKTtcbiAgICBpZiAoZnJvbVRlbXBlcmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGVtcGVyYXR1cmUnXSwgZnJvbVRlbXBlcmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvcFAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RvcFAnXSk7XG4gICAgaWYgKGZyb21Ub3BQICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndG9wUCddLCBmcm9tVG9wUCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BLID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BLJ10pO1xuICAgIGlmIChmcm9tVG9wSyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RvcEsnXSwgZnJvbVRvcEspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjYW5kaWRhdGVDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYW5kaWRhdGVDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZUNvdW50J10sIGZyb21DYW5kaWRhdGVDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhPdXRwdXRUb2tlbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWF4T3V0cHV0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4T3V0cHV0VG9rZW5zJ10sIGZyb21NYXhPdXRwdXRUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RvcFNlcXVlbmNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N0b3BTZXF1ZW5jZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RvcFNlcXVlbmNlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0b3BTZXF1ZW5jZXMnXSwgZnJvbVN0b3BTZXF1ZW5jZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VMb2dwcm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTG9ncHJvYnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VMb2dwcm9icyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlTG9ncHJvYnMnXSwgZnJvbVJlc3BvbnNlTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9ncHJvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvZ3Byb2JzJ10pO1xuICAgIGlmIChmcm9tTG9ncHJvYnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb2dwcm9icyddLCBmcm9tTG9ncHJvYnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlc2VuY2VQZW5hbHR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlc2VuY2VQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZXNlbmNlUGVuYWx0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZXNlbmNlUGVuYWx0eSddLCBmcm9tUHJlc2VuY2VQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZyZXF1ZW5jeVBlbmFsdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmcmVxdWVuY3lQZW5hbHR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZyZXF1ZW5jeVBlbmFsdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcmVxdWVuY3lQZW5hbHR5J10sIGZyb21GcmVxdWVuY3lQZW5hbHR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVzcG9uc2VNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VNaW1lVHlwZSddLCBmcm9tUmVzcG9uc2VNaW1lVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZVNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VTY2hlbWEnXSwgc2NoZW1hVG9WZXJ0ZXgodFNjaGVtYShmcm9tUmVzcG9uc2VTY2hlbWEpKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZUpzb25TY2hlbWEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXNwb25zZUpzb25TY2hlbWEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmVzcG9uc2VKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2VKc29uU2NoZW1hJ10sIGZyb21SZXNwb25zZUpzb25TY2hlbWEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm91dGluZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JvdXRpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUm91dGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JvdXRpbmdDb25maWcnXSwgZnJvbVJvdXRpbmdDb25maWcpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTW9kZWxTZWxlY3Rpb25Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtb2RlbFNlbGVjdGlvbkNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Nb2RlbFNlbGVjdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsQ29uZmlnJ10sIG1vZGVsU2VsZWN0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU1vZGVsU2VsZWN0aW9uQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlTZXR0aW5ncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eVNldHRpbmdzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eVNldHRpbmdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TYWZldHlTZXR0aW5ncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZldHlTZXR0aW5nVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2FmZXR5U2V0dGluZ3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b29scyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvb2xzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IHRUb29scyhmcm9tVG9vbHMpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvb2xUb1ZlcnRleCh0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRvb2xDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rvb2xDb25maWcnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29sQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3Rvb2xDb25maWcnXSwgdG9vbENvbmZpZ1RvVmVydGV4KGZyb21Ub29sQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYWNoZWRDb250ZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY2FjaGVkQ29udGVudCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21DYWNoZWRDb250ZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2NhY2hlZENvbnRlbnQnXSwgdENhY2hlZENvbnRlbnROYW1lKGFwaUNsaWVudCwgZnJvbUNhY2hlZENvbnRlbnQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3BlZWNoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVlY2hDb25maWcnXSk7XG4gICAgaWYgKGZyb21TcGVlY2hDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVlY2hDb25maWcnXSwgc3BlZWNoQ29uZmlnVG9WZXJ0ZXgodFNwZWVjaENvbmZpZyhmcm9tU3BlZWNoQ29uZmlnKSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQXVkaW9UaW1lc3RhbXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdWRpb1RpbWVzdGFtcCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdWRpb1RpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1ZGlvVGltZXN0YW1wJ10sIGZyb21BdWRpb1RpbWVzdGFtcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0NvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdDb25maWcnXSwgdGhpbmtpbmdDb25maWdUb1ZlcnRleChmcm9tVGhpbmtpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VDb25maWcnXSwgaW1hZ2VDb25maWdUb1ZlcnRleChmcm9tSW1hZ2VDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGVudHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbnRlbnRzJ10pO1xuICAgIGlmIChmcm9tQ29udGVudHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdENvbnRlbnRzKGZyb21Db250ZW50cyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGVudFRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRpb25Db25maWcnXSwgZ2VuZXJhdGVDb250ZW50Q29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21Db25maWcsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudHMnXSk7XG4gICAgaWYgKGZyb21Db250ZW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0Q29udGVudHMoZnJvbUNvbnRlbnRzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb250ZW50VG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb250ZW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0aW9uQ29uZmlnJ10sIGdlbmVyYXRlQ29udGVudENvbmZpZ1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DYW5kaWRhdGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYW5kaWRhdGVzJ10pO1xuICAgIGlmIChmcm9tQ2FuZGlkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2FuZGlkYXRlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5kaWRhdGVGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYW5kaWRhdGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVDb250ZW50UmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2FuZGlkYXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2FuZGlkYXRlcyddKTtcbiAgICBpZiAoZnJvbUNhbmRpZGF0ZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUNhbmRpZGF0ZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuZGlkYXRlRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NhbmRpZGF0ZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Nb2RlbFZlcnNpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbU1vZGVsVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsVmVyc2lvbiddLCBmcm9tTW9kZWxWZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdEZlZWRiYWNrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvbXB0RmVlZGJhY2snLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvbXB0RmVlZGJhY2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9tcHRGZWVkYmFjayddLCBmcm9tUHJvbXB0RmVlZGJhY2spO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVzcG9uc2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2VJZCddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlSWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUlkJ10sIGZyb21SZXNwb25zZUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVzYWdlTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1c2FnZU1ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVzYWdlTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1c2FnZU1ldGFkYXRhJ10sIGZyb21Vc2FnZU1ldGFkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRHY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmVnYXRpdmVQcm9tcHQnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25lZ2F0aXZlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc2VlZCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUluY2x1ZGVTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcyddLCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVJhaVJlYXNvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVSYWlSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW5jbHVkZVJhaVJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVSYWlSZWFzb24nXSwgZnJvbUluY2x1ZGVSYWlSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTGFuZ3VhZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdsYW5ndWFnZSddLCBmcm9tTGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZGRXYXRlcm1hcmsgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlSW1hZ2VTaXplJ10sIGZyb21JbWFnZVNpemUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmhhbmNlUHJvbXB0J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmhhbmNlUHJvbXB0IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tT3V0cHV0R2NzVXJpID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXRHY3NVcmknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRHY3NVcmkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdzdG9yYWdlVXJpJ10sIGZyb21PdXRwdXRHY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUd1aWRhbmNlU2NhbGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdndWlkYW5jZVNjYWxlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUd1aWRhbmNlU2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdndWlkYW5jZVNjYWxlJ10sIGZyb21HdWlkYW5jZVNjYWxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlGaWx0ZXJMZXZlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUZpbHRlckxldmVsJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNhZmV0eUZpbHRlckxldmVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FmZXR5U2V0dGluZyddLCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5jbHVkZVNhZmV0eUF0dHJpYnV0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbmNsdWRlU2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2luY2x1ZGVTYWZldHlBdHRyaWJ1dGVzJ10sIGZyb21JbmNsdWRlU2FmZXR5QXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYW5ndWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2xhbmd1YWdlJ10sIGZyb21MYW5ndWFnZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRkV2F0ZXJtYXJrID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhZGRXYXRlcm1hcmsnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21BZGRXYXRlcm1hcmsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdhZGRXYXRlcm1hcmsnXSwgZnJvbUFkZFdhdGVybWFyayk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUltYWdlU2l6ZSddLCBmcm9tSW1hZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlSW1hZ2VzQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVJbWFnZXNDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZEltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbU1sZGV2KGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWFnZXNSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Bvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMnXSwgc2FmZXR5QXR0cmlidXRlc0Zyb21WZXJ0ZXgoZnJvbVBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTnVtYmVyT2ZWaWRlb3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdudW1iZXJPZlZpZGVvcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OdW1iZXJPZlZpZGVvcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhbXBsZUNvdW50J10sIGZyb21OdW1iZXJPZlZpZGVvcyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0cHV0R2NzVXJpIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZnBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EdXJhdGlvblNlY29uZHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkdXJhdGlvblNlY29uZHMnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRHVyYXRpb25TZWNvbmRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZHVyYXRpb25TZWNvbmRzJ10sIGZyb21EdXJhdGlvblNlY29uZHMpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWVkIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwdWJzdWJUb3BpYyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncHVic3ViVG9waWMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5lZ2F0aXZlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbmVnYXRpdmVQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTmVnYXRpdmVQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICduZWdhdGl2ZVByb21wdCddLCBmcm9tTmVnYXRpdmVQcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2VuaGFuY2VQcm9tcHQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5oYW5jZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2VuaGFuY2VQcm9tcHQnXSwgZnJvbUVuaGFuY2VQcm9tcHQpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnZW5lcmF0ZUF1ZGlvJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZW5lcmF0ZUF1ZGlvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFzdEZyYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlcyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVmZXJlbmNlSW1hZ2VzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2snXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hc2sgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHJlc3Npb25RdWFsaXR5J10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb21wcmVzc2lvblF1YWxpdHkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZlZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mVmlkZW9zJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mVmlkZW9zKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dEdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0R2NzVXJpJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tT3V0cHV0R2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc3RvcmFnZVVyaSddLCBmcm9tT3V0cHV0R2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRHVyYXRpb25TZWNvbmRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHVyYXRpb25TZWNvbmRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUR1cmF0aW9uU2Vjb25kcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2R1cmF0aW9uU2Vjb25kcyddLCBmcm9tRHVyYXRpb25TZWNvbmRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NlZWQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TZWVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2VlZCddLCBmcm9tU2VlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Bc3BlY3RSYXRpbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Bc3BlY3RSYXRpbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ2FzcGVjdFJhdGlvJ10sIGZyb21Bc3BlY3RSYXRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNvbHV0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNvbHV0aW9uJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUmVzb2x1dGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Jlc29sdXRpb24nXSwgZnJvbVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uR2VuZXJhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BlcnNvbkdlbmVyYXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uR2VuZXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3BlcnNvbkdlbmVyYXRpb24nXSwgZnJvbVBlcnNvbkdlbmVyYXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHVic3ViVG9waWMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3B1YnN1YlRvcGljJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHVic3ViVG9waWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwdWJzdWJUb3BpYyddLCBmcm9tUHVic3ViVG9waWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmVnYXRpdmVQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZWdhdGl2ZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZWdhdGl2ZVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ25lZ2F0aXZlUHJvbXB0J10sIGZyb21OZWdhdGl2ZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmhhbmNlUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5oYW5jZVByb21wdCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZW5oYW5jZVByb21wdCddLCBmcm9tRW5oYW5jZVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21HZW5lcmF0ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ2VuZXJhdGVBdWRpbycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21HZW5lcmF0ZUF1ZGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZ2VuZXJhdGVBdWRpbyddLCBmcm9tR2VuZXJhdGVBdWRpbyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYXN0RnJhbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhc3RGcmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxhc3RGcmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnbGFzdEZyYW1lJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUxhc3RGcmFtZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlZmVyZW5jZUltYWdlcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUmVmZXJlbmNlSW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZpZGVvR2VuZXJhdGlvblJlZmVyZW5jZUltYWdlVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3JlZmVyZW5jZUltYWdlcyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFzayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFzayddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1hc2sgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ21hc2snXSwgdmlkZW9HZW5lcmF0aW9uTWFza1RvVmVydGV4KGZyb21NYXNrKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wcmVzc2lvblF1YWxpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb21wcmVzc2lvblF1YWxpdHknLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQ29tcHJlc3Npb25RdWFsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21Db21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc09wZXJhdGlvbkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgJ2dlbmVyYXRlVmlkZW9SZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbVJlc3BvbnNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zT3BlcmF0aW9uRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtZXRhZGF0YSddKTtcbiAgICBpZiAoZnJvbU1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0YWRhdGEnXSwgZnJvbU1ldGFkYXRhKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURvbmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RvbmUnXSk7XG4gICAgaWYgKGZyb21Eb25lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZG9uZSddLCBmcm9tRG9uZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcnJvciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXJyb3InXSk7XG4gICAgaWYgKGZyb21FcnJvciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Vycm9yJ10sIGZyb21FcnJvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVzcG9uc2UnXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Jlc3BvbnNlJ10sIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tVmVydGV4KGZyb21SZXNwb25zZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZVZpZGVvc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpZGVvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Tb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NvdXJjZSddKTtcbiAgICBpZiAoZnJvbVNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zU291cmNlVG9NbGRldihmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRlVmlkZW9zQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICd2aWRlbyddLCB2aWRlb1RvVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBnZW5lcmF0ZVZpZGVvc1NvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgZ2VuZXJhdGVWaWRlb3NDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zUmVzcG9uc2VGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRlZFNhbXBsZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRWaWRlb3MnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRDb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlNZWRpYUZpbHRlcmVkQ291bnQnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMnXSwgZnJvbVJhaU1lZGlhRmlsdGVyZWRSZWFzb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVWaWRlb3NSZXNwb25zZUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdlbmVyYXRlZFZpZGVvcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9zJ10pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkVmlkZW9zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRWaWRlb3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkVmlkZW9Gcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkVmlkZW9zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkQ291bnQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpTWVkaWFGaWx0ZXJlZENvdW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmFpTWVkaWFGaWx0ZXJlZENvdW50J10sIGZyb21SYWlNZWRpYUZpbHRlcmVkQ291bnQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpTWVkaWFGaWx0ZXJlZFJlYXNvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlNZWRpYUZpbHRlcmVkUmVhc29ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaU1lZGlhRmlsdGVyZWRSZWFzb25zJ10sIGZyb21SYWlNZWRpYUZpbHRlcmVkUmVhc29ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zU291cmNlVG9NbGRldihmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9NbGRldihmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZpZGVvIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVmlkZW9zU291cmNlVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvbXB0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9tcHQnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3Byb21wdCddLCBmcm9tUHJvbXB0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZpZGVvJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmlkZW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3ZpZGVvJ10sIHZpZGVvVG9WZXJ0ZXgoZnJvbVZpZGVvKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZEltYWdlRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlRnJvbU1sZGV2KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmFpRmlsdGVyZWRSZWFzb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyYWlGaWx0ZXJlZFJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SYWlGaWx0ZXJlZFJlYXNvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JhaUZpbHRlcmVkUmVhc29uJ10sIGZyb21SYWlGaWx0ZXJlZFJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TYWZldHlBdHRyaWJ1dGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVNhZmV0eUF0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzYWZldHlBdHRyaWJ1dGVzJ10sIHNhZmV0eUF0dHJpYnV0ZXNGcm9tTWxkZXYoZnJvbVNhZmV0eUF0dHJpYnV0ZXMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlRnJvbVZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJhaUZpbHRlcmVkUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmFpRmlsdGVyZWRSZWFzb24nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmFpRmlsdGVyZWRSZWFzb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyYWlGaWx0ZXJlZFJlYXNvbiddLCBmcm9tUmFpRmlsdGVyZWRSZWFzb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5QXR0cmlidXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21TYWZldHlBdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2FmZXR5QXR0cmlidXRlcyddLCBzYWZldHlBdHRyaWJ1dGVzRnJvbVZlcnRleChmcm9tU2FmZXR5QXR0cmlidXRlcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZWRQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAoZnJvbUVuaGFuY2VkUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5oYW5jZWRQcm9tcHQnXSwgZnJvbUVuaGFuY2VkUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkSW1hZ2VNYXNrRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWFzayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21NYXNrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFzayddLCBpbWFnZUZyb21WZXJ0ZXgoZnJvbU1hc2spKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhYmVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFiZWxzJ10pO1xuICAgIGlmIChmcm9tTGFiZWxzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21MYWJlbHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW50aXR5TGFiZWxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFiZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlZFZpZGVvRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21WaWRlbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvJ10sIHZpZGVvRnJvbU1sZGV2KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZW5lcmF0ZWRWaWRlb0Zyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVZpZGVvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW8nXSwgdmlkZW9Gcm9tVmVydGV4KGZyb21WaWRlbykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRNb2RlbFBhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZ29vZ2xlTWFwc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21BdXRoQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhdXRoQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tQXV0aENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dGhDb25maWcnXSwgYXV0aENvbmZpZ1RvVmVydGV4KGZyb21BdXRoQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYkMShmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRHluYW1pY1JldHJpZXZhbENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2R5bmFtaWNSZXRyaWV2YWxDb25maWcnXSwgZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvVmVydGV4KGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvTWxkZXYkMShmcm9tVGltZVJhbmdlRmlsdGVyKSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4Y2x1ZGVEb21haW5zJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleGNsdWRlRG9tYWlucyBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnb29nbGVTZWFyY2hUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVGltZVJhbmdlRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGltZVJhbmdlRmlsdGVyJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRpbWVSYW5nZUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpbWVSYW5nZUZpbHRlciddLCBpbnRlcnZhbFRvVmVydGV4KGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVEb21haW5zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhjbHVkZURvbWFpbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhjbHVkZURvbWFpbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlRG9tYWlucyddLCBmcm9tRXhjbHVkZURvbWFpbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFzcGVjdFJhdGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhc3BlY3RSYXRpbyddKTtcbiAgICBpZiAoZnJvbUFzcGVjdFJhdGlvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXNwZWN0UmF0aW8nXSwgZnJvbUFzcGVjdFJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXNwZWN0UmF0aW8gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FzcGVjdFJhdGlvJ10pO1xuICAgIGlmIChmcm9tQXNwZWN0UmF0aW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhc3BlY3RSYXRpbyddLCBmcm9tQXNwZWN0UmF0aW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBpbWFnZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2J5dGVzQmFzZTY0RW5jb2RlZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbWFnZUJ5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW1hZ2VCeXRlcyddLCB0Qnl0ZXMoZnJvbUltYWdlQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW1lVHlwZSddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gaW1hZ2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2djc1VyaSddLCBmcm9tR2NzVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW1hZ2VCeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlQnl0ZXMnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnY3NVcmknXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2djc1VyaSBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VCeXRlcyddKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGltYWdlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUdjc1VyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pO1xuICAgIGlmIChmcm9tR2NzVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW1hZ2VCeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2VCeXRlcyddKTtcbiAgICBpZiAoZnJvbUltYWdlQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21JbWFnZUJ5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVN0YXJ0VGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRUaW1lJ10pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kVGltZSddKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGF0TG5nVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTGF0aXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdGl0dWRlJ10pO1xuICAgIGlmIChmcm9tTGF0aXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYXRpdHVkZSddLCBmcm9tTGF0aXR1ZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTG9uZ2l0dWRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsb25naXR1ZGUnXSk7XG4gICAgaWYgKGZyb21Mb25naXR1ZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsb25naXR1ZGUnXSwgZnJvbUxvbmdpdHVkZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxhdExuZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRpdHVkZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0aXR1ZGUnXSk7XG4gICAgaWYgKGZyb21MYXRpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdGl0dWRlJ10sIGZyb21MYXRpdHVkZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb25naXR1ZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xvbmdpdHVkZSddKTtcbiAgICBpZiAoZnJvbUxvbmdpdHVkZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xvbmdpdHVkZSddLCBmcm9tTG9uZ2l0dWRlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYWdlU2l6ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVNpemUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVNpemUnXSwgZnJvbVBhZ2VTaXplKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFnZVRva2VuJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVRva2VuICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlVG9rZW4nXSwgZnJvbVBhZ2VUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWx0ZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbHRlciddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUZpbHRlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAnZmlsdGVyJ10sIGZyb21GaWx0ZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUXVlcnlCYXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydxdWVyeUJhc2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21RdWVyeUJhc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3VybCcsICdtb2RlbHNfdXJsJ10sIHRNb2RlbHNVcmwoYXBpQ2xpZW50LCBmcm9tUXVlcnlCYXNlKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNDb25maWdUb1ZlcnRleChhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21RdWVyeUJhc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3F1ZXJ5QmFzZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVF1ZXJ5QmFzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfdXJsJywgJ21vZGVsc191cmwnXSwgdE1vZGVsc1VybChhcGlDbGllbnQsIGZyb21RdWVyeUJhc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1BhcmFtZXRlcnNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgbGlzdE1vZGVsc0NvbmZpZ1RvTWxkZXYoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0TW9kZWxzQ29uZmlnVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdE1vZGVsc1Jlc3BvbnNlRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGVscyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21Nb2RlbHMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gdEV4dHJhY3RNb2RlbHMoZnJvbU1vZGVscyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZWxzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NlZ21lbnRhdGlvbkNsYXNzZXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2VnbWVudGF0aW9uQ2xhc3NlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21hc2tDbGFzc2VzJ10sIGZyb21TZWdtZW50YXRpb25DbGFzc2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1hc2tEaWxhdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWFza0RpbGF0aW9uJ10pO1xuICAgIGlmIChmcm9tTWFza0RpbGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGlsYXRpb24nXSwgZnJvbU1hc2tEaWxhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsRnJvbU1sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbiddKTtcbiAgICBpZiAoZnJvbVZlcnNpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2ZXJzaW9uJ10sIGZyb21WZXJzaW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxJbmZvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydfc2VsZiddKTtcbiAgICBpZiAoZnJvbVR1bmVkTW9kZWxJbmZvICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbEluZm8nXSwgdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbVR1bmVkTW9kZWxJbmZvKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbnB1dFRva2VuTGltaXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tSW5wdXRUb2tlbkxpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5wdXRUb2tlbkxpbWl0J10sIGZyb21JbnB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0VG9rZW5MaW1pdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dFRva2VuTGltaXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tT3V0cHV0VG9rZW5MaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ291dHB1dFRva2VuTGltaXQnXSwgZnJvbU91dHB1dFRva2VuTGltaXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3VwcG9ydGVkQWN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3N1cHBvcnRlZEdlbmVyYXRpb25NZXRob2RzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1cHBvcnRlZEFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBwb3J0ZWRBY3Rpb25zJ10sIGZyb21TdXBwb3J0ZWRBY3Rpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbW9kZWxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNwbGF5TmFtZSddLCBmcm9tRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVyc2lvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVyc2lvbklkJ10pO1xuICAgIGlmIChmcm9tVmVyc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZlcnNpb24nXSwgZnJvbVZlcnNpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXBsb3llZE1vZGVscyddKTtcbiAgICBpZiAoZnJvbUVuZHBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRW5kcG9pbnRzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuZHBvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYWJlbHMnXSwgZnJvbUxhYmVscyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsSW5mbyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnX3NlbGYnXSk7XG4gICAgaWYgKGZyb21UdW5lZE1vZGVsSW5mbyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWxJbmZvJ10sIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tVHVuZWRNb2RlbEluZm8pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHRDaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkZWZhdWx0Q2hlY2twb2ludElkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbURlZmF1bHRDaGVja3BvaW50SWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNoZWNrcG9pbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjaGVja3BvaW50cyddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21DaGVja3BvaW50cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja3BvaW50RnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIG1vZGVsU2VsZWN0aW9uQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZlYXR1cmVTZWxlY3Rpb25QcmVmZXJlbmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmZWF0dXJlU2VsZWN0aW9uUHJlZmVyZW5jZSddLCBmcm9tRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3BlYWtlclZvaWNlQ29uZmlncyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NwZWFrZXJWb2ljZUNvbmZpZ3MnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3BlYWtlclZvaWNlQ29uZmlncyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tU3BlYWtlclZvaWNlQ29uZmlncztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyVm9pY2VDb25maWdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZpZGVvTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2aWRlb01ldGFkYXRhJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVZpZGVvTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2aWRlb01ldGFkYXRhJ10sIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYkZyb21NbGRldihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21NbGRldihmcm9tRmlsZURhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHRTaWduYXR1cmUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0aG91Z2h0U2lnbmF0dXJlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRob3VnaHRTaWduYXR1cmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0U2lnbmF0dXJlJ10sIGZyb21UaG91Z2h0U2lnbmF0dXJlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uQ2FsbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25DYWxsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25DYWxsJ10sIGZ1bmN0aW9uQ2FsbEZyb21NbGRldihmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhRnJvbVZlcnRleChmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iRnJvbVZlcnRleChmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YUZyb21WZXJ0ZXgoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxGcm9tVmVydGV4KGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVmlkZW9NZXRhZGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvTWV0YWRhdGEnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9NZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvTWV0YWRhdGEnXSwgdmlkZW9NZXRhZGF0YVRvTWxkZXYkMShmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldiQxKGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9NbGRldiQxKGZyb21GaWxlRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodFNpZ25hdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Rob3VnaHRTaWduYXR1cmUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhvdWdodFNpZ25hdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Rob3VnaHRTaWduYXR1cmUnXSwgZnJvbVRob3VnaHRTaWduYXR1cmUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmdW5jdGlvbkNhbGwnXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkNhbGwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkNhbGwnXSwgZnVuY3Rpb25DYWxsVG9NbGRldiQxKGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcGFydFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgoZnJvbVZpZGVvTWV0YWRhdGEpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRob3VnaHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Rob3VnaHQnXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodCddLCBmcm9tVGhvdWdodCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmxpbmVEYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbmxpbmVEYXRhJ10pO1xuICAgIGlmIChmcm9tSW5saW5lRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2lubGluZURhdGEnXSwgYmxvYlRvVmVydGV4KGZyb21JbmxpbmVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GaWxlRGF0YSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsZURhdGEnXSk7XG4gICAgaWYgKGZyb21GaWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZpbGVEYXRhJ10sIGZpbGVEYXRhVG9WZXJ0ZXgoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb1ZlcnRleChmcm9tRnVuY3Rpb25DYWxsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29kZUV4ZWN1dGlvblJlc3VsdCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29kZUV4ZWN1dGlvblJlc3VsdCddLCBmcm9tQ29kZUV4ZWN1dGlvblJlc3VsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGVjdXRhYmxlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4ZWN1dGFibGVDb2RlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUV4ZWN1dGFibGVDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhlY3V0YWJsZUNvZGUnXSwgZnJvbUV4ZWN1dGFibGVDb2RlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvblJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvblJlc3BvbnNlJ10sIGZyb21GdW5jdGlvblJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3RleHQnXSk7XG4gICAgaWYgKGZyb21UZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dCddLCBmcm9tVGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHByZWJ1aWx0Vm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcmVidWlsdFZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9kdWN0SW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUHJvZHVjdEltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwcm9kdWN0SW1hZ2UnXSk7XG4gICAgaWYgKGZyb21Qcm9kdWN0SW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21Qcm9kdWN0SW1hZ2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJhc2VTdGVwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZVN0ZXBzJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmFzZVN0ZXBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnZWRpdENvbmZpZycsICdiYXNlU3RlcHMnXSwgZnJvbUJhc2VTdGVwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TZWVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzZWVkJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2VlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NlZWQnXSwgZnJvbVNlZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2FmZXR5RmlsdGVyTGV2ZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlGaWx0ZXJMZXZlbCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TYWZldHlGaWx0ZXJMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3NhZmV0eVNldHRpbmcnXSwgZnJvbVNhZmV0eUZpbHRlckxldmVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBlcnNvbkdlbmVyYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwZXJzb25HZW5lcmF0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBlcnNvbkdlbmVyYXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdwZXJzb25HZW5lcmF0aW9uJ10sIGZyb21QZXJzb25HZW5lcmF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFkZFdhdGVybWFyayA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRkV2F0ZXJtYXJrJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRkV2F0ZXJtYXJrICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnYWRkV2F0ZXJtYXJrJ10sIGZyb21BZGRXYXRlcm1hcmspO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0TWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdvdXRwdXRNaW1lVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRNaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnbWltZVR5cGUnXSwgZnJvbU91dHB1dE1pbWVUeXBlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dENvbXByZXNzaW9uUXVhbGl0eScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdvdXRwdXRPcHRpb25zJywgJ2NvbXByZXNzaW9uUXVhbGl0eSddLCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuaGFuY2VQcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlUHJvbXB0JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVuaGFuY2VQcm9tcHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdlbmhhbmNlUHJvbXB0J10sIGZyb21FbmhhbmNlUHJvbXB0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICByZWNvbnRleHRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21Tb3VyY2UsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgcmVjb250ZXh0SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRJbWFnZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRJbWFnZXMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUdlbmVyYXRlZEltYWdlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZWRJbWFnZUZyb21WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnZW5lcmF0ZWRJbWFnZXMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcmVjb250ZXh0SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Qcm9tcHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb21wdCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVByb21wdCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAncHJvbXB0J10sIGZyb21Qcm9tcHQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGVyc29uSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BlcnNvbkltYWdlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGVyc29uSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3BlcnNvbkltYWdlJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVBlcnNvbkltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9kdWN0SW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvZHVjdEltYWdlcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9kdWN0SW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21Qcm9kdWN0SW1hZ2VzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2R1Y3RJbWFnZVRvVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9kdWN0SW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJlZmVyZW5jZUltYWdlQVBJSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmVmZXJlbmNlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWZlcmVuY2VJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbVJlZmVyZW5jZUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVmZXJlbmNlSWQnXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlZmVyZW5jZUlkJ10sIGZyb21SZWZlcmVuY2VJZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXNrSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTWFza0ltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWFza0ltYWdlQ29uZmlnJ10sIG1hc2tSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tTWFza0ltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250cm9sSW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb250cm9sSW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tQ29udHJvbEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udHJvbEltYWdlQ29uZmlnJ10sIGNvbnRyb2xSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tQ29udHJvbEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdHlsZUltYWdlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3R5bGVJbWFnZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdHlsZUltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3R5bGVJbWFnZUNvbmZpZyddLCBzdHlsZVJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21TdHlsZUltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdWJqZWN0SW1hZ2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzdWJqZWN0SW1hZ2VDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3ViamVjdEltYWdlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3ViamVjdEltYWdlQ29uZmlnJ10sIHN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tU3ViamVjdEltYWdlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUxhdExuZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGF0TG5nJ10pO1xuICAgIGlmIChmcm9tTGF0TG5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGF0TG5nJ10sIGxhdExuZ1RvTWxkZXYoZnJvbUxhdExuZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFuZ3VhZ2VDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYW5ndWFnZUNvZGUnXSk7XG4gICAgaWYgKGZyb21MYW5ndWFnZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydsYW5ndWFnZUNvZGUnXSwgZnJvbUxhbmd1YWdlQ29kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21MYXRMbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhdExuZyddKTtcbiAgICBpZiAoZnJvbUxhdExuZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhdExuZyddLCBsYXRMbmdUb1ZlcnRleChmcm9tTGF0TG5nKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5QXR0cmlidXRlc0Zyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ2F0ZWdvcmllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnY2F0ZWdvcmllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21DYXRlZ29yaWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcmllcyddLCBmcm9tQ2F0ZWdvcmllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TY29yZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzYWZldHlBdHRyaWJ1dGVzJyxcbiAgICAgICAgJ3Njb3JlcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TY29yZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzY29yZXMnXSwgZnJvbVNjb3Jlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db250ZW50VHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29udGVudFR5cGUnXSk7XG4gICAgaWYgKGZyb21Db250ZW50VHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbnRlbnRUeXBlJ10sIGZyb21Db250ZW50VHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNhZmV0eUF0dHJpYnV0ZXNGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DYXRlZ29yaWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2FmZXR5QXR0cmlidXRlcycsXG4gICAgICAgICdjYXRlZ29yaWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNhdGVnb3JpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yaWVzJ10sIGZyb21DYXRlZ29yaWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjb3JlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NhZmV0eUF0dHJpYnV0ZXMnLFxuICAgICAgICAnc2NvcmVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNjb3JlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Njb3JlcyddLCBmcm9tU2NvcmVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbnRlbnRUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb250ZW50VHlwZSddKTtcbiAgICBpZiAoZnJvbUNvbnRlbnRUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29udGVudFR5cGUnXSwgZnJvbUNvbnRlbnRUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2FmZXR5U2V0dGluZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNhdGVnb3J5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjYXRlZ29yeSddKTtcbiAgICBpZiAoZnJvbUNhdGVnb3J5ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2F0ZWdvcnknXSwgZnJvbUNhdGVnb3J5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRocmVzaG9sZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhyZXNob2xkJ10pO1xuICAgIGlmIChmcm9tVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhyZXNob2xkJ10sIGZyb21UaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzYWZldHlTZXR0aW5nVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1ldGhvZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWV0aG9kJ10pO1xuICAgIGlmIChmcm9tTWV0aG9kICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWV0aG9kJ10sIGZyb21NZXRob2QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ2F0ZWdvcnkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NhdGVnb3J5J10pO1xuICAgIGlmIChmcm9tQ2F0ZWdvcnkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjYXRlZ29yeSddLCBmcm9tQ2F0ZWdvcnkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aHJlc2hvbGQnXSk7XG4gICAgaWYgKGZyb21UaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aHJlc2hvbGQnXSwgZnJvbVRocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjaGVtYVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUFueU9mID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydhbnlPZiddKTtcbiAgICBpZiAoZnJvbUFueU9mICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYW55T2YnXSwgZnJvbUFueU9mKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlZmF1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2RlZmF1bHQnXSk7XG4gICAgaWYgKGZyb21EZWZhdWx0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVmYXVsdCddLCBmcm9tRGVmYXVsdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbnVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnVtJ10pO1xuICAgIGlmIChmcm9tRW51bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VudW0nXSwgZnJvbUVudW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXhhbXBsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZSddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGFtcGxlJ10sIGZyb21FeGFtcGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZvcm1hdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZm9ybWF0J10pO1xuICAgIGlmIChmcm9tRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZm9ybWF0J10sIGZyb21Gb3JtYXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2l0ZW1zJ10pO1xuICAgIGlmIChmcm9tSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpdGVtcyddLCBmcm9tSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4SXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heEl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWF4SXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhJdGVtcyddLCBmcm9tTWF4SXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4TGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhMZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NYXhMZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhMZW5ndGgnXSwgZnJvbU1heExlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhQcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWF4UHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NYXhQcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4UHJvcGVydGllcyddLCBmcm9tTWF4UHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhpbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtYXhpbXVtJ10pO1xuICAgIGlmIChmcm9tTWF4aW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heGltdW0nXSwgZnJvbU1heGltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluSXRlbXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkl0ZW1zJ10pO1xuICAgIGlmIChmcm9tTWluSXRlbXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5JdGVtcyddLCBmcm9tTWluSXRlbXMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWluTGVuZ3RoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5MZW5ndGgnXSk7XG4gICAgaWYgKGZyb21NaW5MZW5ndGggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5MZW5ndGgnXSwgZnJvbU1pbkxlbmd0aCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5Qcm9wZXJ0aWVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbWluUHJvcGVydGllcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NaW5Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluUHJvcGVydGllcyddLCBmcm9tTWluUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5pbXVtID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtaW5pbXVtJ10pO1xuICAgIGlmIChmcm9tTWluaW11bSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbmltdW0nXSwgZnJvbU1pbmltdW0pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTnVsbGFibGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ251bGxhYmxlJ10pO1xuICAgIGlmIChmcm9tTnVsbGFibGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydudWxsYWJsZSddLCBmcm9tTnVsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGF0dGVybiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGF0dGVybiddKTtcbiAgICBpZiAoZnJvbVBhdHRlcm4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXR0ZXJuJ10sIGZyb21QYXR0ZXJuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3Byb3BlcnRpZXMnXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0aWVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydGllcyddLCBmcm9tUHJvcGVydGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9wZXJ0eU9yZGVyaW5nID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvcGVydHlPcmRlcmluZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21Qcm9wZXJ0eU9yZGVyaW5nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJvcGVydHlPcmRlcmluZyddLCBmcm9tUHJvcGVydHlPcmRlcmluZyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXF1aXJlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmVxdWlyZWQnXSk7XG4gICAgaWYgKGZyb21SZXF1aXJlZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3JlcXVpcmVkJ10sIGZyb21SZXF1aXJlZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaXRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGl0bGUnXSk7XG4gICAgaWYgKGZyb21UaXRsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RpdGxlJ10sIGZyb21UaXRsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0eXBlJ10pO1xuICAgIGlmIChmcm9tVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R5cGUnXSwgZnJvbVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzY2hlbWFUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQW55T2YgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FueU9mJ10pO1xuICAgIGlmIChmcm9tQW55T2YgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhbnlPZiddLCBmcm9tQW55T2YpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVmYXVsdCddKTtcbiAgICBpZiAoZnJvbURlZmF1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZWZhdWx0J10sIGZyb21EZWZhdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAoZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZGVzY3JpcHRpb24nXSwgZnJvbURlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VudW0nXSk7XG4gICAgaWYgKGZyb21FbnVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW51bSddLCBmcm9tRW51bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FeGFtcGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlJ10pO1xuICAgIGlmIChmcm9tRXhhbXBsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGUnXSwgZnJvbUV4YW1wbGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRm9ybWF0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmb3JtYXQnXSk7XG4gICAgaWYgKGZyb21Gb3JtYXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmb3JtYXQnXSwgZnJvbUZvcm1hdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaXRlbXMnXSk7XG4gICAgaWYgKGZyb21JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2l0ZW1zJ10sIGZyb21JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhJdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWF4SXRlbXMnXSk7XG4gICAgaWYgKGZyb21NYXhJdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heEl0ZW1zJ10sIGZyb21NYXhJdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXhMZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heExlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1heExlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21heExlbmd0aCddLCBmcm9tTWF4TGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heFByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1heFByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXhQcm9wZXJ0aWVzJ10sIGZyb21NYXhQcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heGltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21heGltdW0nXSk7XG4gICAgaWYgKGZyb21NYXhpbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWF4aW11bSddLCBmcm9tTWF4aW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5JdGVtcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWluSXRlbXMnXSk7XG4gICAgaWYgKGZyb21NaW5JdGVtcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkl0ZW1zJ10sIGZyb21NaW5JdGVtcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW5MZW5ndGggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbkxlbmd0aCddKTtcbiAgICBpZiAoZnJvbU1pbkxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbkxlbmd0aCddLCBmcm9tTWluTGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pblByb3BlcnRpZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU1pblByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW5Qcm9wZXJ0aWVzJ10sIGZyb21NaW5Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbmltdW0gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbmltdW0nXSk7XG4gICAgaWYgKGZyb21NaW5pbXVtICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWluaW11bSddLCBmcm9tTWluaW11bSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdWxsYWJsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbnVsbGFibGUnXSk7XG4gICAgaWYgKGZyb21OdWxsYWJsZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ251bGxhYmxlJ10sIGZyb21OdWxsYWJsZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXR0ZXJuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYXR0ZXJuJ10pO1xuICAgIGlmIChmcm9tUGF0dGVybiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhdHRlcm4nXSwgZnJvbVBhdHRlcm4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJvcGVydGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvcGVydGllcyddKTtcbiAgICBpZiAoZnJvbVByb3BlcnRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0aWVzJ10sIGZyb21Qcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByb3BlcnR5T3JkZXJpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcm9wZXJ0eU9yZGVyaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByb3BlcnR5T3JkZXJpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9wZXJ0eU9yZGVyaW5nJ10sIGZyb21Qcm9wZXJ0eU9yZGVyaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlcXVpcmVkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXF1aXJlZCddKTtcbiAgICBpZiAoZnJvbVJlcXVpcmVkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVxdWlyZWQnXSwgZnJvbVJlcXVpcmVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRpdGxlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0aXRsZSddKTtcbiAgICBpZiAoZnJvbVRpdGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGl0bGUnXSwgZnJvbVRpdGxlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R5cGUnXSk7XG4gICAgaWYgKGZyb21UeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHlwZSddLCBmcm9tVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNjcmliYmxlSW1hZ2VUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbWFnZSddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTW9kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21vZGUnXSwgZnJvbU1vZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWF4UHJlZGljdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtYXhQcmVkaWN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhQcmVkaWN0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21heFByZWRpY3Rpb25zJ10sIGZyb21NYXhQcmVkaWN0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWRlbmNlVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29uZmlkZW5jZVRocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Db25maWRlbmNlVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnY29uZmlkZW5jZVRocmVzaG9sZCddLCBmcm9tQ29uZmlkZW5jZVRocmVzaG9sZCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NYXNrRGlsYXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tEaWxhdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU1hc2tEaWxhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ21hc2tEaWxhdGlvbiddLCBmcm9tTWFza0RpbGF0aW9uKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUJpbmFyeUNvbG9yVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnYmluYXJ5Q29sb3JUaHJlc2hvbGQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICdiaW5hcnlDb2xvclRocmVzaG9sZCddLCBmcm9tQmluYXJ5Q29sb3JUaHJlc2hvbGQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZWdtZW50SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzb3VyY2UnXSk7XG4gICAgaWYgKGZyb21Tb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBzZWdtZW50SW1hZ2VTb3VyY2VUb1ZlcnRleChmcm9tU291cmNlLCB0b09iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNlZ21lbnRJbWFnZUNvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2VnbWVudEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HZW5lcmF0ZWRNYXNrcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJlZGljdGlvbnMnXSk7XG4gICAgaWYgKGZyb21HZW5lcmF0ZWRNYXNrcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tR2VuZXJhdGVkTWFza3M7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VNYXNrRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dlbmVyYXRlZE1hc2tzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNlZ21lbnRJbWFnZVNvdXJjZVRvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb21wdCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvbXB0J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUHJvbXB0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2luc3RhbmNlc1swXScsICdwcm9tcHQnXSwgZnJvbVByb21wdCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydpbnN0YW5jZXNbMF0nLCAnaW1hZ2UnXSwgaW1hZ2VUb1ZlcnRleChmcm9tSW1hZ2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNjcmliYmxlSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzY3JpYmJsZUltYWdlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNjcmliYmxlSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ3NjcmliYmxlJ10sIHNjcmliYmxlSW1hZ2VUb1ZlcnRleChmcm9tU2NyaWJibGVJbWFnZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNwZWFrZXIgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3NwZWFrZXInXSk7XG4gICAgaWYgKGZyb21TcGVha2VyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3BlYWtlciddLCBmcm9tU3BlYWtlcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Wb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VDb25maWcnXSk7XG4gICAgaWYgKGZyb21Wb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10sIHZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVlY2hDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2JDEoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSwgbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2JDEoZnJvbU11bHRpU3BlYWtlclZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYW5ndWFnZUNvZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddKTtcbiAgICBpZiAoZnJvbUxhbmd1YWdlQ29kZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhbmd1YWdlQ29kZSddLCBmcm9tTGFuZ3VhZ2VDb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc3BlZWNoQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb1ZlcnRleChmcm9tVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbXVsdGlTcGVha2VyVm9pY2VDb25maWcnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzdHlsZVJlZmVyZW5jZUNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TdHlsZURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3R5bGVEZXNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TdHlsZURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3R5bGVEZXNjcmlwdGlvbiddLCBmcm9tU3R5bGVEZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHN1YmplY3RSZWZlcmVuY2VDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3ViamVjdFR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N1YmplY3RUeXBlJ10pO1xuICAgIGlmIChmcm9tU3ViamVjdFR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdWJqZWN0VHlwZSddLCBmcm9tU3ViamVjdFR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3ViamVjdERlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3ViamVjdERlc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN1YmplY3REZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1YmplY3REZXNjcmlwdGlvbiddLCBmcm9tU3ViamVjdERlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb01sZGV2JDEoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdGhpbmtpbmdDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW5jbHVkZVRob3VnaHRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVRob3VnaHRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUluY2x1ZGVUaG91Z2h0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2luY2x1ZGVUaG91Z2h0cyddLCBmcm9tSW5jbHVkZVRob3VnaHRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQnVkZ2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdCdWRnZXQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVGhpbmtpbmdCdWRnZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aGlua2luZ0J1ZGdldCddLCBmcm9tVGhpbmtpbmdCdWRnZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0b29sQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb01sZGV2KGZyb21GdW5jdGlvbkNhbGxpbmdDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJldHJpZXZhbENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3JldHJpZXZhbENvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWxDb25maWcnXSwgcmV0cmlldmFsQ29uZmlnVG9NbGRldihmcm9tUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHRvb2xDb25maWdUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25DYWxsaW5nQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbGluZ0NvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbGluZ0NvbmZpZyddLCBmdW5jdGlvbkNhbGxpbmdDb25maWdUb1ZlcnRleChmcm9tRnVuY3Rpb25DYWxsaW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZXRyaWV2YWxDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUmV0cmlldmFsQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmFsQ29uZmlnJ10sIHJldHJpZXZhbENvbmZpZ1RvVmVydGV4KGZyb21SZXRyaWV2YWxDb25maWcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYkMShmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdmdW5jdGlvbkRlY2xhcmF0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25EZWNsYXJhdGlvblRvTWxkZXYkMShpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3JldHJpZXZhbCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmV0cmlldmFsIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb01sZGV2JDEoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2JDEoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCkpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbnRlcnByaXNlV2ViU2VhcmNoIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZU1hcHMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvb2dsZU1hcHMgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVybENvbnRleHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybENvbnRleHQnXSk7XG4gICAgaWYgKGZyb21VcmxDb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsQ29udGV4dCddLCB1cmxDb250ZXh0VG9NbGRldiQxKCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29tcHV0ZXJVc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10pO1xuICAgIGlmIChmcm9tQ29tcHV0ZXJVc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb21wdXRlclVzZSddLCBjb21wdXRlclVzZVRvTWxkZXYkMShmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uRGVjbGFyYXRpb25zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21GdW5jdGlvbkRlY2xhcmF0aW9ucztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9WZXJ0ZXgoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmdW5jdGlvbkRlY2xhcmF0aW9ucyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2YWwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2YWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2YWwnXSwgZnJvbVJldHJpZXZhbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaCddLCBnb29nbGVTZWFyY2hUb1ZlcnRleChmcm9tR29vZ2xlU2VhcmNoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdnb29nbGVTZWFyY2hSZXRyaWV2YWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJ10sIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvVmVydGV4KGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbnRlcnByaXNlV2ViU2VhcmNoJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVudGVycHJpc2VXZWJTZWFyY2ggIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbnRlcnByaXNlV2ViU2VhcmNoJ10sIGVudGVycHJpc2VXZWJTZWFyY2hUb1ZlcnRleChmcm9tRW50ZXJwcmlzZVdlYlNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlTWFwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlTWFwcyddKTtcbiAgICBpZiAoZnJvbUdvb2dsZU1hcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydnb29nbGVNYXBzJ10sIGdvb2dsZU1hcHNUb1ZlcnRleChmcm9tR29vZ2xlTWFwcykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsQ29udGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJsQ29udGV4dCddKTtcbiAgICBpZiAoZnJvbVVybENvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd1cmxDb250ZXh0J10sIHVybENvbnRleHRUb1ZlcnRleCgpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbXB1dGVyVXNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb21wdXRlclVzZSddKTtcbiAgICBpZiAoZnJvbUNvbXB1dGVyVXNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSwgY29tcHV0ZXJVc2VUb1ZlcnRleChmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbEluZm9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3JlYXRlVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY3JlYXRlVGltZSddKTtcbiAgICBpZiAoZnJvbUNyZWF0ZVRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjcmVhdGVUaW1lJ10sIGZyb21DcmVhdGVUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxJbmZvRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGFiZWxzJyxcbiAgICAgICAgJ2dvb2dsZS12ZXJ0ZXgtbGxtLXR1bmluZy1iYXNlLW1vZGVsLWlkJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbURpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZWZhdWx0Q2hlY2twb2ludElkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZGVmYXVsdENoZWNrcG9pbnRJZCcsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZWZhdWx0Q2hlY2twb2ludElkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2RlZmF1bHRDaGVja3BvaW50SWQnXSwgZnJvbURlZmF1bHRDaGVja3BvaW50SWQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbURpc3BsYXlOYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rpc3BsYXlOYW1lJ10sIGZyb21EaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2RlZmF1bHRDaGVja3BvaW50SWQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRGVmYXVsdENoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydkZWZhdWx0Q2hlY2twb2ludElkJ10sIGZyb21EZWZhdWx0Q2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgdXBkYXRlTW9kZWxDb25maWdUb01sZGV2KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgoYXBpQ2xpZW50LCBmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGVsJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ21vZGVsJ10sIHRNb2RlbChhcGlDbGllbnQsIGZyb21Nb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVNb2RlbENvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlQVBJQ29uZmlnSW50ZXJuYWxUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21PdXRwdXRHY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ291dHB1dEdjc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3N0b3JhZ2VVcmknXSwgZnJvbU91dHB1dEdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21JbmNsdWRlUmFpUmVhc29uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW5jbHVkZVJhaVJlYXNvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbmNsdWRlUmFpUmVhc29uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnaW5jbHVkZVJhaVJlYXNvbiddLCBmcm9tSW5jbHVkZVJhaVJlYXNvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21PdXRwdXRNaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ291dHB1dE1pbWVUeXBlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dE1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnb3V0cHV0T3B0aW9ucycsICdtaW1lVHlwZSddLCBmcm9tT3V0cHV0TWltZVR5cGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0Q29tcHJlc3Npb25RdWFsaXR5JyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dENvbXByZXNzaW9uUXVhbGl0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ291dHB1dE9wdGlvbnMnLCAnY29tcHJlc3Npb25RdWFsaXR5J10sIGZyb21PdXRwdXRDb21wcmVzc2lvblF1YWxpdHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5oYW5jZUlucHV0SW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmhhbmNlSW5wdXRJbWFnZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FbmhhbmNlSW5wdXRJbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydwYXJhbWV0ZXJzJywgJ3Vwc2NhbGVDb25maWcnLCAnZW5oYW5jZUlucHV0SW1hZ2UnXSwgZnJvbUVuaGFuY2VJbnB1dEltYWdlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlUHJlc2VydmF0aW9uRmFjdG9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnaW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3InLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tSW1hZ2VQcmVzZXJ2YXRpb25GYWN0b3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ2ltYWdlUHJlc2VydmF0aW9uRmFjdG9yJ10sIGZyb21JbWFnZVByZXNlcnZhdGlvbkZhY3Rvcik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OdW1iZXJPZkltYWdlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ251bWJlck9mSW1hZ2VzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU51bWJlck9mSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnc2FtcGxlQ291bnQnXSwgZnJvbU51bWJlck9mSW1hZ2VzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3BhcmFtZXRlcnMnLCAnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVwc2NhbGVJbWFnZUFQSVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICdtb2RlbCddLCB0TW9kZWwoYXBpQ2xpZW50LCBmcm9tTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUltYWdlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpbWFnZSddKTtcbiAgICBpZiAoZnJvbUltYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5zdGFuY2VzWzBdJywgJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcHNjYWxlRmFjdG9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXBzY2FsZUZhY3RvcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21VcHNjYWxlRmFjdG9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycycsICd1cHNjYWxlQ29uZmlnJywgJ3Vwc2NhbGVGYWN0b3InXSwgZnJvbVVwc2NhbGVGYWN0b3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICB1cHNjYWxlSW1hZ2VBUElDb25maWdJbnRlcm5hbFRvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXBzY2FsZUltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR2VuZXJhdGVkSW1hZ2VzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlZGljdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tR2VuZXJhdGVkSW1hZ2VzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21HZW5lcmF0ZWRJbWFnZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVkSW1hZ2VGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2VuZXJhdGVkSW1hZ2VzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRNZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbU1sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsTWV0YWRhdGEnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dE1ldGFkYXRhRnJvbVZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVXJsTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tVXJsTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVVybE1ldGFkYXRhO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybE1ldGFkYXRhRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybE1ldGFkYXRhJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHVybENvbnRleHRUb01sZGV2JDEoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxDb250ZXh0VG9WZXJ0ZXgoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUmV0cmlldmVkVXJsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXRyaWV2ZWRVcmwnXSk7XG4gICAgaWYgKGZyb21SZXRyaWV2ZWRVcmwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXRyaWV2ZWRVcmwnXSwgZnJvbVJldHJpZXZlZFVybCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxSZXRyaWV2YWxTdGF0dXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd1cmxSZXRyaWV2YWxTdGF0dXMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVXJsUmV0cmlldmFsU3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJsUmV0cmlldmFsU3RhdHVzJ10sIGZyb21VcmxSZXRyaWV2YWxTdGF0dXMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB1cmxNZXRhZGF0YUZyb21WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVJldHJpZXZlZFVybCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmVkVXJsJ10pO1xuICAgIGlmIChmcm9tUmV0cmlldmVkVXJsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmV0cmlldmVkVXJsJ10sIGZyb21SZXRyaWV2ZWRVcmwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndXJsUmV0cmlldmFsU3RhdHVzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVVybFJldHJpZXZhbFN0YXR1cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybFJldHJpZXZhbFN0YXR1cyddLCBmcm9tVXJsUmV0cmlldmFsU3RhdHVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW8nLCAndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ZpZGVvJyxcbiAgICAgICAgJ2VuY29kZWRWaWRlbycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb0J5dGVzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9CeXRlcyddLCB0Qnl0ZXMoZnJvbVZpZGVvQnl0ZXMpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1pbWVUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmNvZGluZyddKTtcbiAgICBpZiAoZnJvbU1pbWVUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbWltZVR5cGUnXSwgZnJvbU1pbWVUeXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdmlkZW9Gcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21VcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbVVyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VyaSddLCBmcm9tVXJpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVZpZGVvQnl0ZXMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdieXRlc0Jhc2U2NEVuY29kZWQnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmlkZW9CeXRlcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZpZGVvQnl0ZXMnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvR2VuZXJhdGlvbk1hc2tUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tSW1hZ2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ltYWdlJ10pO1xuICAgIGlmIChmcm9tSW1hZ2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfc2VsZiddLCBpbWFnZVRvVmVydGV4KGZyb21JbWFnZSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWFza01vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21hc2tNb2RlJ10pO1xuICAgIGlmIChmcm9tTWFza01vZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtYXNrTW9kZSddLCBmcm9tTWFza01vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb0dlbmVyYXRpb25SZWZlcmVuY2VJbWFnZVRvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21JbWFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaW1hZ2UnXSk7XG4gICAgaWYgKGZyb21JbWFnZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ltYWdlJ10sIGltYWdlVG9WZXJ0ZXgoZnJvbUltYWdlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21SZWZlcmVuY2VUeXBlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncmVmZXJlbmNlVHlwZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZWZlcmVuY2VUeXBlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVmZXJlbmNlVHlwZSddLCBmcm9tUmVmZXJlbmNlVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvTWV0YWRhdGFGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21GcHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZwcyddKTtcbiAgICBpZiAoZnJvbUZwcyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2ZwcyddLCBmcm9tRnBzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kT2Zmc2V0J10pO1xuICAgIGlmIChmcm9tRW5kT2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kT2Zmc2V0J10sIGZyb21FbmRPZmZzZXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10pO1xuICAgIGlmIChmcm9tU3RhcnRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydE9mZnNldCddLCBmcm9tU3RhcnRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZwcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZnBzJ10pO1xuICAgIGlmIChmcm9tRnBzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnBzJ10sIGZyb21GcHMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kT2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21FbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZmZzZXQnXSwgZnJvbUVuZE9mZnNldCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydE9mZnNldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSk7XG4gICAgaWYgKGZyb21TdGFydE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2Zmc2V0J10sIGZyb21TdGFydE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZpZGVvVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXJpJ10pO1xuICAgIGlmIChmcm9tVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ2NzVXJpJ10sIGZyb21VcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmlkZW9CeXRlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmlkZW9CeXRlcyddKTtcbiAgICBpZiAoZnJvbVZpZGVvQnl0ZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydieXRlc0Jhc2U2NEVuY29kZWQnXSwgdEJ5dGVzKGZyb21WaWRlb0J5dGVzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldiQxKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHZvaWNlQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVidWlsdFZvaWNlQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZWJ1aWx0Vm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVidWlsdFZvaWNlQ29uZmlnJ10sIHByZWJ1aWx0Vm9pY2VDb25maWdUb1ZlcnRleChmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IENPTlRFTlRfVFlQRV9IRUFERVIgPSAnQ29udGVudC1UeXBlJztcbmNvbnN0IFNFUlZFUl9USU1FT1VUX0hFQURFUiA9ICdYLVNlcnZlci1UaW1lb3V0JztcbmNvbnN0IFVTRVJfQUdFTlRfSEVBREVSID0gJ1VzZXItQWdlbnQnO1xuY29uc3QgR09PR0xFX0FQSV9DTElFTlRfSEVBREVSID0gJ3gtZ29vZy1hcGktY2xpZW50JztcbmNvbnN0IFNES19WRVJTSU9OID0gJzEuMjIuMCc7IC8vIHgtcmVsZWFzZS1wbGVhc2UtdmVyc2lvblxuY29uc3QgTElCUkFSWV9MQUJFTCA9IGBnb29nbGUtZ2VuYWktc2RrLyR7U0RLX1ZFUlNJT059YDtcbmNvbnN0IFZFUlRFWF9BSV9BUElfREVGQVVMVF9WRVJTSU9OID0gJ3YxYmV0YTEnO1xuY29uc3QgR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT04gPSAndjFiZXRhJztcbmNvbnN0IHJlc3BvbnNlTGluZVJFID0gL15cXHMqZGF0YTogKC4qKSg/OlxcblxcbnxcXHJcXHJ8XFxyXFxuXFxyXFxuKS87XG4vKipcbiAqIFRoZSBBcGlDbGllbnQgY2xhc3MgaXMgdXNlZCB0byBzZW5kIHJlcXVlc3RzIHRvIHRoZSBHZW1pbmkgQVBJIG9yIFZlcnRleCBBSVxuICogZW5kcG9pbnRzLlxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRzKSwgeyBwcm9qZWN0OiBvcHRzLnByb2plY3QsIGxvY2F0aW9uOiBvcHRzLmxvY2F0aW9uLCBhcGlLZXk6IG9wdHMuYXBpS2V5LCB2ZXJ0ZXhhaTogb3B0cy52ZXJ0ZXhhaSB9KTtcbiAgICAgICAgY29uc3QgaW5pdEh0dHBPcHRpb25zID0ge307XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpIHtcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVkVSVEVYX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IHRoaXMuYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRoaXMubm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEdlbWluaSBBUElcbiAgICAgICAgICAgIGluaXRIdHRwT3B0aW9ucy5hcGlWZXJzaW9uID1cbiAgICAgICAgICAgICAgICAoX2IgPSB0aGlzLmNsaWVudE9wdGlvbnMuYXBpVmVyc2lvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogR09PR0xFX0FJX0FQSV9ERUZBVUxUX1ZFUlNJT047XG4gICAgICAgICAgICBpbml0SHR0cE9wdGlvbnMuYmFzZVVybCA9IGBodHRwczovL2dlbmVyYXRpdmVsYW5ndWFnZS5nb29nbGVhcGlzLmNvbS9gO1xuICAgICAgICB9XG4gICAgICAgIGluaXRIdHRwT3B0aW9ucy5oZWFkZXJzID0gdGhpcy5nZXREZWZhdWx0SGVhZGVycygpO1xuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSBpbml0SHR0cE9wdGlvbnM7XG4gICAgICAgIGlmIChvcHRzLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMgPSB0aGlzLnBhdGNoSHR0cE9wdGlvbnMoaW5pdEh0dHBPcHRpb25zLCBvcHRzLmh0dHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHRoZSBiYXNlIFVSTCBmb3IgVmVydGV4IEFJIGJhc2VkIG9uIHByb2plY3QgYW5kIGxvY2F0aW9uLlxuICAgICAqIFVzZXMgdGhlIGdsb2JhbCBlbmRwb2ludCBpZiBsb2NhdGlvbiBpcyAnZ2xvYmFsJyBvciBpZiBwcm9qZWN0L2xvY2F0aW9uXG4gICAgICogYXJlIG5vdCBzcGVjaWZpZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYmFzZVVybEZyb21Qcm9qZWN0TG9jYXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24gIT09ICdnbG9iYWwnKSB7XG4gICAgICAgICAgICAvLyBSZWdpb25hbCBlbmRwb2ludFxuICAgICAgICAgICAgcmV0dXJuIGBodHRwczovLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufS1haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2xvYmFsIGVuZHBvaW50IChjb3ZlcnMgJ2dsb2JhbCcgbG9jYXRpb24gYW5kIEFQSSBrZXkgdXNhZ2UpXG4gICAgICAgIHJldHVybiBgaHR0cHM6Ly9haXBsYXRmb3JtLmdvb2dsZWFwaXMuY29tL2A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZXMgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBmb3IgVmVydGV4IEFJLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBwcm92aWRlZCwgQVBJIGtleSBpcyBjbGVhcmVkLlxuICAgICAqIElmIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBub3QgcHJvdmlkZWQgKGltcGx5aW5nIEFQSSBrZXkgdXNhZ2UpLFxuICAgICAqIHByb2plY3QgYW5kIGxvY2F0aW9uIGFyZSBjbGVhcmVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgbm9ybWFsaXplQXV0aFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCAmJiB0aGlzLmNsaWVudE9wdGlvbnMubG9jYXRpb24pIHtcbiAgICAgICAgICAgIC8vIFVzaW5nIHByb2plY3QvbG9jYXRpb24gZm9yIGF1dGgsIGNsZWFyIHBvdGVudGlhbCBBUEkga2V5XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuYXBpS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzaW5nIEFQSSBrZXkgZm9yIGF1dGggKG9yIG5vIGF1dGggcHJvdmlkZWQgeWV0KSwgY2xlYXIgcHJvamVjdC9sb2NhdGlvblxuICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpc1ZlcnRleEFJKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmNsaWVudE9wdGlvbnMudmVydGV4YWkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRQcm9qZWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLnByb2plY3Q7XG4gICAgfVxuICAgIGdldExvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9uO1xuICAgIH1cbiAgICBnZXRBcGlWZXJzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmFwaVZlcnNpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBUEkgdmVyc2lvbiBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRCYXNlVXJsKCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zICYmXG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlIFVSTCBpcyBub3Qgc2V0LicpO1xuICAgIH1cbiAgICBnZXRSZXF1ZXN0VXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXF1ZXN0VXJsSW50ZXJuYWwodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKTtcbiAgICB9XG4gICAgZ2V0SGVhZGVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucyAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zLmhlYWRlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucy5oZWFkZXJzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIZWFkZXJzIGFyZSBub3Qgc2V0LicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucykge1xuICAgICAgICBpZiAoIWh0dHBPcHRpb25zIHx8XG4gICAgICAgICAgICBodHRwT3B0aW9ucy5iYXNlVXJsID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zLmFwaVZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVFRQIG9wdGlvbnMgYXJlIG5vdCBjb3JyZWN0bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBodHRwT3B0aW9ucy5iYXNlVXJsLmVuZHNXaXRoKCcvJylcbiAgICAgICAgICAgID8gaHR0cE9wdGlvbnMuYmFzZVVybC5zbGljZSgwLCAtMSlcbiAgICAgICAgICAgIDogaHR0cE9wdGlvbnMuYmFzZVVybDtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFtiYXNlVXJsXTtcbiAgICAgICAgaWYgKGh0dHBPcHRpb25zLmFwaVZlcnNpb24gJiYgaHR0cE9wdGlvbnMuYXBpVmVyc2lvbiAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChodHRwT3B0aW9ucy5hcGlWZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJsRWxlbWVudC5qb2luKCcvJyk7XG4gICAgfVxuICAgIGdldEJhc2VSZXNvdXJjZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiBgcHJvamVjdHMvJHt0aGlzLmNsaWVudE9wdGlvbnMucHJvamVjdH0vbG9jYXRpb25zLyR7dGhpcy5jbGllbnRPcHRpb25zLmxvY2F0aW9ufWA7XG4gICAgfVxuICAgIGdldEFwaUtleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50T3B0aW9ucy5hcGlLZXk7XG4gICAgfVxuICAgIGdldFdlYnNvY2tldEJhc2VVcmwoKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSB0aGlzLmdldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgdXJsUGFydHMgPSBuZXcgVVJMKGJhc2VVcmwpO1xuICAgICAgICB1cmxQYXJ0cy5wcm90b2NvbCA9IHVybFBhcnRzLnByb3RvY29sID09ICdodHRwOicgPyAnd3MnIDogJ3dzcyc7XG4gICAgICAgIHJldHVybiB1cmxQYXJ0cy50b1N0cmluZygpO1xuICAgIH1cbiAgICBzZXRCYXNlVXJsKHVybCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMuYmFzZVVybCA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSFRUUCBvcHRpb25zIGFyZSBub3QgY29ycmVjdGx5IHNldC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RVcmwocGF0aCwgaHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pIHtcbiAgICAgICAgY29uc3QgdXJsRWxlbWVudCA9IFt0aGlzLmdldFJlcXVlc3RVcmxJbnRlcm5hbChodHRwT3B0aW9ucyldO1xuICAgICAgICBpZiAocHJlcGVuZFByb2plY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgdXJsRWxlbWVudC5wdXNoKHRoaXMuZ2V0QmFzZVJlc291cmNlUGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF0aCAhPT0gJycpIHtcbiAgICAgICAgICAgIHVybEVsZW1lbnQucHVzaChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3VybEVsZW1lbnQuam9pbignLycpfWApO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBzaG91bGRQcmVwZW5kVmVydGV4UHJvamVjdFBhdGgocmVxdWVzdCkge1xuICAgICAgICBpZiAodGhpcy5jbGllbnRPcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jbGllbnRPcHRpb25zLnZlcnRleGFpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwcm9qZWN0cy8nKSkge1xuICAgICAgICAgICAgLy8gQXNzdW1lIHRoZSBwYXRoIGFscmVhZHkgc3RhcnRzIHdpdGhcbiAgICAgICAgICAgIC8vIGBwcm9qZWN0cy88cHJvamVjdD4vbG9jYXRpb24vPGxvY2F0aW9uPmAuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE1ldGhvZCA9PT0gJ0dFVCcgJiZcbiAgICAgICAgICAgIHJlcXVlc3QucGF0aC5zdGFydHNXaXRoKCdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMnKSkge1xuICAgICAgICAgICAgLy8gVGhlc2UgcGF0aHMgYXJlIHVzZWQgYnkgVmVydGV4J3MgbW9kZWxzLmdldCBhbmQgbW9kZWxzLmxpc3RcbiAgICAgICAgICAgIC8vIGNhbGxzLiBGb3IgYmFzZSBtb2RlbHMgVmVydGV4IGRvZXMgbm90IGFjY2VwdCBhIHByb2plY3QvbG9jYXRpb25cbiAgICAgICAgICAgIC8vIHByZWZpeCAoZm9yIHR1bmVkIG1vZGVsIHRoZSBwcmVmaXggaXMgcmVxdWlyZWQpLlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBhc3luYyByZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICAgICAgbGV0IHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucztcbiAgICAgICAgaWYgKHJlcXVlc3QuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9ucyA9IHRoaXMucGF0Y2hIdHRwT3B0aW9ucyh0aGlzLmNsaWVudE9wdGlvbnMuaHR0cE9wdGlvbnMsIHJlcXVlc3QuaHR0cE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXBlbmRQcm9qZWN0TG9jYXRpb24gPSB0aGlzLnNob3VsZFByZXBlbmRWZXJ0ZXhQcm9qZWN0UGF0aChyZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25zdHJ1Y3RVcmwocmVxdWVzdC5wYXRoLCBwYXRjaGVkSHR0cE9wdGlvbnMsIHByZXBlbmRQcm9qZWN0TG9jYXRpb24pO1xuICAgICAgICBpZiAocmVxdWVzdC5xdWVyeVBhcmFtcykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdC5xdWVyeVBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXF1ZXN0SW5pdCA9IHt9O1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwTWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3QuYm9keSAmJiByZXF1ZXN0LmJvZHkgIT09ICd7fScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3QgYm9keSBzaG91bGQgYmUgZW1wdHkgZm9yIEdFVCByZXF1ZXN0LCBidXQgZ290IG5vbiBlbXB0eSByZXF1ZXN0IGJvZHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEluaXQgPSBhd2FpdCB0aGlzLmluY2x1ZGVFeHRyYUh0dHBPcHRpb25zVG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgcGF0Y2hlZEh0dHBPcHRpb25zLCByZXF1ZXN0LmFib3J0U2lnbmFsKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5hcnlBcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIHJlcXVlc3QuaHR0cE1ldGhvZCk7XG4gICAgfVxuICAgIHBhdGNoSHR0cE9wdGlvbnMoYmFzZUh0dHBPcHRpb25zLCByZXF1ZXN0SHR0cE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEh0dHBPcHRpb25zID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShiYXNlSHR0cE9wdGlvbnMpKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocmVxdWVzdEh0dHBPcHRpb25zKSkge1xuICAgICAgICAgICAgLy8gUmVjb3JkcyBjb21waWxlIHRvIG9iamVjdHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVFMyMzQ1VFM3MDUzOiBFbGVtZW50IGltcGxpY2l0bHkgaGFzIGFuICdhbnknIHR5cGVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGV4cHJlc3Npb24gb2YgdHlwZSAnc3RyaW5nJyBjYW4ndCBiZSB1c2VkIHRvIGluZGV4IHR5cGVcbiAgICAgICAgICAgICAgICAvLyAnSHR0cE9wdGlvbnMnLlxuICAgICAgICAgICAgICAgIHBhdGNoZWRIdHRwT3B0aW9uc1trZXldID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFRTMjM0NVRTNzA1MzogRWxlbWVudCBpbXBsaWNpdGx5IGhhcyBhbiAnYW55JyB0eXBlXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBleHByZXNzaW9uIG9mIHR5cGUgJ3N0cmluZycgY2FuJ3QgYmUgdXNlZCB0byBpbmRleCB0eXBlXG4gICAgICAgICAgICAgICAgLy8gJ0h0dHBPcHRpb25zJy5cbiAgICAgICAgICAgICAgICBwYXRjaGVkSHR0cE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRjaGVkSHR0cE9wdGlvbnM7XG4gICAgfVxuICAgIGFzeW5jIHJlcXVlc3RTdHJlYW0ocmVxdWVzdCkge1xuICAgICAgICBsZXQgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5jbGllbnRPcHRpb25zLmh0dHBPcHRpb25zO1xuICAgICAgICBpZiAocmVxdWVzdC5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgcGF0Y2hlZEh0dHBPcHRpb25zID0gdGhpcy5wYXRjaEh0dHBPcHRpb25zKHRoaXMuY2xpZW50T3B0aW9ucy5odHRwT3B0aW9ucywgcmVxdWVzdC5odHRwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJlcGVuZFByb2plY3RMb2NhdGlvbiA9IHRoaXMuc2hvdWxkUHJlcGVuZFZlcnRleFByb2plY3RQYXRoKHJlcXVlc3QpO1xuICAgICAgICBjb25zdCB1cmwgPSB0aGlzLmNvbnN0cnVjdFVybChyZXF1ZXN0LnBhdGgsIHBhdGNoZWRIdHRwT3B0aW9ucywgcHJlcGVuZFByb2plY3RMb2NhdGlvbik7XG4gICAgICAgIGlmICghdXJsLnNlYXJjaFBhcmFtcy5oYXMoJ2FsdCcpIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KCdhbHQnKSAhPT0gJ3NzZScpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdhbHQnLCAnc3NlJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlcXVlc3RJbml0ID0ge307XG4gICAgICAgIHJlcXVlc3RJbml0LmJvZHkgPSByZXF1ZXN0LmJvZHk7XG4gICAgICAgIHJlcXVlc3RJbml0ID0gYXdhaXQgdGhpcy5pbmNsdWRlRXh0cmFIdHRwT3B0aW9uc1RvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIHBhdGNoZWRIdHRwT3B0aW9ucywgcmVxdWVzdC5hYm9ydFNpZ25hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbUFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCwgcmVxdWVzdC5odHRwTWV0aG9kKTtcbiAgICB9XG4gICAgYXN5bmMgaW5jbHVkZUV4dHJhSHR0cE9wdGlvbnNUb1JlcXVlc3RJbml0KHJlcXVlc3RJbml0LCBodHRwT3B0aW9ucywgYWJvcnRTaWduYWwpIHtcbiAgICAgICAgaWYgKChodHRwT3B0aW9ucyAmJiBodHRwT3B0aW9ucy50aW1lb3V0KSB8fCBhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmFsID0gYWJvcnRDb250cm9sbGVyLnNpZ25hbDtcbiAgICAgICAgICAgIGlmIChodHRwT3B0aW9ucy50aW1lb3V0ICYmIChodHRwT3B0aW9ucyA9PT0gbnVsbCB8fCBodHRwT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cE9wdGlvbnMudGltZW91dCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4gYWJvcnRDb250cm9sbGVyLmFib3J0KCksIGh0dHBPcHRpb25zLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SGFuZGxlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0aW1lb3V0SGFuZGxlLnVucmVmID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHVucmVmIHRvIHByZXZlbnQgbm9kZWpzIHByb2Nlc3MgZnJvbSBoYW5naW5nLCBzZWVcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS90aW1lcnMuaHRtbCN0aW1lb3V0dW5yZWZcbiAgICAgICAgICAgICAgICAgICAgdGltZW91dEhhbmRsZS51bnJlZigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RJbml0LnNpZ25hbCA9IHNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuZXh0cmFCb2R5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpbmNsdWRlRXh0cmFCb2R5VG9SZXF1ZXN0SW5pdChyZXF1ZXN0SW5pdCwgaHR0cE9wdGlvbnMuZXh0cmFCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0SW5pdC5oZWFkZXJzID0gYXdhaXQgdGhpcy5nZXRIZWFkZXJzSW50ZXJuYWwoaHR0cE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gcmVxdWVzdEluaXQ7XG4gICAgfVxuICAgIGFzeW5jIHVuYXJ5QXBpQ2FsbCh1cmwsIHJlcXVlc3RJbml0LCBodHRwTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwaUNhbGwodXJsLnRvU3RyaW5nKCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdEluaXQpLCB7IG1ldGhvZDogaHR0cE1ldGhvZCB9KSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhyb3dFcnJvcklmTm90T0socmVzcG9uc2UpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBIdHRwUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzdHJlYW1BcGlDYWxsKHVybCwgcmVxdWVzdEluaXQsIGh0dHBNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpQ2FsbCh1cmwudG9TdHJpbmcoKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0SW5pdCksIHsgbWV0aG9kOiBodHRwTWV0aG9kIH0pKVxuICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBhd2FpdCB0aHJvd0Vycm9ySWZOb3RPSyhyZXNwb25zZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihKU09OLnN0cmluZ2lmeShlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwcm9jZXNzU3RyZWFtUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBwcm9jZXNzU3RyZWFtUmVzcG9uc2VfMSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5ib2R5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcpO1xuICAgICAgICAgICAgaWYgKCFyZWFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3BvbnNlIGJvZHkgaXMgZW1wdHknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHlpZWxkIF9fYXdhaXQocmVhZGVyLnJlYWQoKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLnRyaW0oKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBsZXRlIEpTT04gc2VnbWVudCBhdCB0aGUgZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVua1N0cmluZyA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHRocm93IGFuIGVycm9yIGlmIHRoZSBjaHVuayBjb250YWlucyBhbiBlcnJvci5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rSnNvbiA9IEpTT04ucGFyc2UoY2h1bmtTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gY2h1bmtKc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3JKc29uID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjaHVua0pzb25bJ2Vycm9yJ10pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXMgPSBlcnJvckpzb25bJ3N0YXR1cyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlcnJvckpzb25bJ2NvZGUnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBgZ290IHN0YXR1czogJHtzdGF0dXN9LiAke0pTT04uc3RyaW5naWZ5KGNodW5rSnNvbil9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZSA+PSA0MDAgJiYgY29kZSA8IDYwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQXBpRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXIgKz0gY2h1bmtTdHJpbmc7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkQ2h1bmtTdHJpbmcgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKHByb2Nlc3NlZENodW5rU3RyaW5nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQobmV3IEh0dHBSZXNwb25zZShwYXJ0aWFsUmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGJ1ZmZlci5tYXRjaChyZXNwb25zZUxpbmVSRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uIHBhcnNpbmcgc3RyZWFtIGNodW5rICR7cHJvY2Vzc2VkQ2h1bmtTdHJpbmd9LiAke2V9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByZWFkZXIucmVsZWFzZUxvY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGFwaUNhbGwodXJsLCByZXF1ZXN0SW5pdCkge1xuICAgICAgICByZXR1cm4gZmV0Y2godXJsLCByZXF1ZXN0SW5pdCkuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhjZXB0aW9uICR7ZX0gc2VuZGluZyByZXF1ZXN0YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWZhdWx0SGVhZGVycygpIHtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGVhZGVyVmFsdWUgPSBMSUJSQVJZX0xBQkVMICsgJyAnICsgdGhpcy5jbGllbnRPcHRpb25zLnVzZXJBZ2VudEV4dHJhO1xuICAgICAgICBoZWFkZXJzW1VTRVJfQUdFTlRfSEVBREVSXSA9IHZlcnNpb25IZWFkZXJWYWx1ZTtcbiAgICAgICAgaGVhZGVyc1tHT09HTEVfQVBJX0NMSUVOVF9IRUFERVJdID0gdmVyc2lvbkhlYWRlclZhbHVlO1xuICAgICAgICBoZWFkZXJzW0NPTlRFTlRfVFlQRV9IRUFERVJdID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG4gICAgYXN5bmMgZ2V0SGVhZGVyc0ludGVybmFsKGh0dHBPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICBpZiAoaHR0cE9wdGlvbnMgJiYgaHR0cE9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoaHR0cE9wdGlvbnMuaGVhZGVycykpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGVuZCBhIHRpbWVvdXQgaGVhZGVyIGlmIGl0IGlzIHNldCwgbm90ZSB0aGF0IHRoZSB0aW1lb3V0IG9wdGlvbiBpc1xuICAgICAgICAgICAgLy8gaW4gbWlsbGlzZWNvbmRzIGJ1dCB0aGUgaGVhZGVyIGlzIGluIHNlY29uZHMuXG4gICAgICAgICAgICBpZiAoaHR0cE9wdGlvbnMudGltZW91dCAmJiBodHRwT3B0aW9ucy50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKFNFUlZFUl9USU1FT1VUX0hFQURFUiwgU3RyaW5nKE1hdGguY2VpbChodHRwT3B0aW9ucy50aW1lb3V0IC8gMTAwMCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLmNsaWVudE9wdGlvbnMuYXV0aC5hZGRBdXRoSGVhZGVycyhoZWFkZXJzKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHVzaW5nIEdlbWluaSBBUEkgb25seSwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICogaW4gVmVydGV4IEFJLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGUgVGhlIHN0cmluZyBwYXRoIHRvIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkIG9yIGEgQmxvYiBvYmplY3QuXG4gICAgICogQHBhcmFtIGNvbmZpZyBPcHRpb25hbCBwYXJhbWV0ZXJzIHNwZWNpZmllZCBpbiB0aGUgYFVwbG9hZEZpbGVDb25maWdgXG4gICAgICogICAgIGludGVyZmFjZS4gQHNlZSB7QGxpbmsgVXBsb2FkRmlsZUNvbmZpZ31cbiAgICAgKiBAcmV0dXJuIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYEZpbGVgIG9iamVjdC5cbiAgICAgKiBAdGhyb3dzIEFuIGVycm9yIGlmIGNhbGxlZCBvbiBhIFZlcnRleCBBSSBjbGllbnQuXG4gICAgICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgYG1pbWVUeXBlYCBpcyBub3QgcHJvdmlkZWQgYW5kIGNhbiBub3QgYmUgaW5mZXJyZWQsXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRmlsZShmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBmaWxlVG9VcGxvYWQgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubWltZVR5cGUgPSBjb25maWcubWltZVR5cGU7XG4gICAgICAgICAgICBmaWxlVG9VcGxvYWQubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgICAgICAgICAgZmlsZVRvVXBsb2FkLmRpc3BsYXlOYW1lID0gY29uZmlnLmRpc3BsYXlOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWxlVG9VcGxvYWQubmFtZSAmJiAhZmlsZVRvVXBsb2FkLm5hbWUuc3RhcnRzV2l0aCgnZmlsZXMvJykpIHtcbiAgICAgICAgICAgIGZpbGVUb1VwbG9hZC5uYW1lID0gYGZpbGVzLyR7ZmlsZVRvVXBsb2FkLm5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRlciA9IHRoaXMuY2xpZW50T3B0aW9ucy51cGxvYWRlcjtcbiAgICAgICAgY29uc3QgZmlsZVN0YXQgPSBhd2FpdCB1cGxvYWRlci5zdGF0KGZpbGUpO1xuICAgICAgICBmaWxlVG9VcGxvYWQuc2l6ZUJ5dGVzID0gU3RyaW5nKGZpbGVTdGF0LnNpemUpO1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IChfYSA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZVN0YXQudHlwZTtcbiAgICAgICAgaWYgKG1pbWVUeXBlID09PSB1bmRlZmluZWQgfHwgbWltZVR5cGUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgZGV0ZXJtaW5lIG1pbWVUeXBlLiBQbGVhc2UgcHJvdmlkZSBtaW1lVHlwZSBpbiB0aGUgY29uZmlnLicpO1xuICAgICAgICB9XG4gICAgICAgIGZpbGVUb1VwbG9hZC5taW1lVHlwZSA9IG1pbWVUeXBlO1xuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSBhd2FpdCB0aGlzLmZldGNoVXBsb2FkVXJsKGZpbGVUb1VwbG9hZCwgY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHVwbG9hZGVyLnVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZHMgYSBmaWxlIGFzeW5jaHJvbm91c2x5IHRvIHRoZSBzcGVjaWZpZWQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBwYXJhbXMgcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBkb3dubG9hZCByZXF1ZXN0LCBzZWUge0BsaW5rXG4gICAgICogRG93bmxvYWRGaWxlUGFyYW1ldGVyc31cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZEZpbGUocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRvd25sb2FkZXIgPSB0aGlzLmNsaWVudE9wdGlvbnMuZG93bmxvYWRlcjtcbiAgICAgICAgYXdhaXQgZG93bmxvYWRlci5kb3dubG9hZChwYXJhbXMsIHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBmZXRjaFVwbG9hZFVybChmaWxlLCBjb25maWcpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB7fTtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5odHRwT3B0aW9ucykge1xuICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBodHRwT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLVByb3RvY29sJzogJ3Jlc3VtYWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLUNvbW1hbmQnOiAnc3RhcnQnLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1MZW5ndGgnOiBgJHtmaWxlLnNpemVCeXRlc31gLFxuICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1IZWFkZXItQ29udGVudC1UeXBlJzogYCR7ZmlsZS5taW1lVHlwZX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgICAgICAnZmlsZSc6IGZpbGUsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGh0dHBSZXNwb25zZSA9IGF3YWl0IHRoaXMucmVxdWVzdCh7XG4gICAgICAgICAgICBwYXRoOiBmb3JtYXRNYXAoJ3VwbG9hZC92MWJldGEvZmlsZXMnLCBib2R5WydfdXJsJ10pLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBodHRwT3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaHR0cFJlc3BvbnNlIHx8ICEoaHR0cFJlc3BvbnNlID09PSBudWxsIHx8IGh0dHBSZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHR0cFJlc3BvbnNlLmhlYWRlcnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcnZlciBkaWQgbm90IHJldHVybiBhbiBIdHRwUmVzcG9uc2Ugb3IgdGhlIHJldHVybmVkIEh0dHBSZXNwb25zZSBkaWQgbm90IGhhdmUgaGVhZGVycy4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cGxvYWRVcmwgPSAoX2EgPSBodHRwUmVzcG9uc2UgPT09IG51bGwgfHwgaHR0cFJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBodHRwUmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWyd4LWdvb2ctdXBsb2FkLXVybCddO1xuICAgICAgICBpZiAodXBsb2FkVXJsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCB1cGxvYWQgdXJsLiBTZXJ2ZXIgZGlkIG5vdCByZXR1cm4gdGhlIHgtZ29vZ2xlLXVwbG9hZC11cmwgaW4gdGhlIGhlYWRlcnMnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXBsb2FkVXJsO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHRocm93RXJyb3JJZk5vdE9LKHJlc3BvbnNlKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChyZXNwb25zZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3JCb2R5O1xuICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JCb2R5ID0ge1xuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGF3YWl0IHJlc3BvbnNlLnRleHQoKSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZXJyb3JCb2R5KTtcbiAgICAgICAgaWYgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBBcGlFcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBhcGlFcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFJlY3Vyc2l2ZWx5IHVwZGF0ZXMgdGhlIGByZXF1ZXN0SW5pdC5ib2R5YCB3aXRoIHZhbHVlcyBmcm9tIGFuIGBleHRyYUJvZHlgIG9iamVjdC5cbiAqXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBzdHJpbmcsIGl0J3MgYXNzdW1lZCB0byBiZSBKU09OIGFuZCB3aWxsIGJlIHBhcnNlZC5cbiAqIFRoZSBgZXh0cmFCb2R5YCBpcyB0aGVuIGRlZXBseSBtZXJnZWQgaW50byB0aGlzIHBhcnNlZCBvYmplY3QuXG4gKiBJZiBgcmVxdWVzdEluaXQuYm9keWAgaXMgYSBCbG9iLCBgZXh0cmFCb2R5YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCBhIHdhcm5pbmcgbG9nZ2VkLFxuICogYXMgbWVyZ2luZyBzdHJ1Y3R1cmVkIGRhdGEgaW50byBhbiBvcGFxdWUgQmxvYiBpcyBub3Qgc3VwcG9ydGVkLlxuICpcbiAqIFRoZSBmdW5jdGlvbiBkb2VzIG5vdCBlbmZvcmNlIHRoYXQgdXBkYXRlZCB2YWx1ZXMgZnJvbSBgZXh0cmFCb2R5YCBoYXZlIHRoZVxuICogc2FtZSB0eXBlIGFzIGV4aXN0aW5nIHZhbHVlcyBpbiBgcmVxdWVzdEluaXQuYm9keWAuIFR5cGUgbWlzbWF0Y2hlcyBkdXJpbmdcbiAqIHRoZSBtZXJnZSB3aWxsIHJlc3VsdCBpbiBhIHdhcm5pbmcsIGJ1dCB0aGUgdmFsdWUgZnJvbSBgZXh0cmFCb2R5YCB3aWxsIG92ZXJ3cml0ZVxuICogdGhlIG9yaWdpbmFsLiBgZXh0cmFCb2R5YCB1c2VycyBhcmUgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIGBleHRyYUJvZHlgIGhhcyB0aGUgY29ycmVjdCBzdHJ1Y3R1cmUuXG4gKlxuICogQHBhcmFtIHJlcXVlc3RJbml0IFRoZSBSZXF1ZXN0SW5pdCBvYmplY3Qgd2hvc2UgYm9keSB3aWxsIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gZXh0cmFCb2R5IFRoZSBvYmplY3QgY29udGFpbmluZyB1cGRhdGVzIHRvIGJlIG1lcmdlZCBpbnRvIGByZXF1ZXN0SW5pdC5ib2R5YC5cbiAqL1xuZnVuY3Rpb24gaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQocmVxdWVzdEluaXQsIGV4dHJhQm9keSkge1xuICAgIGlmICghZXh0cmFCb2R5IHx8IE9iamVjdC5rZXlzKGV4dHJhQm9keSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHJlcXVlc3RJbml0LmJvZHkgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IGV4dHJhQm9keSBwcm92aWRlZCBidXQgY3VycmVudCByZXF1ZXN0IGJvZHkgaXMgYSBCbG9iLiBleHRyYUJvZHkgd2lsbCBiZSBpZ25vcmVkIGFzIG1lcmdpbmcgaXMgbm90IHN1cHBvcnRlZCBmb3IgQmxvYiBib2RpZXMuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRCb2R5T2JqZWN0ID0ge307XG4gICAgLy8gSWYgYWRkaW5nIG5ldyB0eXBlIHRvIEh0dHBSZXF1ZXN0LmJvZHksIHBsZWFzZSBjaGVjayB0aGUgY29kZSBiZWxvdyB0b1xuICAgIC8vIHNlZSBpZiB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgbG9naWMuXG4gICAgaWYgKHR5cGVvZiByZXF1ZXN0SW5pdC5ib2R5ID09PSAnc3RyaW5nJyAmJiByZXF1ZXN0SW5pdC5ib2R5Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEJvZHkgPSBKU09OLnBhcnNlKHJlcXVlc3RJbml0LmJvZHkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWRCb2R5ID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShwYXJzZWRCb2R5KSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRCb2R5T2JqZWN0ID0gcGFyc2VkQm9keTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyB2YWxpZCBKU09OIGJ1dCBub3QgYSBub24tYXJyYXkgb2JqZWN0LiBTa2lwIGFwcGx5aW5nIGV4dHJhQm9keSB0byB0aGUgcmVxdWVzdCBib2R5LicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qICBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW5jbHVkZUV4dHJhQm9keVRvUmVxdWVzdEluaXQ6IE9yaWdpbmFsIHJlcXVlc3QgYm9keSBpcyBub3QgdmFsaWQgSlNPTi4gU2tpcCBhcHBseWluZyBleHRyYUJvZHkgdG8gdGhlIHJlcXVlc3QgYm9keS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0VmFsdWUgPSBvdXRwdXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHNvdXJjZVZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheShzb3VyY2VWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHRhcmdldFZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRWYWx1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlVmFsdWUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0YXJnZXRWYWx1ZSAhPT0gdHlwZW9mIHNvdXJjZVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYGluY2x1ZGVFeHRyYUJvZHlUb1JlcXVlc3RJbml0OmRlZXBNZXJnZTogVHlwZSBtaXNtYXRjaCBmb3Iga2V5IFwiJHtrZXl9XCIuIE9yaWdpbmFsIHR5cGU6ICR7dHlwZW9mIHRhcmdldFZhbHVlfSwgTmV3IHR5cGU6ICR7dHlwZW9mIHNvdXJjZVZhbHVlfS4gT3ZlcndyaXRpbmcuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2VWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkQm9keSA9IGRlZXBNZXJnZShjdXJyZW50Qm9keU9iamVjdCwgZXh0cmFCb2R5KTtcbiAgICByZXF1ZXN0SW5pdC5ib2R5ID0gSlNPTi5zdHJpbmdpZnkobWVyZ2VkQm9keSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8vIFRPRE86IGIvNDE2MDQxMjI5IC0gRGV0ZXJtaW5lIGhvdyB0byByZXRyaWV2ZSB0aGUgTUNQIHBhY2thZ2UgdmVyc2lvbi5cbmNvbnN0IE1DUF9MQUJFTCA9ICdtY3BfdXNlZC91bmtub3duJztcbi8vIFdoZXRoZXIgTUNQIHRvb2wgdXNhZ2UgaXMgZGV0ZWN0ZWQgZnJvbSBtY3BUb1Rvb2wuIFRoaXMgaXMgdXNlZCBmb3Jcbi8vIHRlbGVtZXRyeS5cbmxldCBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sID0gZmFsc2U7XG4vLyBDaGVja3Mgd2hldGhlciB0aGUgbGlzdCBvZiB0b29scyBjb250YWlucyBhbnkgTUNQIHRvb2xzLlxuZnVuY3Rpb24gaGFzTWNwVG9vbFVzYWdlKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIHRvb2xzKSB7XG4gICAgICAgIGlmIChpc01jcENhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b29sID09PSAnb2JqZWN0JyAmJiAnaW5wdXRTY2hlbWEnIGluIHRvb2wpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNNY3BUb29sVXNhZ2VGcm9tTWNwVG9Ub29sO1xufVxuLy8gU2V0cyB0aGUgTUNQIHZlcnNpb24gbGFiZWwgaW4gdGhlIEdvb2dsZSBBUEkgY2xpZW50IGhlYWRlci5cbmZ1bmN0aW9uIHNldE1jcFVzYWdlSGVhZGVyKGhlYWRlcnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXhpc3RpbmdIZWFkZXIgPSAoX2EgPSBoZWFkZXJzW0dPT0dMRV9BUElfQ0xJRU5UX0hFQURFUl0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgIGhlYWRlcnNbR09PR0xFX0FQSV9DTElFTlRfSEVBREVSXSA9IChleGlzdGluZ0hlYWRlciArIGAgJHtNQ1BfTEFCRUx9YCkudHJpbVN0YXJ0KCk7XG59XG4vLyBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhIE1DUCBDYWxsYWJsZVRvb2wsIG90aGVyd2lzZSBmYWxzZS5cbmZ1bmN0aW9uIGlzTWNwQ2FsbGFibGVUb29sKG9iamVjdCkge1xuICAgIHJldHVybiAob2JqZWN0ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICAgIG9iamVjdCBpbnN0YW5jZW9mIE1jcENhbGxhYmxlVG9vbCk7XG59XG4vLyBMaXN0IGFsbCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50LlxuZnVuY3Rpb24gbGlzdEFsbFRvb2xzKG1jcENsaWVudCwgbWF4VG9vbHMgPSAxMDApIHtcbiAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiBsaXN0QWxsVG9vbHNfMSgpIHtcbiAgICAgICAgbGV0IGN1cnNvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IG51bVRvb2xzID0gMDtcbiAgICAgICAgd2hpbGUgKG51bVRvb2xzIDwgbWF4VG9vbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSB5aWVsZCBfX2F3YWl0KG1jcENsaWVudC5saXN0VG9vbHMoeyBjdXJzb3IgfSkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHQudG9vbHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHRvb2wpO1xuICAgICAgICAgICAgICAgIG51bVRvb2xzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXQubmV4dEN1cnNvcikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3Vyc29yID0gdC5uZXh0Q3Vyc29yO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIE1jcENhbGxhYmxlVG9vbCBjYW4gYmUgdXNlZCBmb3IgbW9kZWwgaW5mZXJlbmNlIGFuZCBpbnZva2luZyBNQ1AgY2xpZW50cyB3aXRoXG4gKiBnaXZlbiBmdW5jdGlvbiBjYWxsIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmNsYXNzIE1jcENhbGxhYmxlVG9vbCB7XG4gICAgY29uc3RydWN0b3IobWNwQ2xpZW50cyA9IFtdLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5tY3BUb29scyA9IFtdO1xuICAgICAgICB0aGlzLmZ1bmN0aW9uTmFtZVRvTWNwQ2xpZW50ID0ge307XG4gICAgICAgIHRoaXMubWNwQ2xpZW50cyA9IG1jcENsaWVudHM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTWNwQ2FsbGFibGVUb29sLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUobWNwQ2xpZW50cywgY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWNwQ2FsbGFibGVUb29sKG1jcENsaWVudHMsIGNvbmZpZyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyB0aGUgZnVuY3Rpb24gbmFtZXMgYXJlIG5vdCBkdXBsaWNhdGUgYW5kIGluaXRpYWxpemUgdGhlIGZ1bmN0aW9uXG4gICAgICogbmFtZSB0byBNQ1AgY2xpZW50IG1hcHBpbmcuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgdGhlIE1DUCB0b29scyBmcm9tIHRoZSBNQ1AgY2xpZW50cyBoYXZlIGR1cGxpY2F0ZSB0b29sXG4gICAgICogICAgIG5hbWVzLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIGlmICh0aGlzLm1jcFRvb2xzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbk1hcCA9IHt9O1xuICAgICAgICBjb25zdCBtY3BUb29scyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1jcENsaWVudCBvZiB0aGlzLm1jcENsaWVudHMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IChlXzEgPSB2b2lkIDAsIF9fYXN5bmNWYWx1ZXMobGlzdEFsbFRvb2xzKG1jcENsaWVudCkpKSwgX2Y7IF9mID0gYXdhaXQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9kID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1jcFRvb2wgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgbWNwVG9vbHMucHVzaChtY3BUb29sKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWNwVG9vbE5hbWUgPSBtY3BUb29sLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmdW5jdGlvbk1hcFttY3BUb29sTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGZ1bmN0aW9uIG5hbWUgJHttY3BUb29sTmFtZX0gZm91bmQgaW4gTUNQIHRvb2xzLiBQbGVhc2UgZW5zdXJlIGZ1bmN0aW9uIG5hbWVzIGFyZSB1bmlxdWUuYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25NYXBbbWNwVG9vbE5hbWVdID0gbWNwQ2xpZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWNwVG9vbHMgPSBtY3BUb29scztcbiAgICAgICAgdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCA9IGZ1bmN0aW9uTWFwO1xuICAgIH1cbiAgICBhc3luYyB0b29sKCkge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgcmV0dXJuIG1jcFRvb2xzVG9HZW1pbmlUb29sKHRoaXMubWNwVG9vbHMsIHRoaXMuY29uZmlnKTtcbiAgICB9XG4gICAgYXN5bmMgY2FsbFRvb2woZnVuY3Rpb25DYWxscykge1xuICAgICAgICBhd2FpdCB0aGlzLmluaXRpYWxpemUoKTtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsUmVzcG9uc2VQYXJ0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uQ2FsbCBvZiBmdW5jdGlvbkNhbGxzKSB7XG4gICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm5hbWUgaW4gdGhpcy5mdW5jdGlvbk5hbWVUb01jcENsaWVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1jcENsaWVudCA9IHRoaXMuZnVuY3Rpb25OYW1lVG9NY3BDbGllbnRbZnVuY3Rpb25DYWxsLm5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBiLzQyNDIzODY1NCAtIEFkZCBzdXBwb3J0IGZvciBmaW5lciBncmFpbmVkIHRpbWVvdXQgY29udHJvbC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25maWcudGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxUb29sUmVzcG9uc2UgPSBhd2FpdCBtY3BDbGllbnQuY2FsbFRvb2woe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbkNhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBmdW5jdGlvbkNhbGwuYXJncyxcbiAgICAgICAgICAgICAgICB9LCBcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIHJlc3VsdCBzY2hlbWEgdG8gdW5kZWZpbmVkIHRvIGFsbG93IE1DUCB0byByZWx5IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc2NoZW1hLlxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgcmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uQ2FsbFJlc3BvbnNlUGFydHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGZ1bmN0aW9uQ2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IGNhbGxUb29sUmVzcG9uc2UuaXNFcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBlcnJvcjogY2FsbFRvb2xSZXNwb25zZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxsVG9vbFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbkNhbGxSZXNwb25zZVBhcnRzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzTWNwQ2xpZW50KGNsaWVudCkge1xuICAgIHJldHVybiAoY2xpZW50ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBjbGllbnQgPT09ICdvYmplY3QnICYmXG4gICAgICAgICdsaXN0VG9vbHMnIGluIGNsaWVudCAmJlxuICAgICAgICB0eXBlb2YgY2xpZW50Lmxpc3RUb29scyA9PT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBNY3BDYWxsYWJsZVRvb2wgZnJvbSBNQ1AgY2xpZW50cyBhbmQgYW4gb3B0aW9uYWwgY29uZmlnLlxuICpcbiAqIFRoZSBjYWxsYWJsZSB0b29sIGNhbiBpbnZva2UgdGhlIE1DUCBjbGllbnRzIHdpdGggZ2l2ZW4gZnVuY3Rpb24gY2FsbFxuICogYXJndW1lbnRzLiAob2Z0ZW4gZm9yIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nKS5cbiAqIFVzZSB0aGUgY29uZmlnIHRvIG1vZGlmeSB0b29sIHBhcmFtZXRlcnMgc3VjaCBhcyBiZWhhdmlvci5cbiAqXG4gKiBAZXhwZXJpbWVudGFsIEJ1aWx0LWluIE1DUCBzdXBwb3J0IGlzIGFuIGV4cGVyaW1lbnRhbCBmZWF0dXJlLCBtYXkgY2hhbmdlIGluIGZ1dHVyZVxuICogdmVyc2lvbnMuXG4gKi9cbmZ1bmN0aW9uIG1jcFRvVG9vbCguLi5hcmdzKSB7XG4gICAgLy8gU2V0IE1DUCB1c2FnZSBmb3IgdGVsZW1ldHJ5LlxuICAgIGhhc01jcFRvb2xVc2FnZUZyb21NY3BUb1Rvb2wgPSB0cnVlO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIE1DUCBjbGllbnRzIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IG1heWJlQ29uZmlnID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc01jcENsaWVudChtYXliZUNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIE1jcENhbGxhYmxlVG9vbC5jcmVhdGUoYXJncywge30pO1xuICAgIH1cbiAgICByZXR1cm4gTWNwQ2FsbGFibGVUb29sLmNyZWF0ZShhcmdzLnNsaWNlKDAsIGFyZ3MubGVuZ3RoIC0gMSksIG1heWJlQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgYW5kIHRoZW4gY2FsbGluZyB0aGUgb25tZXNzYWdlIGNhbGxiYWNrLlxuICogTm90ZSB0aGF0IHRoZSBmaXJzdCBtZXNzYWdlIHdoaWNoIGlzIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciBpcyBhXG4gKiBzZXR1cENvbXBsZXRlIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGFwaUNsaWVudCBUaGUgQXBpQ2xpZW50IGluc3RhbmNlLlxuICogQHBhcmFtIG9ubWVzc2FnZSBUaGUgdXNlci1wcm92aWRlZCBvbm1lc3NhZ2UgY2FsbGJhY2sgKGlmIGFueSkuXG4gKiBAcGFyYW0gZXZlbnQgVGhlIE1lc3NhZ2VFdmVudCBmcm9tIHRoZSBXZWJTb2NrZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UkMShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVNdXNpY1NlcnZlck1lc3NhZ2UoKTtcbiAgICBsZXQgZGF0YTtcbiAgICBpZiAoZXZlbnQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoYXdhaXQgZXZlbnQuZGF0YS50ZXh0KCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlID0gbGl2ZU11c2ljU2VydmVyTWVzc2FnZUZyb21NbGRldihkYXRhKTtcbiAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3BvbnNlKTtcbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmVNdXNpYyBjbGFzcyBlbmNhcHN1bGF0ZXMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIGxpdmUgbXVzaWNcbiAgIGdlbmVyYXRpb24gdmlhIEx5cmlhIExpdmUgbW9kZWxzLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWMge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgYW5kIHJldHVybnMgYVxuICAgICAgIExpdmVNdXNpY1Nlc3Npb24gb2JqZWN0IHJlcHJlc2VudGluZyB0aGF0IGNvbm5lY3Rpb24uXG4gIFxuICAgICAgIEBleHBlcmltZW50YWxcbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsID0gJ21vZGVscy9seXJpYS1yZWFsdGltZS1leHAnO1xuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLm11c2ljLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ubWVzc2FnZTogKGU6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBtZXNzYWdlIGZyb20gdGhlIHNlcnZlcjogJXNcXG4nLCBkZWJ1ZyhlLmRhdGEpKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25lcnJvcjogKGU6IEVycm9yRXZlbnQpID0+IHtcbiAgICAgICAgICAgICBjb25zb2xlLmxvZygnRXJyb3Igb2NjdXJyZWQ6ICVzXFxuJywgZGVidWcoZS5lcnJvcikpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmNsb3NlOiAoZTogQ2xvc2VFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0aW9uIGNsb3NlZC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgIH0sXG4gICAgICAgfSk7XG4gICAgICAgYGBgXG4gICAgICAqL1xuICAgIGFzeW5jIGNvbm5lY3QocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTGl2ZSBtdXNpYyBpcyBub3Qgc3VwcG9ydGVkIGZvciBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKCdMaXZlIG11c2ljIGdlbmVyYXRpb24gaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlIGluIGZ1dHVyZSB2ZXJzaW9ucy4nKTtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0QmFzZVVybCA9IHRoaXMuYXBpQ2xpZW50LmdldFdlYnNvY2tldEJhc2VVcmwoKTtcbiAgICAgICAgY29uc3QgYXBpVmVyc2lvbiA9IHRoaXMuYXBpQ2xpZW50LmdldEFwaVZlcnNpb24oKTtcbiAgICAgICAgY29uc3QgaGVhZGVycyA9IG1hcFRvSGVhZGVycyQxKHRoaXMuYXBpQ2xpZW50LmdldERlZmF1bHRIZWFkZXJzKCkpO1xuICAgICAgICBjb25zdCBhcGlLZXkgPSB0aGlzLmFwaUNsaWVudC5nZXRBcGlLZXkoKTtcbiAgICAgICAgY29uc3QgdXJsID0gYCR7d2Vic29ja2V0QmFzZVVybH0vd3MvZ29vZ2xlLmFpLmdlbmVyYXRpdmVsYW5ndWFnZS4ke2FwaVZlcnNpb259LkdlbmVyYXRpdmVTZXJ2aWNlLkJpZGlHZW5lcmF0ZU11c2ljP2tleT0ke2FwaUtleX1gO1xuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9ub3BlblJlc29sdmUoe30pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhcGlDbGllbnQgPSB0aGlzLmFwaUNsaWVudDtcbiAgICAgICAgY29uc3Qgd2Vic29ja2V0Q2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgb25vcGVuOiBvbm9wZW5Bd2FpdGVkQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbm1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZvaWQgaGFuZGxlV2ViU29ja2V0TWVzc2FnZSQxKGFwaUNsaWVudCwgY2FsbGJhY2tzLm9ubWVzc2FnZSwgZXZlbnQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uZXJyb3I6IChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmVycm9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uY2xvc2U6IChfYiA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbmNsb3NlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29ubiA9IHRoaXMud2ViU29ja2V0RmFjdG9yeS5jcmVhdGUodXJsLCBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgY29uc3QgbW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGNvbnN0IHNldHVwID0gbGl2ZU11c2ljQ2xpZW50U2V0dXBUb01sZGV2KHtcbiAgICAgICAgICAgIG1vZGVsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IGxpdmVNdXNpY0NsaWVudE1lc3NhZ2VUb01sZGV2KHsgc2V0dXAgfSk7XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgTGl2ZU11c2ljU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBMaXZlTXVzaWNTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAgU2V0cyBpbnB1dHMgdG8gc3RlZXIgbXVzaWMgZ2VuZXJhdGlvbi4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIHdlaWdodGVkIHByb21wdHMuXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIG9uZSBwcm9wZXJ0eSwgYHdlaWdodGVkUHJvbXB0c2AuXG4gIFxuICAgICAgICAtIGB3ZWlnaHRlZFByb21wdHNgIHRvIHNlbmQgdG8gdGhlIG1vZGVsOyB3ZWlnaHRzIGFyZSBub3JtYWxpemVkIHRvXG4gICAgICAgICAgc3VtIHRvIDEuMC5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgYXN5bmMgc2V0V2VpZ2h0ZWRQcm9tcHRzKHBhcmFtcykge1xuICAgICAgICBpZiAoIXBhcmFtcy53ZWlnaHRlZFByb21wdHMgfHxcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHBhcmFtcy53ZWlnaHRlZFByb21wdHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWlnaHRlZCBwcm9tcHRzIG11c3QgYmUgc2V0IGFuZCBjb250YWluIGF0IGxlYXN0IG9uZSBlbnRyeS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXRXZWlnaHRlZFByb21wdHNQYXJhbWV0ZXJzID0gbGl2ZU11c2ljU2V0V2VpZ2h0ZWRQcm9tcHRzUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgY29uc3QgY2xpZW50Q29udGVudCA9IGxpdmVNdXNpY0NsaWVudENvbnRlbnRUb01sZGV2KHNldFdlaWdodGVkUHJvbXB0c1BhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeSh7IGNsaWVudENvbnRlbnQgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNldHMgYSBjb25maWd1cmF0aW9uIHRvIHRoZSBtb2RlbC4gVXBkYXRlcyB0aGUgc2Vzc2lvbidzIGN1cnJlbnRcbiAgICAgIG11c2ljIGdlbmVyYXRpb24gY29uZmlnLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtdXNpY0dlbmVyYXRpb25Db25maWdgLlxuICBcbiAgICAgICAgLSBgbXVzaWNHZW5lcmF0aW9uQ29uZmlnYCB0byBzZXQgaW4gdGhlIG1vZGVsLiBQYXNzaW5nIGFuIGVtcHR5IG9yXG4gICAgICB1bmRlZmluZWQgY29uZmlnIHRvIHRoZSBtb2RlbCB3aWxsIHJlc2V0IHRoZSBjb25maWcgdG8gZGVmYXVsdHMuXG4gIFxuICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGFzeW5jIHNldE11c2ljR2VuZXJhdGlvbkNvbmZpZyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICBwYXJhbXMubXVzaWNHZW5lcmF0aW9uQ29uZmlnID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2V0Q29uZmlnUGFyYW1ldGVycyA9IGxpdmVNdXNpY1NldENvbmZpZ1BhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSBsaXZlTXVzaWNDbGllbnRNZXNzYWdlVG9NbGRldihzZXRDb25maWdQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZW5kUGxheWJhY2tDb250cm9sKHBsYXliYWNrQ29udHJvbCkge1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gbGl2ZU11c2ljQ2xpZW50TWVzc2FnZVRvTWxkZXYoe1xuICAgICAgICAgICAgcGxheWJhY2tDb250cm9sLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkoY2xpZW50TWVzc2FnZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0aGUgbXVzaWMgc3RyZWFtLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBsYXkoKSB7XG4gICAgICAgIHRoaXMuc2VuZFBsYXliYWNrQ29udHJvbChMaXZlTXVzaWNQbGF5YmFja0NvbnRyb2wuUExBWSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRlbXBvcmFyaWx5IGhhbHQgdGhlIG11c2ljIHN0cmVhbS4gVXNlIGBwbGF5YCB0byByZXN1bWUgZnJvbSB0aGUgY3VycmVudFxuICAgICAqIHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlBBVVNFKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RvcCB0aGUgbXVzaWMgc3RyZWFtIGFuZCByZXNldCB0aGUgc3RhdGUuIFJldGFpbnMgdGhlIGN1cnJlbnQgcHJvbXB0c1xuICAgICAqIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5zZW5kUGxheWJhY2tDb250cm9sKExpdmVNdXNpY1BsYXliYWNrQ29udHJvbC5TVE9QKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBjb250ZXh0IG9mIHRoZSBtdXNpYyBnZW5lcmF0aW9uIHdpdGhvdXQgc3RvcHBpbmcgaXQuXG4gICAgICogUmV0YWlucyB0aGUgY3VycmVudCBwcm9tcHRzIGFuZCBjb25maWcuXG4gICAgICpcbiAgICAgKiBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgcmVzZXRDb250ZXh0KCkge1xuICAgICAgICB0aGlzLnNlbmRQbGF5YmFja0NvbnRyb2woTGl2ZU11c2ljUGxheWJhY2tDb250cm9sLlJFU0VUX0NPTlRFWFQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgICBUZXJtaW5hdGVzIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAkMShoZWFkZXJzKSB7XG4gICAgY29uc3QgaGVhZGVyTWFwID0ge307XG4gICAgaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgIGhlYWRlck1hcFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlYWRlck1hcDtcbn1cbi8vIENvbnZlcnRzIGEgXCJtYXBcIiBvYmplY3QgdG8gYSBoZWFkZXJzIG9iamVjdC4gV2UgdXNlIHRoaXMgYXMgdGhlIEF1dGhcbi8vIGludGVyZmFjZSB3b3JrcyB3aXRoIEhlYWRlcnMgb2JqZWN0cyB3aGlsZSB0aGUgQVBJIGNsaWVudCBkZWZhdWx0IGhlYWRlcnNcbi8vIHJldHVybnMgYSBtYXAuXG5mdW5jdGlvbiBtYXBUb0hlYWRlcnMkMShtYXApIHtcbiAgICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtYXApKSB7XG4gICAgICAgIGhlYWRlcnMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gaGVhZGVycztcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQgPSAnRnVuY3Rpb25SZXNwb25zZSByZXF1ZXN0IG11c3QgaGF2ZSBhbiBgaWRgIGZpZWxkIGZyb20gdGhlIHJlc3BvbnNlIG9mIGEgVG9vbENhbGwuRnVuY3Rpb25hbENhbGxzIGluIEdvb2dsZSBBSS4nO1xuLyoqXG4gKiBIYW5kbGVzIGluY29taW5nIG1lc3NhZ2VzIGZyb20gdGhlIFdlYlNvY2tldC5cbiAqXG4gKiBAcmVtYXJrc1xuICogVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcGFyc2luZyBpbmNvbWluZyBtZXNzYWdlcywgdHJhbnNmb3JtaW5nIHRoZW1cbiAqIGludG8gTGl2ZVNlcnZlck1lc3NhZ2VzLCBhbmQgdGhlbiBjYWxsaW5nIHRoZSBvbm1lc3NhZ2UgY2FsbGJhY2suIE5vdGUgdGhhdFxuICogdGhlIGZpcnN0IG1lc3NhZ2Ugd2hpY2ggaXMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIGlzIGEgc2V0dXBDb21wbGV0ZVxuICogbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gYXBpQ2xpZW50IFRoZSBBcGlDbGllbnQgaW5zdGFuY2UuXG4gKiBAcGFyYW0gb25tZXNzYWdlIFRoZSB1c2VyLXByb3ZpZGVkIG9ubWVzc2FnZSBjYWxsYmFjayAoaWYgYW55KS5cbiAqIEBwYXJhbSBldmVudCBUaGUgTWVzc2FnZUV2ZW50IGZyb20gdGhlIFdlYlNvY2tldC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaGFuZGxlV2ViU29ja2V0TWVzc2FnZShhcGlDbGllbnQsIG9ubWVzc2FnZSwgZXZlbnQpIHtcbiAgICBjb25zdCBzZXJ2ZXJNZXNzYWdlID0gbmV3IExpdmVTZXJ2ZXJNZXNzYWdlKCk7XG4gICAgbGV0IGpzb25EYXRhO1xuICAgIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBqc29uRGF0YSA9IGF3YWl0IGV2ZW50LmRhdGEudGV4dCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAganNvbkRhdGEgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoZXZlbnQuZGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uRGF0YSA9IGV2ZW50LmRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGpzb25EYXRhKTtcbiAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICBjb25zdCByZXNwID0gbGl2ZVNlcnZlck1lc3NhZ2VGcm9tVmVydGV4KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGxpdmVTZXJ2ZXJNZXNzYWdlRnJvbU1sZGV2KGRhdGEpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHNlcnZlck1lc3NhZ2UsIHJlc3ApO1xuICAgIH1cbiAgICBvbm1lc3NhZ2Uoc2VydmVyTWVzc2FnZSk7XG59XG4vKipcbiAgIExpdmUgY2xhc3MgZW5jYXBzdWxhdGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBsaXZlIGludGVyYWN0aW9uIHdpdGggdGhlXG4gICBHZW5lcmF0aXZlIExhbmd1YWdlIEFQSS4gSXQgZW1iZWRzIEFwaUNsaWVudCBmb3IgZ2VuZXJhbCBBUEkgc2V0dGluZ3MuXG5cbiAgIEBleHBlcmltZW50YWxcbiAgKi9cbmNsYXNzIExpdmUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCwgYXV0aCwgd2ViU29ja2V0RmFjdG9yeSkge1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgdGhpcy5hdXRoID0gYXV0aDtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5tdXNpYyA9IG5ldyBMaXZlTXVzaWModGhpcy5hcGlDbGllbnQsIHRoaXMuYXV0aCwgdGhpcy53ZWJTb2NrZXRGYWN0b3J5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIHRoZSBzcGVjaWZpZWQgbW9kZWwgd2l0aCB0aGUgZ2l2ZW5cbiAgICAgICBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgU2Vzc2lvbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoYXQgY29ubmVjdGlvbi5cbiAgXG4gICAgICAgQGV4cGVyaW1lbnRhbCBCdWlsdC1pbiBNQ1Agc3VwcG9ydCBpcyBhbiBleHBlcmltZW50YWwgZmVhdHVyZSwgbWF5IGNoYW5nZSBpblxuICAgICAgIGZ1dHVyZSB2ZXJzaW9ucy5cbiAgXG4gICAgICAgQHJlbWFya3NcbiAgXG4gICAgICAgQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlc3RhYmxpc2hpbmcgYSBjb25uZWN0aW9uIHRvIHRoZSBtb2RlbC5cbiAgICAgICBAcmV0dXJuIEEgbGl2ZSBzZXNzaW9uLlxuICBcbiAgICAgICBAZXhhbXBsZVxuICAgICAgIGBgYHRzXG4gICAgICAgbGV0IG1vZGVsOiBzdHJpbmc7XG4gICAgICAgaWYgKEdPT0dMRV9HRU5BSV9VU0VfVkVSVEVYQUkpIHtcbiAgICAgICAgIG1vZGVsID0gJ2dlbWluaS0yLjAtZmxhc2gtbGl2ZS1wcmV2aWV3LTA0LTA5JztcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLWxpdmUtMi41LWZsYXNoLXByZXZpZXcnO1xuICAgICAgIH1cbiAgICAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgYWkubGl2ZS5jb25uZWN0KHtcbiAgICAgICAgIG1vZGVsOiBtb2RlbCxcbiAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICByZXNwb25zZU1vZGFsaXRpZXM6IFtNb2RhbGl0eS5BVURJT10sXG4gICAgICAgICB9LFxuICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgIG9ub3BlbjogKCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25uZWN0ZWQgdG8gdGhlIHNvY2tldC4nKTtcbiAgICAgICAgICAgfSxcbiAgICAgICAgICAgb25tZXNzYWdlOiAoZTogTWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIG1lc3NhZ2UgZnJvbSB0aGUgc2VydmVyOiAlc1xcbicsIGRlYnVnKGUuZGF0YSkpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgICBvbmVycm9yOiAoZTogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdFcnJvciBvY2N1cnJlZDogJXNcXG4nLCBkZWJ1ZyhlLmVycm9yKSk7XG4gICAgICAgICAgIH0sXG4gICAgICAgICAgIG9uY2xvc2U6IChlOiBDbG9zZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgY29uc29sZS5sb2coJ0Nvbm5lY3Rpb24gY2xvc2VkLicpO1xuICAgICAgICAgICB9LFxuICAgICAgICAgfSxcbiAgICAgICB9KTtcbiAgICAgICBgYGBcbiAgICAgICovXG4gICAgYXN5bmMgY29ubmVjdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIC8vIFRPRE86IGIvNDA0OTQ2NzQ2IC0gU3VwcG9ydCBwZXIgcmVxdWVzdCBIVFRQIG9wdGlvbnMuXG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIExpdmUgbW9kdWxlIGRvZXMgbm90IHN1cHBvcnQgaHR0cE9wdGlvbnMgYXQgcmVxdWVzdC1sZXZlbCBpbicgK1xuICAgICAgICAgICAgICAgICcgTGl2ZUNvbm5lY3RDb25maWcgeWV0LiBQbGVhc2UgdXNlIHRoZSBjbGllbnQtbGV2ZWwgaHR0cE9wdGlvbnMnICtcbiAgICAgICAgICAgICAgICAnIGNvbmZpZ3VyYXRpb24gaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3ZWJzb2NrZXRCYXNlVXJsID0gdGhpcy5hcGlDbGllbnQuZ2V0V2Vic29ja2V0QmFzZVVybCgpO1xuICAgICAgICBjb25zdCBhcGlWZXJzaW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpVmVyc2lvbigpO1xuICAgICAgICBsZXQgdXJsO1xuICAgICAgICBjb25zdCBjbGllbnRIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0SGVhZGVycygpO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBzZXRNY3BVc2FnZUhlYWRlcihjbGllbnRIZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZWFkZXJzID0gbWFwVG9IZWFkZXJzKGNsaWVudEhlYWRlcnMpO1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuY2xvdWQuYWlwbGF0Zm9ybS4ke2FwaVZlcnNpb259LkxsbUJpZGlTZXJ2aWNlL0JpZGlHZW5lcmF0ZUNvbnRlbnRgO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hdXRoLmFkZEF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYXBpS2V5ID0gdGhpcy5hcGlDbGllbnQuZ2V0QXBpS2V5KCk7XG4gICAgICAgICAgICBsZXQgbWV0aG9kID0gJ0JpZGlHZW5lcmF0ZUNvbnRlbnQnO1xuICAgICAgICAgICAgbGV0IGtleU5hbWUgPSAna2V5JztcbiAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IG51bGwgfHwgYXBpS2V5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IEVwaGVtZXJhbCB0b2tlbiBzdXBwb3J0IGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGFwaVZlcnNpb24gIT09ICd2MWFscGhhJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBUaGUgU0RLJ3MgZXBoZW1lcmFsIHRva2VuIHN1cHBvcnQgaXMgaW4gdjFhbHBoYSBvbmx5LiBQbGVhc2UgdXNlIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHthcGlLZXk6IHRva2VuLm5hbWUsIGh0dHBPcHRpb25zOiB7IGFwaVZlcnNpb246ICd2MWFscGhhJyB9fSk7IGJlZm9yZSBzZXNzaW9uIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtZXRob2QgPSAnQmlkaUdlbmVyYXRlQ29udGVudENvbnN0cmFpbmVkJztcbiAgICAgICAgICAgICAgICBrZXlOYW1lID0gJ2FjY2Vzc190b2tlbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwgPSBgJHt3ZWJzb2NrZXRCYXNlVXJsfS93cy9nb29nbGUuYWkuZ2VuZXJhdGl2ZWxhbmd1YWdlLiR7YXBpVmVyc2lvbn0uR2VuZXJhdGl2ZVNlcnZpY2UuJHttZXRob2R9PyR7a2V5TmFtZX09JHthcGlLZXl9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb25vcGVuUmVzb2x2ZSA9ICgpID0+IHsgfTtcbiAgICAgICAgY29uc3Qgb25vcGVuUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBhcmFtcy5jYWxsYmFja3M7XG4gICAgICAgIGNvbnN0IG9ub3BlbkF3YWl0ZWRDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IGNhbGxiYWNrcyA9PT0gbnVsbCB8fCBjYWxsYmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vbm9wZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcyk7XG4gICAgICAgICAgICBvbm9wZW5SZXNvbHZlKHt9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIG9ub3Blbjogb25vcGVuQXdhaXRlZENhbGxiYWNrLFxuICAgICAgICAgICAgb25tZXNzYWdlOiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB2b2lkIGhhbmRsZVdlYlNvY2tldE1lc3NhZ2UoYXBpQ2xpZW50LCBjYWxsYmFja3Mub25tZXNzYWdlLCBldmVudCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25lcnJvcjogKF9hID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25jbG9zZTogKF9iID0gY2FsbGJhY2tzID09PSBudWxsIHx8IGNhbGxiYWNrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uY2xvc2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb25uID0gdGhpcy53ZWJTb2NrZXRGYWN0b3J5LmNyZWF0ZSh1cmwsIGhlYWRlcnNUb01hcChoZWFkZXJzKSwgd2Vic29ja2V0Q2FsbGJhY2tzKTtcbiAgICAgICAgY29ubi5jb25uZWN0KCk7XG4gICAgICAgIC8vIFdhaXQgZm9yIHRoZSB3ZWJzb2NrZXQgdG8gb3BlbiBiZWZvcmUgc2VuZGluZyByZXF1ZXN0cy5cbiAgICAgICAgYXdhaXQgb25vcGVuUHJvbWlzZTtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTW9kZWwgPSB0TW9kZWwodGhpcy5hcGlDbGllbnQsIHBhcmFtcy5tb2RlbCk7XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkgJiZcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwuc3RhcnRzV2l0aCgncHVibGlzaGVycy8nKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvamVjdCA9IHRoaXMuYXBpQ2xpZW50LmdldFByb2plY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5hcGlDbGllbnQuZ2V0TG9jYXRpb24oKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTW9kZWwgPVxuICAgICAgICAgICAgICAgIGBwcm9qZWN0cy8ke3Byb2plY3R9L2xvY2F0aW9ucy8ke2xvY2F0aW9ufS9gICsgdHJhbnNmb3JtZWRNb2RlbDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpICYmXG4gICAgICAgICAgICAoKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnJlc3BvbnNlTW9kYWxpdGllcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gU2V0IGRlZmF1bHQgdG8gQVVESU8gdG8gYWxpZ24gd2l0aCBNTERldiBBUEkuXG4gICAgICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbmZpZyA9IHsgcmVzcG9uc2VNb2RhbGl0aWVzOiBbTW9kYWxpdHkuQVVESU9dIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlTW9kYWxpdGllcyA9IFtNb2RhbGl0eS5BVURJT107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5nZW5lcmF0aW9uQ29uZmlnKSB7XG4gICAgICAgICAgICAvLyBSYWlzZSBkZXByZWNhdGlvbiB3YXJuaW5nIGZvciBnZW5lcmF0aW9uQ29uZmlnLlxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdTZXR0aW5nIGBMaXZlQ29ubmVjdENvbmZpZy5nZW5lcmF0aW9uX2NvbmZpZ2AgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHNldCB0aGUgZmllbGRzIG9uIGBMaXZlQ29ubmVjdENvbmZpZ2AgZGlyZWN0bHkuIFRoaXMgd2lsbCBiZWNvbWUgYW4gZXJyb3IgaW4gYSBmdXR1cmUgdmVyc2lvbiAobm90IGJlZm9yZSBRMyAyMDI1KS4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dFRvb2xzID0gKF9mID0gKF9lID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnRvb2xzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBbXTtcbiAgICAgICAgY29uc3QgY29udmVydGVkVG9vbHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIGlucHV0VG9vbHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGFibGVUb29sID0gdG9vbDtcbiAgICAgICAgICAgICAgICBjb252ZXJ0ZWRUb29scy5wdXNoKGF3YWl0IGNhbGxhYmxlVG9vbC50b29sKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udmVydGVkVG9vbHMucHVzaCh0b29sKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udmVydGVkVG9vbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyA9IGNvbnZlcnRlZFRvb2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpdmVDb25uZWN0UGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIG1vZGVsOiB0cmFuc2Zvcm1lZE1vZGVsLFxuICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgY2FsbGJhY2tzOiBwYXJhbXMuY2FsbGJhY2tzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIGxpdmVDb25uZWN0UGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0gbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgbGl2ZUNvbm5lY3RQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2xpZW50TWVzc2FnZVsnY29uZmlnJ107XG4gICAgICAgIGNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgICAgIHJldHVybiBuZXcgU2Vzc2lvbihjb25uLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxuICAgIC8vIFRPRE86IGIvNDE2MDQxMjI5IC0gQWJzdHJhY3QgdGhpcyBtZXRob2QgdG8gYSBjb21tb24gcGxhY2UuXG4gICAgaXNDYWxsYWJsZVRvb2wodG9vbCkge1xuICAgICAgICByZXR1cm4gJ2NhbGxUb29sJyBpbiB0b29sICYmIHR5cGVvZiB0b29sLmNhbGxUb29sID09PSAnZnVuY3Rpb24nO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRMaXZlU2VuZENsaWVudENvbnRlbnRQYXJhbWVydGVycyA9IHtcbiAgICB0dXJuQ29tcGxldGU6IHRydWUsXG59O1xuLyoqXG4gICBSZXByZXNlbnRzIGEgY29ubmVjdGlvbiB0byB0aGUgQVBJLlxuXG4gICBAZXhwZXJpbWVudGFsXG4gICovXG5jbGFzcyBTZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25uLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIHRMaXZlQ2xpZW50Q29udGVudChhcGlDbGllbnQsIHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLnR1cm5zICE9PSBudWxsICYmIHBhcmFtcy50dXJucyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudHMgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29udGVudHMgPSB0Q29udGVudHMocGFyYW1zLnR1cm5zKTtcbiAgICAgICAgICAgICAgICBpZiAoYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyA9IGNvbnRlbnRzLm1hcCgoaXRlbSkgPT4gY29udGVudFRvVmVydGV4KGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzID0gY29udGVudHMubWFwKChpdGVtKSA9PiBjb250ZW50VG9NbGRldiQxKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBjbGllbnQgY29udGVudCBcInR1cm5zXCIsIHR5cGU6ICcke3R5cGVvZiBwYXJhbXMudHVybnN9J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjbGllbnRDb250ZW50OiB7IHR1cm5zOiBjb250ZW50cywgdHVybkNvbXBsZXRlOiBwYXJhbXMudHVybkNvbXBsZXRlIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRDb250ZW50OiB7IHR1cm5Db21wbGV0ZTogcGFyYW1zLnR1cm5Db21wbGV0ZSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0TGl2ZUNsaWVudHRUb29sUmVzcG9uc2UoYXBpQ2xpZW50LCBwYXJhbXMpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2VzID0gW107XG4gICAgICAgIGlmIChwYXJhbXMuZnVuY3Rpb25SZXNwb25zZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmdW5jdGlvblJlc3BvbnNlcyBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzKSkge1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZXMgPSBbcGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzID0gcGFyYW1zLmZ1bmN0aW9uUmVzcG9uc2VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmdW5jdGlvblJlc3BvbnNlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb25SZXNwb25zZXMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmdW5jdGlvblJlc3BvbnNlIG9mIGZ1bmN0aW9uUmVzcG9uc2VzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2UgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICEoJ25hbWUnIGluIGZ1bmN0aW9uUmVzcG9uc2UpIHx8XG4gICAgICAgICAgICAgICAgISgncmVzcG9uc2UnIGluIGZ1bmN0aW9uUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgcGFyc2UgZnVuY3Rpb24gcmVzcG9uc2UsIHR5cGUgJyR7dHlwZW9mIGZ1bmN0aW9uUmVzcG9uc2V9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYXBpQ2xpZW50LmlzVmVydGV4QUkoKSAmJiAhKCdpZCcgaW4gZnVuY3Rpb25SZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoRlVOQ1RJT05fUkVTUE9OU0VfUkVRVUlSRVNfSUQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsaWVudE1lc3NhZ2UgPSB7XG4gICAgICAgICAgICB0b29sUmVzcG9uc2U6IHsgZnVuY3Rpb25SZXNwb25zZXM6IGZ1bmN0aW9uUmVzcG9uc2VzIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGllbnRNZXNzYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgIFNlbmQgYSBtZXNzYWdlIG92ZXIgdGhlIGVzdGFibGlzaGVkIGNvbm5lY3Rpb24uXG4gIFxuICAgICAgQHBhcmFtIHBhcmFtcyAtIENvbnRhaW5zIHR3byAqKm9wdGlvbmFsKiogcHJvcGVydGllcywgYHR1cm5zYCBhbmRcbiAgICAgICAgICBgdHVybkNvbXBsZXRlYC5cbiAgXG4gICAgICAgIC0gYHR1cm5zYCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGBDb250ZW50W11gXG4gICAgICAgIC0gYHR1cm5Db21wbGV0ZTogdHJ1ZWAgW2RlZmF1bHRdIGluZGljYXRlcyB0aGF0IHlvdSBhcmUgZG9uZSBzZW5kaW5nXG4gICAgICAgICAgY29udGVudCBhbmQgZXhwZWN0IGEgcmVzcG9uc2UuIElmIGB0dXJuQ29tcGxldGU6IGZhbHNlYCwgdGhlIHNlcnZlclxuICAgICAgICAgIHdpbGwgd2FpdCBmb3IgYWRkaXRpb25hbCBtZXNzYWdlcyBiZWZvcmUgc3RhcnRpbmcgZ2VuZXJhdGlvbi5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFRoZXJlIGFyZSB0d28gd2F5cyB0byBzZW5kIG1lc3NhZ2VzIHRvIHRoZSBsaXZlIEFQSTpcbiAgICAgIGBzZW5kQ2xpZW50Q29udGVudGAgYW5kIGBzZW5kUmVhbHRpbWVJbnB1dGAuXG4gIFxuICAgICAgYHNlbmRDbGllbnRDb250ZW50YCBtZXNzYWdlcyBhcmUgYWRkZWQgdG8gdGhlIG1vZGVsIGNvbnRleHQgKippbiBvcmRlcioqLlxuICAgICAgSGF2aW5nIGEgY29udmVyc2F0aW9uIHVzaW5nIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgaXMgcm91Z2hseVxuICAgICAgZXF1aXZhbGVudCB0byB1c2luZyB0aGUgYENoYXQuc2VuZE1lc3NhZ2VTdHJlYW1gLCBleGNlcHQgdGhhdCB0aGUgc3RhdGUgb2ZcbiAgICAgIHRoZSBgY2hhdGAgaGlzdG9yeSBpcyBzdG9yZWQgb24gdGhlIEFQSSBzZXJ2ZXIgaW5zdGVhZCBvZiBsb2NhbGx5LlxuICBcbiAgICAgIEJlY2F1c2Ugb2YgYHNlbmRDbGllbnRDb250ZW50YCdzIG9yZGVyIGd1YXJhbnRlZSwgdGhlIG1vZGVsIGNhbm5vdCByZXNwb25zXG4gICAgICBhcyBxdWlja2x5IHRvIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZXMgYXMgdG8gYHNlbmRSZWFsdGltZUlucHV0YFxuICAgICAgbWVzc2FnZXMuIFRoaXMgbWFrZXMgdGhlIGJpZ2dlc3QgZGlmZmVyZW5jZSB3aGVuIHNlbmRpbmcgb2JqZWN0cyB0aGF0IGhhdmVcbiAgICAgIHNpZ25pZmljYW50IHByZXByb2Nlc3NpbmcgdGltZSAodHlwaWNhbGx5IGltYWdlcykuXG4gIFxuICAgICAgVGhlIGBzZW5kQ2xpZW50Q29udGVudGAgbWVzc2FnZSBzZW5kcyBhIGBDb250ZW50W11gXG4gICAgICB3aGljaCBoYXMgbW9yZSBvcHRpb25zIHRoYW4gdGhlIGBCbG9iYCBzZW50IGJ5IGBzZW5kUmVhbHRpbWVJbnB1dGAuXG4gIFxuICAgICAgU28gdGhlIG1haW4gdXNlLWNhc2VzIGZvciBgc2VuZENsaWVudENvbnRlbnRgIG92ZXIgYHNlbmRSZWFsdGltZUlucHV0YCBhcmU6XG4gIFxuICAgICAgLSBTZW5kaW5nIGFueXRoaW5nIHRoYXQgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgYXMgYSBgQmxvYmAgKHRleHQsXG4gICAgICBgc2VuZENsaWVudENvbnRlbnQoe3R1cm5zPVwiSGVsbG8/XCJ9YCkpLlxuICAgICAgLSBNYW5hZ2luZyB0dXJucyB3aGVuIG5vdCB1c2luZyBhdWRpbyBpbnB1dCBhbmQgdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uLlxuICAgICAgICAoYHNlbmRDbGllbnRDb250ZW50KHt0dXJuQ29tcGxldGU6dHJ1ZX0pYCBvciB0aGUgc2hvcnQgZm9ybVxuICAgICAgYHNlbmRDbGllbnRDb250ZW50KClgKVxuICAgICAgLSBQcmVmaWxsaW5nIGEgY29udmVyc2F0aW9uIGNvbnRleHRcbiAgICAgICAgYGBgXG4gICAgICAgIHNlbmRDbGllbnRDb250ZW50KHtcbiAgICAgICAgICAgIHR1cm5zOiBbXG4gICAgICAgICAgICAgIENvbnRlbnQoe3JvbGU6dXNlciwgcGFydHM6Li4ufSksXG4gICAgICAgICAgICAgIENvbnRlbnQoe3JvbGU6dXNlciwgcGFydHM6Li4ufSksXG4gICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgXVxuICAgICAgICB9KVxuICAgICAgICBgYGBcbiAgICAgIEBleHBlcmltZW50YWxcbiAgICAgKi9cbiAgICBzZW5kQ2xpZW50Q29udGVudChwYXJhbXMpIHtcbiAgICAgICAgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TGl2ZVNlbmRDbGllbnRDb250ZW50UGFyYW1lcnRlcnMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBjbGllbnRNZXNzYWdlID0gdGhpcy50TGl2ZUNsaWVudENvbnRlbnQodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgcmVhbHRpbWUgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBvbmUgcHJvcGVydHksIGBtZWRpYWAuXG4gIFxuICAgICAgICAtIGBtZWRpYWAgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYSBgQmxvYmBcbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFVzZSBgc2VuZFJlYWx0aW1lSW5wdXRgIGZvciByZWFsdGltZSBhdWRpbyBjaHVua3MgYW5kIHZpZGVvIGZyYW1lcyAoaW1hZ2VzKS5cbiAgXG4gICAgICBXaXRoIGBzZW5kUmVhbHRpbWVJbnB1dGAgdGhlIGFwaSB3aWxsIHJlc3BvbmQgdG8gYXVkaW8gYXV0b21hdGljYWxseVxuICAgICAgYmFzZWQgb24gdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uIChWQUQpLlxuICBcbiAgICAgIGBzZW5kUmVhbHRpbWVJbnB1dGAgaXMgb3B0aW1pemVkIGZvciByZXNwb25zaXZuZXNzIGF0IHRoZSBleHBlbnNlIG9mXG4gICAgICBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIGd1YXJhbnRlZXMuIEF1ZGlvIGFuZCB2aWRlbyB0b2tlbnMgYXJlIHRvIHRoZVxuICAgICAgY29udGV4dCB3aGVuIHRoZXkgYmVjb21lIGF2YWlsYWJsZS5cbiAgXG4gICAgICBOb3RlOiBUaGUgQ2FsbCBzaWduYXR1cmUgZXhwZWN0cyBhIGBCbG9iYCBvYmplY3QsIGJ1dCBvbmx5IGEgc3Vic2V0XG4gICAgICBvZiBhdWRpbyBhbmQgaW1hZ2UgbWltZXR5cGVzIGFyZSBhbGxvd2VkLlxuICAgICAqL1xuICAgIHNlbmRSZWFsdGltZUlucHV0KHBhcmFtcykge1xuICAgICAgICBsZXQgY2xpZW50TWVzc2FnZSA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjbGllbnRNZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgICdyZWFsdGltZUlucHV0JzogbGl2ZVNlbmRSZWFsdGltZUlucHV0UGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50TWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAncmVhbHRpbWVJbnB1dCc6IGxpdmVTZW5kUmVhbHRpbWVJbnB1dFBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5zZW5kKEpTT04uc3RyaW5naWZ5KGNsaWVudE1lc3NhZ2UpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICBTZW5kIGEgZnVuY3Rpb24gcmVzcG9uc2UgbWVzc2FnZSBvdmVyIHRoZSBlc3RhYmxpc2hlZCBjb25uZWN0aW9uLlxuICBcbiAgICAgIEBwYXJhbSBwYXJhbXMgLSBDb250YWlucyBwcm9wZXJ0eSBgZnVuY3Rpb25SZXNwb25zZXNgLlxuICBcbiAgICAgICAgLSBgZnVuY3Rpb25SZXNwb25zZXNgIHdpbGwgYmUgY29udmVydGVkIHRvIGEgYGZ1bmN0aW9uUmVzcG9uc2VzW11gXG4gIFxuICAgICAgQHJlbWFya3NcbiAgICAgIFVzZSBgc2VuZEZ1bmN0aW9uUmVzcG9uc2VgIHRvIHJlcGx5IHRvIGBMaXZlU2VydmVyVG9vbENhbGxgIGZyb20gdGhlIHNlcnZlci5cbiAgXG4gICAgICBVc2Uge0BsaW5rIHR5cGVzLkxpdmVDb25uZWN0Q29uZmlnI3Rvb2xzfSB0byBjb25maWd1cmUgdGhlIGNhbGxhYmxlIGZ1bmN0aW9ucy5cbiAgXG4gICAgICBAZXhwZXJpbWVudGFsXG4gICAgICovXG4gICAgc2VuZFRvb2xSZXNwb25zZShwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5mdW5jdGlvblJlc3BvbnNlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rvb2wgcmVzcG9uc2UgcGFyYW1ldGVycyBhcmUgcmVxdWlyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpZW50TWVzc2FnZSA9IHRoaXMudExpdmVDbGllbnR0VG9vbFJlc3BvbnNlKHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICB0aGlzLmNvbm4uc2VuZChKU09OLnN0cmluZ2lmeShjbGllbnRNZXNzYWdlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAgIFRlcm1pbmF0ZXMgdGhlIFdlYlNvY2tldCBjb25uZWN0aW9uLlxuICBcbiAgICAgICBAZXhwZXJpbWVudGFsXG4gIFxuICAgICAgIEBleGFtcGxlXG4gICAgICAgYGBgdHNcbiAgICAgICBsZXQgbW9kZWw6IHN0cmluZztcbiAgICAgICBpZiAoR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSSkge1xuICAgICAgICAgbW9kZWwgPSAnZ2VtaW5pLTIuMC1mbGFzaC1saXZlLXByZXZpZXctMDQtMDknO1xuICAgICAgIH0gZWxzZSB7XG4gICAgICAgICBtb2RlbCA9ICdnZW1pbmktbGl2ZS0yLjUtZmxhc2gtcHJldmlldyc7XG4gICAgICAgfVxuICAgICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBhaS5saXZlLmNvbm5lY3Qoe1xuICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgY29uZmlnOiB7XG4gICAgICAgICAgIHJlc3BvbnNlTW9kYWxpdGllczogW01vZGFsaXR5LkFVRElPXSxcbiAgICAgICAgIH1cbiAgICAgICB9KTtcbiAgXG4gICAgICAgc2Vzc2lvbi5jbG9zZSgpO1xuICAgICAgIGBgYFxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmNvbm4uY2xvc2UoKTtcbiAgICB9XG59XG4vLyBDb252ZXJ0cyBhbiBoZWFkZXJzIG9iamVjdCB0byBhIFwibWFwXCIgb2JqZWN0IGFzIGV4cGVjdGVkIGJ5IHRoZSBXZWJTb2NrZXRcbi8vIGNvbnN0cnVjdG9yLiBXZSB1c2UgdGhpcyBhcyB0aGUgQXV0aCBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHNcbi8vIHdoaWxlIHRoZSBXZWJTb2NrZXQgY29uc3RydWN0b3IgdGFrZXMgYSBtYXAuXG5mdW5jdGlvbiBoZWFkZXJzVG9NYXAoaGVhZGVycykge1xuICAgIGNvbnN0IGhlYWRlck1hcCA9IHt9O1xuICAgIGhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICBoZWFkZXJNYXBba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJNYXA7XG59XG4vLyBDb252ZXJ0cyBhIFwibWFwXCIgb2JqZWN0IHRvIGEgaGVhZGVycyBvYmplY3QuIFdlIHVzZSB0aGlzIGFzIHRoZSBBdXRoXG4vLyBpbnRlcmZhY2Ugd29ya3Mgd2l0aCBIZWFkZXJzIG9iamVjdHMgd2hpbGUgdGhlIEFQSSBjbGllbnQgZGVmYXVsdCBoZWFkZXJzXG4vLyByZXR1cm5zIGEgbWFwLlxuZnVuY3Rpb24gbWFwVG9IZWFkZXJzKG1hcCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1hcCkpIHtcbiAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBERUZBVUxUX01BWF9SRU1PVEVfQ0FMTFMgPSAxMDtcbi8qKiBSZXR1cm5zIHdoZXRoZXIgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgaXMgZGlzYWJsZWQuICovXG5mdW5jdGlvbiBzaG91bGREaXNhYmxlQWZjKGNvbmZpZykge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGlmICgoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzYWJsZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IGNhbGxhYmxlVG9vbHNQcmVzZW50ID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCB0b29sIG9mIChfYiA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy50b29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICBjYWxsYWJsZVRvb2xzUHJlc2VudCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNhbGxhYmxlVG9vbHNQcmVzZW50KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBtYXhDYWxscyA9IChfYyA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXhpbXVtUmVtb3RlQ2FsbHM7XG4gICAgaWYgKChtYXhDYWxscyAmJiAobWF4Q2FsbHMgPCAwIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKG1heENhbGxzKSkpIHx8XG4gICAgICAgIG1heENhbGxzID09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIG1heGltdW1SZW1vdGVDYWxscyB2YWx1ZSBwcm92aWRlZCBmb3IgYXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcuIERpc2FibGVkIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nLiBQbGVhc2UgcHJvdmlkZSBhIHZhbGlkIGludGVnZXIgdmFsdWUgZ3JlYXRlciB0aGFuIDAuIG1heGltdW1SZW1vdGVDYWxscyBwcm92aWRlZDonLCBtYXhDYWxscyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0NhbGxhYmxlVG9vbCh0b29sKSB7XG4gICAgcmV0dXJuICdjYWxsVG9vbCcgaW4gdG9vbCAmJiB0eXBlb2YgdG9vbC5jYWxsVG9vbCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IG9mIHRvb2xzIGNvbnRhaW5zIGFueSBDYWxsYWJsZVRvb2xzLiBXaWxsIHJldHVybiB0cnVlXG4vLyBpZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgQ2FsbGFibGVUb29sLlxuZnVuY3Rpb24gaGFzQ2FsbGFibGVUb29scyhwYXJhbXMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4gKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvb2xzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc29tZSgodG9vbCkgPT4gaXNDYWxsYWJsZVRvb2wodG9vbCkpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBmYWxzZTtcbn1cbi8vIENoZWNrcyB3aGV0aGVyIHRoZSBsaXN0IG9mIHRvb2xzIGNvbnRhaW5zIGFueSBub24tY2FsbGFibGUgdG9vbHMuIFdpbGwgcmV0dXJuXG4vLyB0cnVlIGlmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBub24tQ2FsbGFibGUgdG9vbC5cbmZ1bmN0aW9uIGhhc05vbkNhbGxhYmxlVG9vbHMocGFyYW1zKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgcmV0dXJuIChfYyA9IChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvbWUoKHRvb2wpID0+ICFpc0NhbGxhYmxlVG9vbCh0b29sKSkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgdG8gYXBwZW5kIGF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIGhpc3RvcnkgdG8gdGhlXG4gKiByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gc2hvdWxkQXBwZW5kQWZjSGlzdG9yeShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICEoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlnbm9yZUNhbGxIaXN0b3J5KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTW9kZWxzIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFrZXMgYW4gQVBJIHJlcXVlc3QgdG8gZ2VuZXJhdGUgY29udGVudCB3aXRoIGEgZ2l2ZW4gbW9kZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBWZXJ0ZXggQUkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBmdWxsIHJlc291cmNlIG5hbWUgc3RhcnRzIHdpdGggJ3Byb2plY3RzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3Byb2plY3RzL215LXByb2plY3QtaWQvbG9jYXRpb25zL3VzLWNlbnRyYWwxL3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBwYXJ0aWFsIHJlc291cmNlIG5hbWUgd2l0aCAncHVibGlzaGVycy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdwdWJsaXNoZXJzL2dvb2dsZS9tb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCcgb3JcbiAgICAgICAgICogICdwdWJsaXNoZXJzL21ldGEvbW9kZWxzL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqIC0gYC9gIHNlcGFyYXRlZCBwdWJsaXNoZXIgYW5kIG1vZGVsIG5hbWUsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAnZ29vZ2xlL2dlbWluaS0yLjAtZmxhc2gnIG9yICdtZXRhL2xsYW1hLTMuMS00MDViLWluc3RydWN0LW1hYXMnXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciB0aGUgYG1vZGVsYCBwYXJhbWV0ZXIsIHN1cHBvcnRlZCBmb3JtYXRzIGZvciBHZW1pbmkgQVBJIGluY2x1ZGU6XG4gICAgICAgICAqIC0gVGhlIEdlbWluaSBtb2RlbCBJRCwgZm9yIGV4YW1wbGU6ICdnZW1pbmktMi4wLWZsYXNoJ1xuICAgICAgICAgKiAtIFRoZSBtb2RlbCBuYW1lIHN0YXJ0cyB3aXRoICdtb2RlbHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAnbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gRm9yIHR1bmVkIG1vZGVscywgdGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ3R1bmVkTW9kZWxzLycsXG4gICAgICAgICAqIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50LlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgY2FuZGlkYXRlQ291bnQ6IDIsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogY29uc29sZS5sb2cocmVzcG9uc2UpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50ID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoIWhhc0NhbGxhYmxlVG9vbHMocGFyYW1zKSB8fCBzaG91bGREaXNhYmxlQWZjKHBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVDb250ZW50SW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc05vbkNhbGxhYmxlVG9vbHMocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0b21hdGljIGZ1bmN0aW9uIGNhbGxpbmcgd2l0aCBDYWxsYWJsZVRvb2xzIGFuZCBUb29scyBpcyBub3QgeWV0IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlQ29udGVudDtcbiAgICAgICAgICAgIGNvbnN0IGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkgPSB0Q29udGVudHModHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMpO1xuICAgICAgICAgICAgY29uc3QgbWF4UmVtb3RlQ2FsbHMgPSAoX2MgPSAoX2IgPSAoX2EgPSB0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5tYXhpbXVtUmVtb3RlQ2FsbHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IERFRkFVTFRfTUFYX1JFTU9URV9DQUxMUztcbiAgICAgICAgICAgIGxldCByZW1vdGVDYWxscyA9IDA7XG4gICAgICAgICAgICB3aGlsZSAocmVtb3RlQ2FsbHMgPCBtYXhSZW1vdGVDYWxscykge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbCh0cmFuc2Zvcm1lZFBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5mdW5jdGlvbkNhbGxzIHx8IHJlc3BvbnNlLmZ1bmN0aW9uQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZUNvbnRlbnQgPSByZXNwb25zZS5jYW5kaWRhdGVzWzBdLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SZXNwb25zZVBhcnRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIChfZSA9IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50b29scykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2FsbGFibGVUb29sKHRvb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBhd2FpdCBjYWxsYWJsZVRvb2wuY2FsbFRvb2wocmVzcG9uc2UuZnVuY3Rpb25DYWxscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlUGFydHMucHVzaCguLi5wYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3RlQ2FsbHMrKztcbiAgICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlQ29udGVudCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICBwYXJ0czogZnVuY3Rpb25SZXNwb25zZVBhcnRzLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMgPSB0Q29udGVudHModHJhbnNmb3JtZWRQYXJhbXMuY29udGVudHMpO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkUGFyYW1zLmNvbnRlbnRzLnB1c2gocmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1lZFBhcmFtcy5jb250ZW50cy5wdXNoKGZ1bmN0aW9uUmVzcG9uc2VDb250ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kQWZjSGlzdG9yeSh0cmFuc2Zvcm1lZFBhcmFtcy5jb25maWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZ0hpc3RvcnkucHVzaChyZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICBhdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5LnB1c2goZnVuY3Rpb25SZXNwb25zZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRBcHBlbmRBZmNIaXN0b3J5KHRyYW5zZm9ybWVkUGFyYW1zLmNvbmZpZykpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5hdXRvbWF0aWNGdW5jdGlvbkNhbGxpbmdIaXN0b3J5ID1cbiAgICAgICAgICAgICAgICAgICAgYXV0b21hdGljRnVuY3Rpb25DYWxsaW5nSGlzdG9yeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ha2VzIGFuIEFQSSByZXF1ZXN0IHRvIGdlbmVyYXRlIGNvbnRlbnQgd2l0aCBhIGdpdmVuIG1vZGVsIGFuZCB5aWVsZHMgdGhlXG4gICAgICAgICAqIHJlc3BvbnNlIGluIGNodW5rcy5cbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIFZlcnRleCBBSSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIGZ1bGwgcmVzb3VyY2UgbmFtZSBzdGFydHMgd2l0aCAncHJvamVjdHMvJywgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAncHJvamVjdHMvbXktcHJvamVjdC1pZC9sb2NhdGlvbnMvdXMtY2VudHJhbDEvcHVibGlzaGVycy9nb29nbGUvbW9kZWxzL2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIHBhcnRpYWwgcmVzb3VyY2UgbmFtZSB3aXRoICdwdWJsaXNoZXJzLycsIGZvciBleGFtcGxlOlxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvZ29vZ2xlL21vZGVscy9nZW1pbmktMi4wLWZsYXNoJyBvclxuICAgICAgICAgKiAgJ3B1Ymxpc2hlcnMvbWV0YS9tb2RlbHMvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICogLSBgL2Agc2VwYXJhdGVkIHB1Ymxpc2hlciBhbmQgbW9kZWwgbmFtZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICdnb29nbGUvZ2VtaW5pLTIuMC1mbGFzaCcgb3IgJ21ldGEvbGxhbWEtMy4xLTQwNWItaW5zdHJ1Y3QtbWFhcydcbiAgICAgICAgICpcbiAgICAgICAgICogRm9yIHRoZSBgbW9kZWxgIHBhcmFtZXRlciwgc3VwcG9ydGVkIGZvcm1hdHMgZm9yIEdlbWluaSBBUEkgaW5jbHVkZTpcbiAgICAgICAgICogLSBUaGUgR2VtaW5pIG1vZGVsIElELCBmb3IgZXhhbXBsZTogJ2dlbWluaS0yLjAtZmxhc2gnXG4gICAgICAgICAqIC0gVGhlIG1vZGVsIG5hbWUgc3RhcnRzIHdpdGggJ21vZGVscy8nLCBmb3IgZXhhbXBsZTpcbiAgICAgICAgICogICdtb2RlbHMvZ2VtaW5pLTIuMC1mbGFzaCdcbiAgICAgICAgICogLSBGb3IgdHVuZWQgbW9kZWxzLCB0aGUgbW9kZWwgbmFtZSBzdGFydHMgd2l0aCAndHVuZWRNb2RlbHMvJyxcbiAgICAgICAgICogZm9yIGV4YW1wbGU6XG4gICAgICAgICAqICAndHVuZWRNb2RlbHMvMTIzNDU2Nzg5MDEyMzQ1Njc4OSdcbiAgICAgICAgICpcbiAgICAgICAgICogU29tZSBtb2RlbHMgc3VwcG9ydCBtdWx0aW1vZGFsIGlucHV0IGFuZCBvdXRwdXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBjb250ZW50IHdpdGggc3RyZWFtaW5nIHJlc3BvbnNlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIGdlbmVyYXRpbmcgY29udGVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhaS5tb2RlbHMuZ2VuZXJhdGVDb250ZW50U3RyZWFtKHtcbiAgICAgICAgICogICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAgICAgKiAgIGNvbnRlbnRzOiAnd2h5IGlzIHRoZSBza3kgYmx1ZT8nLFxuICAgICAgICAgKiAgIGNvbmZpZzoge1xuICAgICAgICAgKiAgICAgbWF4T3V0cHV0VG9rZW5zOiAyMDAsXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICogZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiByZXNwb25zZSkge1xuICAgICAgICAgKiAgIGNvbnNvbGUubG9nKGNodW5rKTtcbiAgICAgICAgICogfVxuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVDb250ZW50U3RyZWFtID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXliZU1vdmVUb1Jlc3BvbnNlSnNvblNjaGVtKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkRGlzYWJsZUFmYyhwYXJhbXMuY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgdGhpcy5wcm9jZXNzUGFyYW1zTWF5YmVBZGRNY3BVc2FnZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnByb2Nlc3NBZmNTdHJlYW0ocGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdlbmVyYXRlcyBhbiBpbWFnZSBiYXNlZCBvbiBhIHRleHQgZGVzY3JpcHRpb24gYW5kIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZ2VuZXJhdGluZyBpbWFnZXMuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLmdlbmVyYXRlSW1hZ2VzKHtcbiAgICAgICAgICogIG1vZGVsOiAnaW1hZ2VuLTMuMC1nZW5lcmF0ZS0wMDInLFxuICAgICAgICAgKiAgcHJvbXB0OiAnUm9ib3QgaG9sZGluZyBhIHJlZCBza2F0ZWJvYXJkJyxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdlbmVyYXRlSW1hZ2VzID0gYXN5bmMgKHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbWFnZXNJbnRlcm5hbChwYXJhbXMpLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGxldCBwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2VuZXJhdGVkSW1hZ2VzID0gW107XG4gICAgICAgICAgICAgICAgaWYgKGFwaVJlc3BvbnNlID09PSBudWxsIHx8IGFwaVJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBnZW5lcmF0ZWRJbWFnZSBvZiBhcGlSZXNwb25zZS5nZW5lcmF0ZWRJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnZW5lcmF0ZWRJbWFnZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnZW5lcmF0ZWRJbWFnZSA9PT0gbnVsbCB8fCBnZW5lcmF0ZWRJbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdGVkSW1hZ2Uuc2FmZXR5QXR0cmlidXRlcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9hID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50VHlwZSkgPT09ICdQb3NpdGl2ZSBQcm9tcHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzID0gZ2VuZXJhdGVkSW1hZ2UgPT09IG51bGwgfHwgZ2VuZXJhdGVkSW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdlbmVyYXRlZEltYWdlLnNhZmV0eUF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXMucHVzaChnZW5lcmF0ZWRJbWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGl2ZVByb21wdFNhZmV0eUF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZWRJbWFnZXM6IGdlbmVyYXRlZEltYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlUHJvbXB0U2FmZXR5QXR0cmlidXRlczogcG9zaXRpdmVQcm9tcHRTYWZldHlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlZEltYWdlczogZ2VuZXJhdGVkSW1hZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2RrSHR0cFJlc3BvbnNlOiBhcGlSZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5QmFzZTogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhY3R1YWxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbFBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb25maWc6IGFjdHVhbENvbmZpZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhY3R1YWxQYXJhbXMuY29uZmlnLnF1ZXJ5QmFzZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gYWN0dWFsUGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWx0ZXJpbmcgdHVuZWQgbW9kZWxzIGxpc3QgZm9yIFZlcnRleCBBSSBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsUGFyYW1zLmNvbmZpZy5maWx0ZXIgPSAnbGFiZWxzLnR1bmUtdHlwZToqJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fTU9ERUxTLCAoeCkgPT4gdGhpcy5saXN0SW50ZXJuYWwoeCksIGF3YWl0IHRoaXMubGlzdEludGVybmFsKGFjdHVhbFBhcmFtcyksIGFjdHVhbFBhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyBhbiBpbWFnZSBiYXNlZCBvbiBhIHByb21wdCwgbGlzdCBvZiByZWZlcmVuY2UgaW1hZ2VzLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlZGl0aW5nIGFuIGltYWdlLlxuICAgICAgICAgKiBAcmV0dXJuIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgY2xpZW50Lm1vZGVscy5lZGl0SW1hZ2Uoe1xuICAgICAgICAgKiAgbW9kZWw6ICdpbWFnZW4tMy4wLWNhcGFiaWxpdHktMDAxJyxcbiAgICAgICAgICogIHByb21wdDogJ0dlbmVyYXRlIGFuIGltYWdlIGNvbnRhaW5pbmcgYSBtdWcgd2l0aCB0aGUgcHJvZHVjdCBsb2dvIFsxXSB2aXNpYmxlIG9uIHRoZSBzaWRlIG9mIHRoZSBtdWcuJyxcbiAgICAgICAgICogIHJlZmVyZW5jZUltYWdlczogW3N1YmplY3RSZWZlcmVuY2VJbWFnZV1cbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZkltYWdlczogMSxcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtc0ludGVybmFsID0ge1xuICAgICAgICAgICAgICAgIG1vZGVsOiBwYXJhbXMubW9kZWwsXG4gICAgICAgICAgICAgICAgcHJvbXB0OiBwYXJhbXMucHJvbXB0LFxuICAgICAgICAgICAgICAgIHJlZmVyZW5jZUltYWdlczogW10sXG4gICAgICAgICAgICAgICAgY29uZmlnOiBwYXJhbXMuY29uZmlnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVmZXJlbmNlSW1hZ2VzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5yZWZlcmVuY2VJbWFnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zSW50ZXJuYWwucmVmZXJlbmNlSW1hZ2VzID0gcGFyYW1zLnJlZmVyZW5jZUltYWdlcy5tYXAoKGltZykgPT4gaW1nLnRvUmVmZXJlbmNlSW1hZ2VBUEkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuZWRpdEltYWdlSW50ZXJuYWwocGFyYW1zSW50ZXJuYWwpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBzY2FsZXMgYW4gaW1hZ2UgYmFzZWQgb24gYW4gaW1hZ2UsIHVwc2NhbGUgZmFjdG9yLCBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICogT25seSBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJIGN1cnJlbnRseS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjbGllbnQubW9kZWxzLnVwc2NhbGVJbWFnZSh7XG4gICAgICAgICAqICBtb2RlbDogJ2ltYWdlbi0zLjAtZ2VuZXJhdGUtMDAyJyxcbiAgICAgICAgICogIGltYWdlOiBpbWFnZSxcbiAgICAgICAgICogIHVwc2NhbGVGYWN0b3I6ICd4MicsXG4gICAgICAgICAqICBjb25maWc6IHtcbiAgICAgICAgICogICAgaW5jbHVkZVJhaVJlYXNvbjogdHJ1ZSxcbiAgICAgICAgICogIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwc2NhbGVJbWFnZSA9IGFzeW5jIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGxldCBhcGlDb25maWcgPSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICAgICAgICAgICAgbW9kZTogJ3Vwc2NhbGUnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgYXBpQ29uZmlnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBhcGlDb25maWcpLCBwYXJhbXMuY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFwaVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBtb2RlbDogcGFyYW1zLm1vZGVsLFxuICAgICAgICAgICAgICAgIGltYWdlOiBwYXJhbXMuaW1hZ2UsXG4gICAgICAgICAgICAgICAgdXBzY2FsZUZhY3RvcjogcGFyYW1zLnVwc2NhbGVGYWN0b3IsXG4gICAgICAgICAgICAgICAgY29uZmlnOiBhcGlDb25maWcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudXBzY2FsZUltYWdlSW50ZXJuYWwoYXBpUGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqICBHZW5lcmF0ZXMgdmlkZW9zIGJhc2VkIG9uIGEgdGV4dCBkZXNjcmlwdGlvbiBhbmQgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBnZW5lcmF0aW5nIHZpZGVvcy5cbiAgICAgICAgICogQHJldHVybiBBIFByb21pc2U8R2VuZXJhdGVWaWRlb3NPcGVyYXRpb24+IHdoaWNoIGFsbG93cyB5b3UgdG8gdHJhY2sgdGhlIHByb2dyZXNzIGFuZCBldmVudHVhbGx5IHJldHJpZXZlIHRoZSBnZW5lcmF0ZWQgdmlkZW9zIHVzaW5nIHRoZSBvcGVyYXRpb25zLmdldCBtZXRob2QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGBgYHRzXG4gICAgICAgICAqIGNvbnN0IG9wZXJhdGlvbiA9IGF3YWl0IGFpLm1vZGVscy5nZW5lcmF0ZVZpZGVvcyh7XG4gICAgICAgICAqICBtb2RlbDogJ3Zlby0yLjAtZ2VuZXJhdGUtMDAxJyxcbiAgICAgICAgICogIHNvdXJjZToge1xuICAgICAgICAgKiAgICBwcm9tcHQ6ICdBIG5lb24gaG9sb2dyYW0gb2YgYSBjYXQgZHJpdmluZyBhdCB0b3Agc3BlZWQnLFxuICAgICAgICAgKiAgfSxcbiAgICAgICAgICogIGNvbmZpZzoge1xuICAgICAgICAgKiAgICBudW1iZXJPZlZpZGVvczogMVxuICAgICAgICAgKiB9KTtcbiAgICAgICAgICpcbiAgICAgICAgICogd2hpbGUgKCFvcGVyYXRpb24uZG9uZSkge1xuICAgICAgICAgKiAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwMCkpO1xuICAgICAgICAgKiAgIG9wZXJhdGlvbiA9IGF3YWl0IGFpLm9wZXJhdGlvbnMuZ2V0VmlkZW9zT3BlcmF0aW9uKHtvcGVyYXRpb246IG9wZXJhdGlvbn0pO1xuICAgICAgICAgKiB9XG4gICAgICAgICAqXG4gICAgICAgICAqIGNvbnNvbGUubG9nKG9wZXJhdGlvbi5yZXNwb25zZT8uZ2VuZXJhdGVkVmlkZW9zPy5bMF0/LnZpZGVvPy51cmkpO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2VuZXJhdGVWaWRlb3MgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICBpZiAoKHBhcmFtcy5wcm9tcHQgfHwgcGFyYW1zLmltYWdlIHx8IHBhcmFtcy52aWRlbykgJiYgcGFyYW1zLnNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU291cmNlIGFuZCBwcm9tcHQvaW1hZ2UvdmlkZW8gYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4gUGxlYXNlIG9ubHkgdXNlIHNvdXJjZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmdlbmVyYXRlVmlkZW9zSW50ZXJuYWwocGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBsb2dpYyBpcyBuZWVkZWQgZm9yIEdlbmVyYXRlQ29udGVudENvbmZpZyBvbmx5LlxuICAgICAqIFByZXZpb3VzbHkgd2UgbWFkZSBHZW5lcmF0ZUNvbnRlbnRDb25maWcucmVzcG9uc2VTY2hlbWEgZmllbGQgdG8gYWNjZXB0XG4gICAgICogdW5rbm93bi4gU2luY2UgdjEuOS4wLCB3ZSBzd2l0Y2ggdG8gdXNlIGJhY2tlbmQgSlNPTiBzY2hlbWEgc3VwcG9ydC5cbiAgICAgKiBUbyBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSBtb3ZlIHRoZSBkYXRhIHRoYXQgd2FzIHRyZWF0ZWQgYXNcbiAgICAgKiBKU09OIHNjaGVtYSBmcm9tIHRoZSByZXNwb25zZVNjaGVtYSBmaWVsZCB0byB0aGUgcmVzcG9uc2VKc29uU2NoZW1hIGZpZWxkLlxuICAgICAqL1xuICAgIG1heWJlTW92ZVRvUmVzcG9uc2VKc29uU2NoZW0ocGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuY29uZmlnICYmIHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWEpIHtcbiAgICAgICAgICAgIGlmICghcGFyYW1zLmNvbmZpZy5yZXNwb25zZUpzb25TY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMocGFyYW1zLmNvbmZpZy5yZXNwb25zZVNjaGVtYSkuaW5jbHVkZXMoJyRzY2hlbWEnKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMuY29uZmlnLnJlc3BvbnNlSnNvblNjaGVtYSA9IHBhcmFtcy5jb25maWcucmVzcG9uc2VTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMuY29uZmlnLnJlc3BvbnNlU2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybXMgdGhlIENhbGxhYmxlVG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMgdG8gYmUgc2ltcGx5IFRvb2xzLCBpdFxuICAgICAqIGNvcGllcyB0aGUgcGFyYW1zIGludG8gYSBuZXcgb2JqZWN0IGFuZCByZXBsYWNlcyB0aGUgdG9vbHMsIGl0IGRvZXMgbm90XG4gICAgICogbW9kaWZ5IHRoZSBvcmlnaW5hbCBwYXJhbXMuIEFsc28gc2V0cyB0aGUgTUNQIHVzYWdlIGhlYWRlciBpZiB0aGVyZSBhcmVcbiAgICAgKiBNQ1AgdG9vbHMgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgYXN5bmMgcHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB0b29scyA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scztcbiAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFRvb2xzID0gYXdhaXQgUHJvbWlzZS5hbGwodG9vbHMubWFwKGFzeW5jICh0b29sKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDYWxsYWJsZVRvb2wodG9vbCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYWJsZVRvb2wgPSB0b29sO1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjYWxsYWJsZVRvb2wudG9vbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvb2w7XG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgbmV3UGFyYW1zID0ge1xuICAgICAgICAgICAgbW9kZWw6IHBhcmFtcy5tb2RlbCxcbiAgICAgICAgICAgIGNvbnRlbnRzOiBwYXJhbXMuY29udGVudHMsXG4gICAgICAgICAgICBjb25maWc6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZyksIHsgdG9vbHM6IHRyYW5zZm9ybWVkVG9vbHMgfSksXG4gICAgICAgIH07XG4gICAgICAgIG5ld1BhcmFtcy5jb25maWcudG9vbHMgPSB0cmFuc2Zvcm1lZFRvb2xzO1xuICAgICAgICBpZiAocGFyYW1zLmNvbmZpZyAmJlxuICAgICAgICAgICAgcGFyYW1zLmNvbmZpZy50b29scyAmJlxuICAgICAgICAgICAgaGFzTWNwVG9vbFVzYWdlKHBhcmFtcy5jb25maWcudG9vbHMpKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gKF9jID0gKF9iID0gcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlYWRlcnMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9O1xuICAgICAgICAgICAgbGV0IG5ld0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBoZWFkZXJzKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdIZWFkZXJzKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBuZXdIZWFkZXJzID0gdGhpcy5hcGlDbGllbnQuZ2V0RGVmYXVsdEhlYWRlcnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldE1jcFVzYWdlSGVhZGVyKG5ld0hlYWRlcnMpO1xuICAgICAgICAgICAgbmV3UGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLmNvbmZpZy5odHRwT3B0aW9ucyksIHsgaGVhZGVyczogbmV3SGVhZGVycyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3UGFyYW1zO1xuICAgIH1cbiAgICBhc3luYyBpbml0QWZjVG9vbHNNYXAocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhZmNUb29scyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIChfYiA9IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b29scykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW10pIHtcbiAgICAgICAgICAgIGlmIChpc0NhbGxhYmxlVG9vbCh0b29sKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxhYmxlVG9vbCA9IHRvb2w7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vbERlY2xhcmF0aW9uID0gYXdhaXQgY2FsbGFibGVUb29sLnRvb2woKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGRlY2xhcmF0aW9uIG9mIChfYyA9IHRvb2xEZWNsYXJhdGlvbi5mdW5jdGlvbkRlY2xhcmF0aW9ucykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkZWNsYXJhdGlvbi5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIGRlY2xhcmF0aW9uIG5hbWUgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmY1Rvb2xzLmhhcyhkZWNsYXJhdGlvbi5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgdG9vbCBkZWNsYXJhdGlvbiBuYW1lOiAke2RlY2xhcmF0aW9uLm5hbWV9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWZjVG9vbHMuc2V0KGRlY2xhcmF0aW9uLm5hbWUsIGNhbGxhYmxlVG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZmNUb29scztcbiAgICB9XG4gICAgYXN5bmMgcHJvY2Vzc0FmY1N0cmVhbShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IG1heFJlbW90ZUNhbGxzID0gKF9jID0gKF9iID0gKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9tYXRpY0Z1bmN0aW9uQ2FsbGluZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heGltdW1SZW1vdGVDYWxscykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogREVGQVVMVF9NQVhfUkVNT1RFX0NBTExTO1xuICAgICAgICBsZXQgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICBsZXQgcmVtb3RlQ2FsbENvdW50ID0gMDtcbiAgICAgICAgY29uc3QgYWZjVG9vbHNNYXAgPSBhd2FpdCB0aGlzLmluaXRBZmNUb29sc01hcChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uIChtb2RlbHMsIGFmY1Rvb2xzLCBwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jLCBlXzEsIF9kLCBfZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVtb3RlQ2FsbENvdW50IDwgbWF4UmVtb3RlQ2FsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdlcmVGdW5jdGlvbnNDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW90ZUNhbGxDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VyZUZ1bmN0aW9uc0NhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0geWllbGQgX19hd2FpdChtb2RlbHMucHJvY2Vzc1BhcmFtc01heWJlQWRkTWNwVXNhZ2UocGFyYW1zKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgX19hd2FpdChtb2RlbHMuZ2VuZXJhdGVDb250ZW50U3RyZWFtSW50ZXJuYWwodHJhbnNmb3JtZWRQYXJhbXMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SZXNwb25zZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VDb250ZW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCByZXNwb25zZV8xID0gKGVfMSA9IHZvaWQgMCwgX19hc3luY1ZhbHVlcyhyZXNwb25zZSkpLCByZXNwb25zZV8xXzE7IHJlc3BvbnNlXzFfMSA9IHlpZWxkIF9fYXdhaXQocmVzcG9uc2VfMS5uZXh0KCkpLCBfYyA9IHJlc3BvbnNlXzFfMS5kb25lLCAhX2M7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9lID0gcmVzcG9uc2VfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBfZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KGNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmsuY2FuZGlkYXRlcyAmJiAoKF9hID0gY2h1bmsuY2FuZGlkYXRlc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlQ29udGVudHMucHVzaChjaHVuay5jYW5kaWRhdGVzWzBdLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgKF9iID0gY2h1bmsuY2FuZGlkYXRlc1swXS5jb250ZW50LnBhcnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW90ZUNhbGxDb3VudCA8IG1heFJlbW90ZUNhbGxzICYmIHBhcnQuZnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbCBuYW1lIHdhcyBub3QgcmV0dXJuZWQgYnkgdGhlIG1vZGVsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFmY1Rvb2xzLmhhcyhwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF1dG9tYXRpYyBmdW5jdGlvbiBjYWxsaW5nIHdhcyByZXF1ZXN0ZWQsIGJ1dCBub3QgYWxsIHRoZSB0b29scyB0aGUgbW9kZWwgdXNlZCBpbXBsZW1lbnQgdGhlIENhbGxhYmxlVG9vbCBpbnRlcmZhY2UuIEF2YWlsYWJsZSB0b29sczogJHthZmNUb29scy5rZXlzKCl9LCBtaXNpbmcgdG9vbDogJHtwYXJ0LmZ1bmN0aW9uQ2FsbC5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQYXJ0cyA9IHlpZWxkIF9fYXdhaXQoYWZjVG9vbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXQocGFydC5mdW5jdGlvbkNhbGwubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYWxsVG9vbChbcGFydC5mdW5jdGlvbkNhbGxdKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2VzLnB1c2goLi4ucmVzcG9uc2VQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYyAmJiAoX2QgPSByZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2QuY2FsbChyZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uUmVzcG9uc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlcmVGdW5jdGlvbnNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwb25zZUNodW5rID0gbmV3IEdlbmVyYXRlQ29udGVudFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlZFJlc3BvbnNlQ2h1bmsuY2FuZGlkYXRlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6ICd1c2VyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQodHlwZWRSZXNwb25zZUNodW5rKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnRzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdDb250ZW50cy5wdXNoKC4uLnJlc3BvbnNlQ29udGVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29udGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogJ3VzZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzOiBmdW5jdGlvblJlc3BvbnNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZENvbnRlbnRzID0gdENvbnRlbnRzKHBhcmFtcy5jb250ZW50cykuY29uY2F0KG5ld0NvbnRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5jb250ZW50cyA9IHVwZGF0ZWRDb250ZW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKHRoaXMsIGFmY1Rvb2xzTWFwLCBwYXJhbXMpO1xuICAgIH1cbiAgICBhc3luYyBnZW5lcmF0ZUNvbnRlbnRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpnZW5lcmF0ZUNvbnRlbnQnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmdlbmVyYXRlQ29udGVudCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdlbmVyYXRlQ29udGVudFN0cmVhbUludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUNvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnN0cmVhbUdlbmVyYXRlQ29udGVudD9hbHQ9c3NlJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgY29uc3QgYXBpQ2xpZW50ID0gdGhpcy5hcGlDbGllbnQ7XG4gICAgICAgICAgICByZXNwb25zZSA9IGFwaUNsaWVudC5yZXF1ZXN0U3RyZWFtKHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbihmdW5jdGlvbiAoYXBpUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIGFwaVJlc3BvbnNlXzEgPSBfX2FzeW5jVmFsdWVzKGFwaVJlc3BvbnNlKSwgYXBpUmVzcG9uc2VfMV8xOyBhcGlSZXNwb25zZV8xXzEgPSB5aWVsZCBfX2F3YWl0KGFwaVJlc3BvbnNlXzEubmV4dCgpKSwgX2EgPSBhcGlSZXNwb25zZV8xXzEuZG9uZSwgIV9hOyBfZCA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyA9IGFwaVJlc3BvbnNlXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlQ29udGVudFJlc3BvbnNlRnJvbVZlcnRleCgoeWllbGQgX19hd2FpdChjaHVuay5qc29uKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcFsnc2RrSHR0cFJlc3BvbnNlJ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNodW5rLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBhcGlSZXNwb25zZV8xLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChhcGlSZXNwb25zZV8xKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlQ29udGVudFBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpzdHJlYW1HZW5lcmF0ZUNvbnRlbnQ/YWx0PXNzZScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGNvbnN0IGFwaUNsaWVudCA9IHRoaXMuYXBpQ2xpZW50O1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBhcGlDbGllbnQucmVxdWVzdFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oZnVuY3Rpb24gKGFwaVJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIGVfMywgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBhcGlSZXNwb25zZV8yID0gX19hc3luY1ZhbHVlcyhhcGlSZXNwb25zZSksIGFwaVJlc3BvbnNlXzJfMTsgYXBpUmVzcG9uc2VfMl8xID0geWllbGQgX19hd2FpdChhcGlSZXNwb25zZV8yLm5leHQoKSksIF9hID0gYXBpUmVzcG9uc2VfMl8xLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MgPSBhcGlSZXNwb25zZV8yXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBnZW5lcmF0ZUNvbnRlbnRSZXNwb25zZUZyb21NbGRldigoeWllbGQgX19hd2FpdChjaHVuay5qc29uKCkpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcFsnc2RrSHR0cFJlc3BvbnNlJ10gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGNodW5rLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgeWllbGQgX19hd2FpdCh0eXBlZFJlc3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9kICYmICFfYSAmJiAoX2IgPSBhcGlSZXNwb25zZV8yLnJldHVybikpIHlpZWxkIF9fYXdhaXQoX2IuY2FsbChhcGlSZXNwb25zZV8yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgZW1iZWRkaW5ncyBmb3IgdGhlIGdpdmVuIGNvbnRlbnRzLiBPbmx5IHRleHQgaXMgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBlbWJlZGRpbmcgY29udGVudHMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmVtYmVkQ29udGVudCh7XG4gICAgICogIG1vZGVsOiAndGV4dC1lbWJlZGRpbmctMDA0JyxcbiAgICAgKiAgY29udGVudHM6IFtcbiAgICAgKiAgICAnV2hhdCBpcyB5b3VyIG5hbWU/JyxcbiAgICAgKiAgICAnV2hhdCBpcyB5b3VyIGZhdm9yaXRlIGNvbG9yPycsXG4gICAgICogIF0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG91dHB1dERpbWVuc2lvbmFsaXR5OiA2NCxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgZW1iZWRDb250ZW50KHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBlbWJlZENvbnRlbnRQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBlbWJlZENvbnRlbnRSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBFbWJlZENvbnRlbnRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZW1iZWRDb250ZW50UGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmJhdGNoRW1iZWRDb250ZW50cycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGVtYmVkQ29udGVudFJlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRW1iZWRDb250ZW50UmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciBnZW5lcmF0aW5nIGltYWdlcy5cbiAgICAgKi9cbiAgICBhc3luYyBnZW5lcmF0ZUltYWdlc0ludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBnZW5lcmF0ZUltYWdlc1BhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVJbWFnZXNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVJbWFnZXNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGdlbmVyYXRlSW1hZ2VzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZWRpdGluZyBhbiBpbWFnZS5cbiAgICAgKi9cbiAgICBhc3luYyBlZGl0SW1hZ2VJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGVkaXRJbWFnZVBhcmFtZXRlcnNJbnRlcm5hbFRvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZWRpdEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgRWRpdEltYWdlUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIGZvciB1cHNjYWxpbmcgYW4gaW1hZ2UuXG4gICAgICovXG4gICAgYXN5bmMgdXBzY2FsZUltYWdlSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cHNjYWxlSW1hZ2VBUElQYXJhbWV0ZXJzSW50ZXJuYWxUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06cHJlZGljdCcsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHVwc2NhbGVJbWFnZVJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IFVwc2NhbGVJbWFnZVJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWNvbnRleHR1YWxpemVzIGFuIGltYWdlLlxuICAgICAqXG4gICAgICogVGhlcmUgYXJlIHR3byB0eXBlcyBvZiByZWNvbnRleHR1YWxpemF0aW9uIGN1cnJlbnRseSBzdXBwb3J0ZWQ6XG4gICAgICogMSkgSW1hZ2VuIFByb2R1Y3QgUmVjb250ZXh0IC0gR2VuZXJhdGUgaW1hZ2VzIG9mIHByb2R1Y3RzIGluIG5ldyBzY2VuZXNcbiAgICAgKiAgICBhbmQgY29udGV4dHMuXG4gICAgICogMikgVmlydHVhbCBUcnktT246IEdlbmVyYXRlIGltYWdlcyBvZiBwZXJzb25zIG1vZGVsaW5nIGZhc2hpb24gcHJvZHVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHJlY29udGV4dHVhbGl6aW5nIGFuIGltYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZTEgPSBhd2FpdCBhaS5tb2RlbHMucmVjb250ZXh0SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ2ltYWdlbi1wcm9kdWN0LXJlY29udGV4dC1wcmV2aWV3LTA2LTMwJyxcbiAgICAgKiAgc291cmNlOiB7XG4gICAgICogICAgcHJvbXB0OiAnSW4gYSBtb2Rlcm4ga2l0Y2hlbiBzZXR0aW5nLicsXG4gICAgICogICAgcHJvZHVjdEltYWdlczogW3Byb2R1Y3RJbWFnZV0sXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG51bWJlck9mSW1hZ2VzOiAxLFxuICAgICAqICB9LFxuICAgICAqIH0pO1xuICAgICAqIGNvbnNvbGUubG9nKHJlc3BvbnNlMT8uZ2VuZXJhdGVkSW1hZ2VzPy5bMF0/LmltYWdlPy5pbWFnZUJ5dGVzKTtcbiAgICAgKlxuICAgICAqIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IGFpLm1vZGVscy5yZWNvbnRleHRJbWFnZSh7XG4gICAgICogIG1vZGVsOiAndmlydHVhbC10cnktb24tcHJldmlldy0wOC0wNCcsXG4gICAgICogIHNvdXJjZToge1xuICAgICAqICAgIHBlcnNvbkltYWdlOiBwZXJzb25JbWFnZSxcbiAgICAgKiAgICBwcm9kdWN0SW1hZ2VzOiBbcHJvZHVjdEltYWdlXSxcbiAgICAgKiAgfSxcbiAgICAgKiAgY29uZmlnOiB7XG4gICAgICogICAgbnVtYmVyT2ZJbWFnZXM6IDEsXG4gICAgICogIH0sXG4gICAgICogfSk7XG4gICAgICogY29uc29sZS5sb2cocmVzcG9uc2UyPy5nZW5lcmF0ZWRJbWFnZXM/LlswXT8uaW1hZ2U/LmltYWdlQnl0ZXMpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHJlY29udGV4dEltYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gcmVjb250ZXh0SW1hZ2VQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3QnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHJlY29udGV4dEltYWdlUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VnbWVudHMgYW4gaW1hZ2UsIGNyZWF0aW5nIGEgbWFzayBvZiBhIHNwZWNpZmllZCBhcmVhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBzZWdtZW50aW5nIGFuIGltYWdlLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5zZWdtZW50SW1hZ2Uoe1xuICAgICAqICBtb2RlbDogJ2ltYWdlLXNlZ21lbnRhdGlvbi0wMDEnLFxuICAgICAqICBzb3VyY2U6IHtcbiAgICAgKiAgICBpbWFnZTogaW1hZ2UsXG4gICAgICogIH0sXG4gICAgICogIGNvbmZpZzoge1xuICAgICAqICAgIG1vZGU6ICdmb3JlZ3JvdW5kJyxcbiAgICAgKiAgfSxcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZT8uZ2VuZXJhdGVkTWFza3M/LlswXT8ubWFzaz8uaW1hZ2VCeXRlcyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgc2VnbWVudEltYWdlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gc2VnbWVudEltYWdlUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpwcmVkaWN0JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBzZWdtZW50SW1hZ2VSZXNwb25zZUZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBTZWdtZW50SW1hZ2VSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBpbmZvcm1hdGlvbiBhYm91dCBhIG1vZGVsIGJ5IG5hbWUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgbW9kZWxJbmZvID0gYXdhaXQgYWkubW9kZWxzLmdldCh7bW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJ30pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIGdldChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0TW9kZWxQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gbW9kZWxGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsc191cmx9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBsaXN0TW9kZWxzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdE1vZGVsc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBsaXN0TW9kZWxzUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWxzX3VybH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RNb2RlbHNSZXNwb25zZUZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IExpc3RNb2RlbHNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhIHR1bmVkIG1vZGVsIGJ5IGl0cyBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB1cGRhdGluZyB0aGUgbW9kZWwuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLnVwZGF0ZSh7XG4gICAgICogICBtb2RlbDogJ3R1bmVkLW1vZGVsLW5hbWUnLFxuICAgICAqICAgY29uZmlnOiB7XG4gICAgICogICAgIGRpc3BsYXlOYW1lOiAnTmV3IGRpc3BsYXkgbmFtZScsXG4gICAgICogICAgIGRlc2NyaXB0aW9uOiAnTmV3IGRlc2NyaXB0aW9uJyxcbiAgICAgKiAgIH0sXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSB1cGRhdGVNb2RlbFBhcmFtZXRlcnNUb1ZlcnRleCh0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQQVRDSCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBtb2RlbEZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gdXBkYXRlTW9kZWxQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BBVENIJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IG1vZGVsRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZXMgYSB0dW5lZCBtb2RlbCBieSBpdHMgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgZGVsZXRpbmcgdGhlIG1vZGVsLlxuICAgICAqIEByZXR1cm4gVGhlIHJlc3BvbnNlIGZyb20gdGhlIEFQSS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFpLm1vZGVscy5kZWxldGUoe21vZGVsOiAndHVuZWQtbW9kZWwtbmFtZSd9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhc3luYyBkZWxldGUocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne25hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnREVMRVRFJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBkZWxldGVNb2RlbFJlc3BvbnNlRnJvbVZlcnRleChhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZWRSZXNwID0gbmV3IERlbGV0ZU1vZGVsUmVzcG9uc2UoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGRlbGV0ZU1vZGVsUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGRlbGV0ZU1vZGVsUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBEZWxldGVNb2RlbFJlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3VudHMgdGhlIG51bWJlciBvZiB0b2tlbnMgaW4gdGhlIGdpdmVuIGNvbnRlbnRzLiBNdWx0aW1vZGFsIGlucHV0IGlzXG4gICAgICogc3VwcG9ydGVkIGZvciBHZW1pbmkgbW9kZWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciBjb3VudGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvdW50VG9rZW5zKHtcbiAgICAgKiAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoJyxcbiAgICAgKiAgY29udGVudHM6ICdUaGUgcXVpY2sgYnJvd24gZm94IGp1bXBzIG92ZXIgdGhlIGxhenkgZG9nLidcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY291bnRUb2tlbnMocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvdW50VG9rZW5zUGFyYW1ldGVyc1RvVmVydGV4KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne21vZGVsfTpjb3VudFRva2VucycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGNvdW50VG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY291bnRUb2tlbnNQYXJhbWV0ZXJzVG9NbGRldih0aGlzLmFwaUNsaWVudCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3ttb2RlbH06Y291bnRUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9jID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2QgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb3VudFRva2Vuc1Jlc3BvbnNlRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ291bnRUb2tlbnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIGNvbnRlbnRzLCByZXR1cm5zIGEgY29ycmVzcG9uZGluZyBUb2tlbnNJbmZvIGNvbnRhaW5pbmdcbiAgICAgKiB0aGUgbGlzdCBvZiB0b2tlbnMgYW5kIGxpc3Qgb2YgdG9rZW4gaWRzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgR2VtaW5pIERldmVsb3BlciBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNvbXB1dGluZyB0b2tlbnMuXG4gICAgICogQHJldHVybiBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgQVBJLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYWkubW9kZWxzLmNvbXB1dGVUb2tlbnMoe1xuICAgICAqICBtb2RlbDogJ2dlbWluaS0yLjAtZmxhc2gnLFxuICAgICAqICBjb250ZW50czogJ1doYXQgaXMgeW91ciBuYW1lPydcbiAgICAgKiB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhyZXNwb25zZSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY29tcHV0ZVRva2VucyhwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvbXB1dGVUb2tlbnNQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OmNvbXB1dGVUb2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSBjb21wdXRlVG9rZW5zUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgQ29tcHV0ZVRva2Vuc1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIFZlcnRleCBBSS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCBmb3IgZ2VuZXJhdGluZyB2aWRlb3MuXG4gICAgICovXG4gICAgYXN5bmMgZ2VuZXJhdGVWaWRlb3NJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2VuZXJhdGVWaWRlb3NQYXJhbWV0ZXJzVG9WZXJ0ZXgodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgR2VuZXJhdGVWaWRlb3NPcGVyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHR5cGVkUmVzcCwgcmVzcCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVkUmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdlbmVyYXRlVmlkZW9zUGFyYW1ldGVyc1RvTWxkZXYodGhpcy5hcGlDbGllbnQsIHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bW9kZWx9OnByZWRpY3RMb25nUnVubmluZycsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gZ2VuZXJhdGVWaWRlb3NPcGVyYXRpb25Gcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNsYXNzIE9wZXJhdGlvbnMgZXh0ZW5kcyBCYXNlTW9kdWxlIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBhcGlDbGllbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXR1cyBvZiBhIGxvbmctcnVubmluZyBvcGVyYXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGdldCBvcGVyYXRpb24gcmVxdWVzdC5cbiAgICAgKiBAcmV0dXJuIFRoZSB1cGRhdGVkIE9wZXJhdGlvbiBvYmplY3QsIHdpdGggdGhlIGxhdGVzdCBzdGF0dXMgb3IgcmVzdWx0LlxuICAgICAqL1xuICAgIGFzeW5jIGdldFZpZGVvc09wZXJhdGlvbihwYXJhbWV0ZXJzKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHBhcmFtZXRlcnMub3BlcmF0aW9uO1xuICAgICAgICBjb25zdCBjb25maWcgPSBwYXJhbWV0ZXJzLmNvbmZpZztcbiAgICAgICAgaWYgKG9wZXJhdGlvbi5uYW1lID09PSB1bmRlZmluZWQgfHwgb3BlcmF0aW9uLm5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBuYW1lIGlzIHJlcXVpcmVkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc291cmNlTmFtZSA9IG9wZXJhdGlvbi5uYW1lLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgIGxldCBodHRwT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb25maWcgJiYgJ2h0dHBPcHRpb25zJyBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9ucyA9IGNvbmZpZy5odHRwT3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIHJlc291cmNlTmFtZTogcmVzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogeyBodHRwT3B0aW9uczogaHR0cE9wdGlvbnMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlzVmVydGV4QUk6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJhd09wZXJhdGlvbiA9IGF3YWl0IHRoaXMuZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbk5hbWU6IG9wZXJhdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uLl9mcm9tQVBJUmVzcG9uc2Uoe1xuICAgICAgICAgICAgICAgIGFwaVJlc3BvbnNlOiByYXdPcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgaXNWZXJ0ZXhBSTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgYSBsb25nLXJ1bm5pbmcgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgVGhlIHBhcmFtZXRlcnMgZm9yIHRoZSBnZXQgb3BlcmF0aW9uIHJlcXVlc3QuXG4gICAgICogQHJldHVybiBUaGUgdXBkYXRlZCBPcGVyYXRpb24gb2JqZWN0LCB3aXRoIHRoZSBsYXRlc3Qgc3RhdHVzIG9yIHJlc3VsdC5cbiAgICAgKi9cbiAgICBhc3luYyBnZXQocGFyYW1ldGVycykge1xuICAgICAgICBjb25zdCBvcGVyYXRpb24gPSBwYXJhbWV0ZXJzLm9wZXJhdGlvbjtcbiAgICAgICAgY29uc3QgY29uZmlnID0gcGFyYW1ldGVycy5jb25maWc7XG4gICAgICAgIGlmIChvcGVyYXRpb24ubmFtZSA9PT0gdW5kZWZpbmVkIHx8IG9wZXJhdGlvbi5uYW1lID09PSAnJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcGVyYXRpb24gbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCByZXNvdXJjZU5hbWUgPSBvcGVyYXRpb24ubmFtZS5zcGxpdCgnL29wZXJhdGlvbnMvJylbMF07XG4gICAgICAgICAgICBsZXQgaHR0cE9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlnICYmICdodHRwT3B0aW9ucycgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnMgPSBjb25maWcuaHR0cE9wdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmZldGNoUHJlZGljdFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICByZXNvdXJjZU5hbWU6IHJlc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IHsgaHR0cE9wdGlvbnM6IGh0dHBPcHRpb25zIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb24uX2Zyb21BUElSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgYXBpUmVzcG9uc2U6IHJhd09wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBpc1ZlcnRleEFJOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByYXdPcGVyYXRpb24gPSBhd2FpdCB0aGlzLmdldFZpZGVvc09wZXJhdGlvbkludGVybmFsKHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25OYW1lOiBvcGVyYXRpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5fZnJvbUFQSVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBhcGlSZXNwb25zZTogcmF3T3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGlzVmVydGV4QUk6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb1ZlcnRleChwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgne29wZXJhdGlvbk5hbWV9JywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGdldE9wZXJhdGlvblBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7b3BlcmF0aW9uTmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hQcmVkaWN0VmlkZW9zT3BlcmF0aW9uSW50ZXJuYWwocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCByZXNwb25zZTtcbiAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0ge307XG4gICAgICAgIGlmICh0aGlzLmFwaUNsaWVudC5pc1ZlcnRleEFJKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBmZXRjaFByZWRpY3RPcGVyYXRpb25QYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tyZXNvdXJjZU5hbWV9OmZldGNoUHJlZGljdE9wZXJhdGlvbicsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBWZXJ0ZXggQUkuJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmZ1bmN0aW9uIGF1ZGlvVHJhbnNjcmlwdGlvbkNvbmZpZ1RvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBhdXRoVG9rZW5Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRGlzYWJsZWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rpc2FibGVkJ10pO1xuICAgIGlmIChmcm9tRGlzYWJsZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkaXNhYmxlZCddLCBmcm9tRGlzYWJsZWQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0T2ZTcGVlY2hTZW5zaXRpdml0eSddLCBmcm9tU3RhcnRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmRPZlNwZWVjaFNlbnNpdGl2aXR5JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZE9mU3BlZWNoU2Vuc2l0aXZpdHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRPZlNwZWVjaFNlbnNpdGl2aXR5J10sIGZyb21FbmRPZlNwZWVjaFNlbnNpdGl2aXR5KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZWZpeFBhZGRpbmdNcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZWZpeFBhZGRpbmdNcycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVmaXhQYWRkaW5nTXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVmaXhQYWRkaW5nTXMnXSwgZnJvbVByZWZpeFBhZGRpbmdNcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TaWxlbmNlRHVyYXRpb25NcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NpbGVuY2VEdXJhdGlvbk1zJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNpbGVuY2VEdXJhdGlvbk1zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2lsZW5jZUR1cmF0aW9uTXMnXSwgZnJvbVNpbGVuY2VEdXJhdGlvbk1zKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gYmxvYlRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGlzcGxheU5hbWUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Rpc3BsYXlOYW1lIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkYXRhJ10pO1xuICAgIGlmIChmcm9tRGF0YSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2RhdGEnXSwgZnJvbURhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWltZVR5cGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21pbWVUeXBlJ10pO1xuICAgIGlmIChmcm9tTWltZVR5cGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtaW1lVHlwZSddLCBmcm9tTWltZVR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlclVzZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUVudmlyb25tZW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbnZpcm9ubWVudCddKTtcbiAgICBpZiAoZnJvbUVudmlyb25tZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW52aXJvbm1lbnQnXSwgZnJvbUVudmlyb25tZW50KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21FeGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGNsdWRlZFByZWRlZmluZWRGdW5jdGlvbnMnXSwgZnJvbUV4Y2x1ZGVkUHJlZGVmaW5lZEZ1bmN0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QYXJ0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncGFydHMnXSk7XG4gICAgaWYgKGZyb21QYXJ0cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tUGFydHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFydFRvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwYXJ0cyddLCB0cmFuc2Zvcm1lZExpc3QpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUm9sZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncm9sZSddKTtcbiAgICBpZiAoZnJvbVJvbGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyb2xlJ10sIGZyb21Sb2xlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tVHJpZ2dlclRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RyaWdnZXJUb2tlbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHJpZ2dlclRva2VucyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3RyaWdnZXJUb2tlbnMnXSwgZnJvbVRyaWdnZXJUb2tlbnMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2xpZGluZ1dpbmRvdyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3NsaWRpbmdXaW5kb3cnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2xpZGluZ1dpbmRvdyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NsaWRpbmdXaW5kb3cnXSwgc2xpZGluZ1dpbmRvd1RvTWxkZXYoZnJvbVNsaWRpbmdXaW5kb3cpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY3JlYXRlQXV0aFRva2VuQ29uZmlnVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBpcmVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2V4cGlyZVRpbWUnXSwgZnJvbUV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXdTZXNzaW9uRXhwaXJlVGltZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21OZXdTZXNzaW9uRXhwaXJlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyduZXdTZXNzaW9uRXhwaXJlVGltZSddLCBmcm9tTmV3U2Vzc2lvbkV4cGlyZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVXNlcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndXNlcyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVVzZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndXNlcyddLCBmcm9tVXNlcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGl2ZUNvbm5lY3RDb25zdHJhaW50cycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddLCBsaXZlQ29ubmVjdENvbnN0cmFpbnRzVG9NbGRldihhcGlDbGllbnQsIGZyb21MaXZlQ29ubmVjdENvbnN0cmFpbnRzKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Mb2NrQWRkaXRpb25hbEZpZWxkcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2xvY2tBZGRpdGlvbmFsRmllbGRzJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxvY2tBZGRpdGlvbmFsRmllbGRzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2ZpZWxkTWFzayddLCBmcm9tTG9ja0FkZGl0aW9uYWxGaWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVBdXRoVG9rZW5QYXJhbWV0ZXJzVG9NbGRldihhcGlDbGllbnQsIGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBjcmVhdGVBdXRoVG9rZW5Db25maWdUb01sZGV2KGFwaUNsaWVudCwgZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gZHluYW1pY1JldHJpZXZhbENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21vZGUnXSk7XG4gICAgaWYgKGZyb21Nb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbW9kZSddLCBmcm9tTW9kZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EeW5hbWljVGhyZXNob2xkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZHluYW1pY1RocmVzaG9sZCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21EeW5hbWljVGhyZXNob2xkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZHluYW1pY1RocmVzaG9sZCddLCBmcm9tRHluYW1pY1RocmVzaG9sZCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZpbGVEYXRhVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkaXNwbGF5TmFtZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGlzcGxheU5hbWUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbGVVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVVcmknXSk7XG4gICAgaWYgKGZyb21GaWxlVXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZmlsZVVyaSddLCBmcm9tRmlsZVVyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NaW1lVHlwZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbWltZVR5cGUnXSk7XG4gICAgaWYgKGZyb21NaW1lVHlwZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21pbWVUeXBlJ10sIGZyb21NaW1lVHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUlkID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydpZCddKTtcbiAgICBpZiAoZnJvbUlkICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaWQnXSwgZnJvbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFyZ3MgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FyZ3MnXSk7XG4gICAgaWYgKGZyb21BcmdzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYXJncyddLCBmcm9tQXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkRlY2xhcmF0aW9uVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQmVoYXZpb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JlaGF2aW9yJ10pO1xuICAgIGlmIChmcm9tQmVoYXZpb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiZWhhdmlvciddLCBmcm9tQmVoYXZpb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVBhcmFtZXRlcnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhcmFtZXRlcnMnXSk7XG4gICAgaWYgKGZyb21QYXJhbWV0ZXJzICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVycyddLCBmcm9tUGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYXJhbWV0ZXJzSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcmFtZXRlcnNKc29uU2NoZW1hJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncGFyYW1ldGVyc0pzb25TY2hlbWEnXSwgZnJvbVBhcmFtZXRlcnNKc29uU2NoZW1hKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydyZXNwb25zZSddKTtcbiAgICBpZiAoZnJvbVJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncmVzcG9uc2UnXSwgZnJvbVJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlSnNvblNjaGVtYScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21SZXNwb25zZUpzb25TY2hlbWEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydyZXNwb25zZUpzb25TY2hlbWEnXSwgZnJvbVJlc3BvbnNlSnNvblNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFJldHJpZXZhbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdkeW5hbWljUmV0cmlldmFsQ29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUR5bmFtaWNSZXRyaWV2YWxDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkeW5hbWljUmV0cmlldmFsQ29uZmlnJ10sIGR5bmFtaWNSZXRyaWV2YWxDb25maWdUb01sZGV2KGZyb21EeW5hbWljUmV0cmlldmFsQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGdvb2dsZVNlYXJjaFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRpbWVSYW5nZUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RpbWVSYW5nZUZpbHRlcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaW1lUmFuZ2VGaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aW1lUmFuZ2VGaWx0ZXInXSwgaW50ZXJ2YWxUb01sZGV2KGZyb21UaW1lUmFuZ2VGaWx0ZXIpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhjbHVkZURvbWFpbnMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4Y2x1ZGVEb21haW5zIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGludGVydmFsVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydFRpbWUnXSk7XG4gICAgaWYgKGZyb21TdGFydFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdGFydFRpbWUnXSwgZnJvbVN0YXJ0VGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlbmRUaW1lJ10pO1xuICAgIGlmIChmcm9tRW5kVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZFRpbWUnXSwgZnJvbUVuZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tR2VuZXJhdGlvbkNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2dlbmVyYXRpb25Db25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tR2VuZXJhdGlvbkNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJ10sIGZyb21HZW5lcmF0aW9uQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21SZXNwb25zZU1vZGFsaXRpZXMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdyZXNwb25zZU1vZGFsaXRpZXMnXSwgZnJvbVJlc3BvbnNlTW9kYWxpdGllcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UZW1wZXJhdHVyZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGVtcGVyYXR1cmUnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RlbXBlcmF0dXJlJ10sIGZyb21UZW1wZXJhdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub3BQID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0b3BQJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVG9wUCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdnZW5lcmF0aW9uQ29uZmlnJywgJ3RvcFAnXSwgZnJvbVRvcFApO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVG9wSyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9wSyddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVRvcEsgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0b3BLJ10sIGZyb21Ub3BLKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU1heE91dHB1dFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ21heE91dHB1dFRva2VucycsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21NYXhPdXRwdXRUb2tlbnMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdtYXhPdXRwdXRUb2tlbnMnXSwgZnJvbU1heE91dHB1dFRva2Vucyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21NZWRpYVJlc29sdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtZWRpYVJlc29sdXRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tTWVkaWFSZXNvbHV0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnbWVkaWFSZXNvbHV0aW9uJ10sIGZyb21NZWRpYVJlc29sdXRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VlZCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc2VlZCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVNlZWQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICdzZWVkJ10sIGZyb21TZWVkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNwZWVjaENvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3BlZWNoQ29uZmlnJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU3BlZWNoQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnc3BlZWNoQ29uZmlnJ10sIHNwZWVjaENvbmZpZ1RvTWxkZXYodExpdmVTcGVlY2hDb25maWcoZnJvbVNwZWVjaENvbmZpZykpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVRoaW5raW5nQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhpbmtpbmdDb25maWcnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVGhpbmtpbmdDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnZ2VuZXJhdGlvbkNvbmZpZycsICd0aGlua2luZ0NvbmZpZyddLCB0aGlua2luZ0NvbmZpZ1RvTWxkZXYoZnJvbVRoaW5raW5nQ29uZmlnKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdlbmFibGVBZmZlY3RpdmVEaWFsb2cnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRW5hYmxlQWZmZWN0aXZlRGlhbG9nICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3NldHVwJywgJ2dlbmVyYXRpb25Db25maWcnLCAnZW5hYmxlQWZmZWN0aXZlRGlhbG9nJ10sIGZyb21FbmFibGVBZmZlY3RpdmVEaWFsb2cpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzeXN0ZW1JbnN0cnVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21TeXN0ZW1JbnN0cnVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdzeXN0ZW1JbnN0cnVjdGlvbiddLCBjb250ZW50VG9NbGRldih0Q29udGVudChmcm9tU3lzdGVtSW5zdHJ1Y3Rpb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Ub29scyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndG9vbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Ub29scyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSB0VG9vbHMoZnJvbVRvb2xzKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b29sVG9NbGRldih0VG9vbChpdGVtKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAndG9vbHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVNlc3Npb25SZXN1bXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2Vzc2lvblJlc3VtcHRpb24nLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tU2Vzc2lvblJlc3VtcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAnc2Vzc2lvblJlc3VtcHRpb24nXSwgc2Vzc2lvblJlc3VtcHRpb25Db25maWdUb01sZGV2KGZyb21TZXNzaW9uUmVzdW1wdGlvbikpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSW5wdXRBdWRpb1RyYW5zY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21JbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdpbnB1dEF1ZGlvVHJhbnNjcmlwdGlvbiddLCBhdWRpb1RyYW5zY3JpcHRpb25Db25maWdUb01sZGV2KCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnb3V0cHV0QXVkaW9UcmFuc2NyaXB0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbU91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdvdXRwdXRBdWRpb1RyYW5zY3JpcHRpb24nXSwgYXVkaW9UcmFuc2NyaXB0aW9uQ29uZmlnVG9NbGRldigpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdyZWFsdGltZUlucHV0Q29uZmlnJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVJlYWx0aW1lSW5wdXRDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc2V0dXAnLCAncmVhbHRpbWVJbnB1dENvbmZpZyddLCByZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldihmcm9tUmVhbHRpbWVJbnB1dENvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY29udGV4dFdpbmRvd0NvbXByZXNzaW9uJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUNvbnRleHRXaW5kb3dDb21wcmVzc2lvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdjb250ZXh0V2luZG93Q29tcHJlc3Npb24nXSwgY29udGV4dFdpbmRvd0NvbXByZXNzaW9uQ29uZmlnVG9NbGRldihmcm9tQ29udGV4dFdpbmRvd0NvbXByZXNzaW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Qcm9hY3Rpdml0eSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncHJvYWN0aXZpdHknXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21Qcm9hY3Rpdml0eSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzZXR1cCcsICdwcm9hY3Rpdml0eSddLCBwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYoZnJvbVByb2FjdGl2aXR5KSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpdmVDb25uZWN0Q29uc3RyYWludHNUb01sZGV2KGFwaUNsaWVudCwgZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydtb2RlbCddKTtcbiAgICBpZiAoZnJvbU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2V0dXAnLCAnbW9kZWwnXSwgdE1vZGVsKGFwaUNsaWVudCwgZnJvbU1vZGVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NvbmZpZyddKTtcbiAgICBpZiAoZnJvbUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbmZpZyddLCBsaXZlQ29ubmVjdENvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbXVsdGlTcGVha2VyVm9pY2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyVm9pY2VDb25maWdzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3BlYWtlclZvaWNlQ29uZmlncycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TcGVha2VyVm9pY2VDb25maWdzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21TcGVha2VyVm9pY2VDb25maWdzO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwZWFrZXJWb2ljZUNvbmZpZ1RvTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzcGVha2VyVm9pY2VDb25maWdzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnRUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21WaWRlb01ldGFkYXRhID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmlkZW9NZXRhZGF0YScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21WaWRlb01ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndmlkZW9NZXRhZGF0YSddLCB2aWRlb01ldGFkYXRhVG9NbGRldihmcm9tVmlkZW9NZXRhZGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGhvdWdodCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGhvdWdodCddKTtcbiAgICBpZiAoZnJvbVRob3VnaHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0aG91Z2h0J10sIGZyb21UaG91Z2h0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUlubGluZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2lubGluZURhdGEnXSk7XG4gICAgaWYgKGZyb21JbmxpbmVEYXRhICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaW5saW5lRGF0YSddLCBibG9iVG9NbGRldihmcm9tSW5saW5lRGF0YSkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsZURhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2ZpbGVEYXRhJ10pO1xuICAgIGlmIChmcm9tRmlsZURhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmaWxlRGF0YSddLCBmaWxlRGF0YVRvTWxkZXYoZnJvbUZpbGVEYXRhKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaG91Z2h0U2lnbmF0dXJlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndGhvdWdodFNpZ25hdHVyZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21UaG91Z2h0U2lnbmF0dXJlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhvdWdodFNpZ25hdHVyZSddLCBmcm9tVGhvdWdodFNpZ25hdHVyZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21GdW5jdGlvbkNhbGwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddKTtcbiAgICBpZiAoZnJvbUZ1bmN0aW9uQ2FsbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uQ2FsbCddLCBmdW5jdGlvbkNhbGxUb01sZGV2KGZyb21GdW5jdGlvbkNhbGwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uUmVzdWx0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb25SZXN1bHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uUmVzdWx0J10sIGZyb21Db2RlRXhlY3V0aW9uUmVzdWx0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4ZWN1dGFibGVDb2RlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZXhlY3V0YWJsZUNvZGUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRXhlY3V0YWJsZUNvZGUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydleGVjdXRhYmxlQ29kZSddLCBmcm9tRXhlY3V0YWJsZUNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRnVuY3Rpb25SZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2Z1bmN0aW9uUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25SZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Z1bmN0aW9uUmVzcG9uc2UnXSwgZnJvbUZ1bmN0aW9uUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVGV4dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dCddKTtcbiAgICBpZiAoZnJvbVRleHQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0ZXh0J10sIGZyb21UZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gcHJlYnVpbHRWb2ljZUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndm9pY2VOYW1lJ10pO1xuICAgIGlmIChmcm9tVm9pY2VOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VOYW1lJ10sIGZyb21Wb2ljZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBwcm9hY3Rpdml0eUNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVByb2FjdGl2ZUF1ZGlvID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJvYWN0aXZlQXVkaW8nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJvYWN0aXZlQXVkaW8gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcm9hY3RpdmVBdWRpbyddLCBmcm9tUHJvYWN0aXZlQXVkaW8pO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiByZWFsdGltZUlucHV0Q29uZmlnVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21BdXRvbWF0aWNBY3Rpdml0eURldGVjdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2F1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uJ10sIGF1dG9tYXRpY0FjdGl2aXR5RGV0ZWN0aW9uVG9NbGRldihmcm9tQXV0b21hdGljQWN0aXZpdHlEZXRlY3Rpb24pKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUFjdGl2aXR5SGFuZGxpbmcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdhY3Rpdml0eUhhbmRsaW5nJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUFjdGl2aXR5SGFuZGxpbmcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydhY3Rpdml0eUhhbmRsaW5nJ10sIGZyb21BY3Rpdml0eUhhbmRsaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1cm5Db3ZlcmFnZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVybkNvdmVyYWdlJ10pO1xuICAgIGlmIChmcm9tVHVybkNvdmVyYWdlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVybkNvdmVyYWdlJ10sIGZyb21UdXJuQ292ZXJhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzZXNzaW9uUmVzdW1wdGlvbkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUhhbmRsZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnaGFuZGxlJ10pO1xuICAgIGlmIChmcm9tSGFuZGxlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnaGFuZGxlJ10sIGZyb21IYW5kbGUpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0cmFuc3BhcmVudCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhbnNwYXJlbnQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gc2xpZGluZ1dpbmRvd1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRhcmdldFRva2VucyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10pO1xuICAgIGlmIChmcm9tVGFyZ2V0VG9rZW5zICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGFyZ2V0VG9rZW5zJ10sIGZyb21UYXJnZXRUb2tlbnMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBzcGVha2VyVm9pY2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TcGVha2VyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzcGVha2VyJ10pO1xuICAgIGlmIChmcm9tU3BlYWtlciAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NwZWFrZXInXSwgZnJvbVNwZWFrZXIpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ZvaWNlQ29uZmlnJ10pO1xuICAgIGlmIChmcm9tVm9pY2VDb25maWcgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd2b2ljZUNvbmZpZyddLCB2b2ljZUNvbmZpZ1RvTWxkZXYoZnJvbVZvaWNlQ29uZmlnKSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHNwZWVjaENvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2b2ljZUNvbmZpZyddKTtcbiAgICBpZiAoZnJvbVZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndm9pY2VDb25maWcnXSwgdm9pY2VDb25maWdUb01sZGV2KGZyb21Wb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdtdWx0aVNwZWFrZXJWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21NdWx0aVNwZWFrZXJWb2ljZUNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ211bHRpU3BlYWtlclZvaWNlQ29uZmlnJ10sIG11bHRpU3BlYWtlclZvaWNlQ29uZmlnVG9NbGRldihmcm9tTXVsdGlTcGVha2VyVm9pY2VDb25maWcpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUxhbmd1YWdlQ29kZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10pO1xuICAgIGlmIChmcm9tTGFuZ3VhZ2VDb2RlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbGFuZ3VhZ2VDb2RlJ10sIGZyb21MYW5ndWFnZUNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0aGlua2luZ0NvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUluY2x1ZGVUaG91Z2h0cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2luY2x1ZGVUaG91Z2h0cycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21JbmNsdWRlVGhvdWdodHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydpbmNsdWRlVGhvdWdodHMnXSwgZnJvbUluY2x1ZGVUaG91Z2h0cyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UaGlua2luZ0J1ZGdldCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3RoaW5raW5nQnVkZ2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRoaW5raW5nQnVkZ2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGhpbmtpbmdCdWRnZXQnXSwgZnJvbVRoaW5raW5nQnVkZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdG9vbFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZnVuY3Rpb25EZWNsYXJhdGlvbnMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRnVuY3Rpb25EZWNsYXJhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbUZ1bmN0aW9uRGVjbGFyYXRpb25zO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFuc2Zvcm1lZExpc3QpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lZExpc3QgPSB0cmFuc2Zvcm1lZExpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uRGVjbGFyYXRpb25Ub01sZGV2KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZnVuY3Rpb25EZWNsYXJhdGlvbnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsncmV0cmlldmFsJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXRyaWV2YWwgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUdvb2dsZVNlYXJjaCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10pO1xuICAgIGlmIChmcm9tR29vZ2xlU2VhcmNoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZ29vZ2xlU2VhcmNoJ10sIGdvb2dsZVNlYXJjaFRvTWxkZXYoZnJvbUdvb2dsZVNlYXJjaCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tR29vZ2xlU2VhcmNoUmV0cmlldmFsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZ29vZ2xlU2VhcmNoUmV0cmlldmFsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUdvb2dsZVNlYXJjaFJldHJpZXZhbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2dvb2dsZVNlYXJjaFJldHJpZXZhbCddLCBnb29nbGVTZWFyY2hSZXRyaWV2YWxUb01sZGV2KGZyb21Hb29nbGVTZWFyY2hSZXRyaWV2YWwpKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW50ZXJwcmlzZVdlYlNlYXJjaCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZW50ZXJwcmlzZVdlYlNlYXJjaCBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydnb29nbGVNYXBzJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb29nbGVNYXBzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcmxDb250ZXh0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cmxDb250ZXh0J10pO1xuICAgIGlmIChmcm9tVXJsQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VybENvbnRleHQnXSwgdXJsQ29udGV4dFRvTWxkZXYoKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21Db21wdXRlclVzZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29tcHV0ZXJVc2UnXSk7XG4gICAgaWYgKGZyb21Db21wdXRlclVzZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NvbXB1dGVyVXNlJ10sIGNvbXB1dGVyVXNlVG9NbGRldihmcm9tQ29tcHV0ZXJVc2UpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvZGVFeGVjdXRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdjb2RlRXhlY3V0aW9uJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUNvZGVFeGVjdXRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydjb2RlRXhlY3V0aW9uJ10sIGZyb21Db2RlRXhlY3V0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdXJsQ29udGV4dFRvTWxkZXYoKSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB2aWRlb01ldGFkYXRhVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tRnBzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmcHMnXSk7XG4gICAgaWYgKGZyb21GcHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydmcHMnXSwgZnJvbUZwcyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRPZmZzZXQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZE9mZnNldCddKTtcbiAgICBpZiAoZnJvbUVuZE9mZnNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZE9mZnNldCddLCBmcm9tRW5kT2Zmc2V0KTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXJ0T2Zmc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGFydE9mZnNldCddKTtcbiAgICBpZiAoZnJvbVN0YXJ0T2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRPZmZzZXQnXSwgZnJvbVN0YXJ0T2Zmc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdm9pY2VDb25maWdUb01sZGV2KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21QcmVidWlsdFZvaWNlQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAncHJlYnVpbHRWb2ljZUNvbmZpZycsXG4gICAgXSk7XG4gICAgaWYgKGZyb21QcmVidWlsdFZvaWNlQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsncHJlYnVpbHRWb2ljZUNvbmZpZyddLCBwcmVidWlsdFZvaWNlQ29uZmlnVG9NbGRldihmcm9tUHJlYnVpbHRWb2ljZUNvbmZpZykpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbi8qKlxuICogUmV0dXJucyBhIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHNldHVwIFRoZSBvYmplY3QgdG8gZXh0cmFjdCBmaWVsZCBtYXNrcyBmcm9tLlxuICogQHJldHVybiBBIGNvbW1hLXNlcGFyYXRlZCBsaXN0IG9mIGZpZWxkIG1hc2tzLlxuICovXG5mdW5jdGlvbiBnZXRGaWVsZE1hc2tzKHNldHVwKSB7XG4gICAgY29uc3QgZmllbGRzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2V0dXApIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZXR1cCwga2V5KSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzZXR1cFtrZXldO1xuICAgICAgICAgICAgLy8gMm5kIGxheWVyLCByZWN1cnNpdmVseSBnZXQgZmllbGQgbWFza3Mgc2VlIFRPRE8oYi80MTgyOTAxMDApXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoa2spID0+IGAke2tleX0uJHtra31gKTtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaCguLi5maWVsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaWVsZHMucHVzaChrZXkpOyAvLyAxc3QgbGF5ZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmllbGRzLmpvaW4oJywnKTtcbn1cbi8qKlxuICogQ29udmVydHMgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwLlxuICogQHBhcmFtIHJlcXVlc3REaWN0IC0gVGhlIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJuIC0gVGhlIG1vZGlmaWVkIHJlcXVlc3QgZGljdGlvbmFyeS5cbiAqL1xuZnVuY3Rpb24gY29udmVydEJpZGlTZXR1cFRvVG9rZW5TZXR1cChyZXF1ZXN0RGljdCwgY29uZmlnKSB7XG4gICAgLy8gQ29udmVydCBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAgZnJvbSBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAuc2V0dXAuXG4gICAgbGV0IHNldHVwRm9yTWFza0dlbmVyYXRpb24gPSBudWxsO1xuICAgIGNvbnN0IGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlID0gcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIGlmICh0eXBlb2YgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSBudWxsICYmXG4gICAgICAgICdzZXR1cCcgaW4gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUpIHtcbiAgICAgICAgLy8gTm93IHdlIGtub3cgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWUgaXMgYW4gb2JqZWN0IGFuZCBoYXMgYSAnc2V0dXAnXG4gICAgICAgIC8vIHByb3BlcnR5LlxuICAgICAgICBjb25zdCBpbm5lclNldHVwID0gYmlkaUdlbmVyYXRlQ29udGVudFNldHVwVmFsdWVcbiAgICAgICAgICAgIC5zZXR1cDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbm5lclNldHVwID09PSAnb2JqZWN0JyAmJiBpbm5lclNldHVwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBpbm5lciBzZXR1cCBmb3VuZC5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydiaWRpR2VuZXJhdGVDb250ZW50U2V0dXAnXSA9IGlubmVyU2V0dXA7XG4gICAgICAgICAgICBzZXR1cEZvck1hc2tHZW5lcmF0aW9uID0gaW5uZXJTZXR1cDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBWYWx1ZS5zZXR1cGAgaXMgbm90IGEgdmFsaWQgb2JqZWN0OyB0cmVhdCBhc1xuICAgICAgICAgICAgLy8gaWYgYmlkaUdlbmVyYXRlQ29udGVudFNldHVwIGlzIGludmFsaWQuXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gYGJpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cGAgZXhpc3RzIGJ1dCBub3QgaW4gdGhlIGV4cGVjdGVkXG4gICAgICAgIC8vIHNoYXBlIHtzZXR1cDogey4uLn19OyB0cmVhdCBhcyBpbnZhbGlkLlxuICAgICAgICBkZWxldGUgcmVxdWVzdERpY3RbJ2JpZGlHZW5lcmF0ZUNvbnRlbnRTZXR1cCddO1xuICAgIH1cbiAgICBjb25zdCBwcmVFeGlzdGluZ0ZpZWxkTWFzayA9IHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTtcbiAgICAvLyBIYW5kbGUgbWFzayBnZW5lcmF0aW9uIHNldHVwLlxuICAgIGlmIChzZXR1cEZvck1hc2tHZW5lcmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZE1hc2tGcm9tQmlkaSA9IGdldEZpZWxkTWFza3Moc2V0dXBGb3JNYXNrR2VuZXJhdGlvbik7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5sb2NrQWRkaXRpb25hbEZpZWxkcykgJiZcbiAgICAgICAgICAgIChjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHMubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAxOiBsb2NrQWRkaXRpb25hbEZpZWxkcyBpcyBhbiBlbXB0eSBhcnJheS4gTG9jayBvbmx5IGZpZWxkcyBmcm9tXG4gICAgICAgICAgICAvLyBiaWRpIHNldHVwLlxuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXNzaWduIGlmIG1hc2sgaXMgbm90IGVtcHR5XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZ2VuZXJhdGVkTWFza0Zyb21CaWRpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXTsgLy8gSWYgbWFzayBpcyBlbXB0eSwgZWZmZWN0aXZlbHkgbm9cbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBmaWVsZHMgbG9ja2VkIGJ5IGJpZGlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzKSAmJlxuICAgICAgICAgICAgY29uZmlnLmxvY2tBZGRpdGlvbmFsRmllbGRzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgIHByZUV4aXN0aW5nRmllbGRNYXNrICE9PSBudWxsICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByZUV4aXN0aW5nRmllbGRNYXNrKSAmJlxuICAgICAgICAgICAgcHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gQ2FzZSAyOiBMb2NrIGZpZWxkcyBmcm9tIGJpZGkgc2V0dXAgKyBhZGRpdGlvbmFsIGZpZWxkc1xuICAgICAgICAgICAgLy8gKHByZUV4aXN0aW5nRmllbGRNYXNrKS5cbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWdGaWVsZHMgPSBbXG4gICAgICAgICAgICAgICAgJ3RlbXBlcmF0dXJlJyxcbiAgICAgICAgICAgICAgICAndG9wSycsXG4gICAgICAgICAgICAgICAgJ3RvcFAnLFxuICAgICAgICAgICAgICAgICdtYXhPdXRwdXRUb2tlbnMnLFxuICAgICAgICAgICAgICAgICdyZXNwb25zZU1vZGFsaXRpZXMnLFxuICAgICAgICAgICAgICAgICdzZWVkJyxcbiAgICAgICAgICAgICAgICAnc3BlZWNoQ29uZmlnJyxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBsZXQgbWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nID0gW107XG4gICAgICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG1hcHBlZEZpZWxkc0Zyb21QcmVFeGlzdGluZyA9IHByZUV4aXN0aW5nRmllbGRNYXNrLm1hcCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlbmVyYXRpb25Db25maWdGaWVsZHMuaW5jbHVkZXMoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYGdlbmVyYXRpb25Db25maWcuJHtmaWVsZH1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmaWVsZDsgLy8gS2VlcCBvcmlnaW5hbCBmaWVsZCBuYW1lIGlmIG5vdCBpblxuICAgICAgICAgICAgICAgICAgICAvLyBnZW5lcmF0aW9uQ29uZmlnRmllbGRzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hc2tQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgaWYgKGdlbmVyYXRlZE1hc2tGcm9tQmlkaSkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goZ2VuZXJhdGVkTWFza0Zyb21CaWRpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXBwZWRGaWVsZHNGcm9tUHJlRXhpc3RpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbmFsTWFza1BhcnRzLnB1c2goLi4ubWFwcGVkRmllbGRzRnJvbVByZUV4aXN0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaW5hbE1hc2tQYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdERpY3RbJ2ZpZWxkTWFzayddID0gZmluYWxNYXNrUGFydHMuam9pbignLCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm8gZmllbGRzIGZyb20gYmlkaSBhbmQgbm8gdmFsaWQgYWRkaXRpb25hbCBmaWVsZHMgZnJvbVxuICAgICAgICAgICAgICAgIC8vIHByZS1leGlzdGluZyBtYXNrLlxuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDYXNlIDM6IFwiTG9jayBhbGwgZmllbGRzXCIgKG1lYW5pbmcsIGRvbid0IHNlbmQgYSBmaWVsZF9tYXNrLCBsZXQgc2VydmVyXG4gICAgICAgICAgICAvLyBkZWZhdWx0cyBhcHBseSBvciBhbGwgYXJlIG11dGFibGUpLiBUaGlzIGlzIGhpdCBpZjpcbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vICAtIGBjb25maWcubG9ja0FkZGl0aW9uYWxGaWVsZHNgIGlzIG5vbi1lbXB0eSwgQlVUXG4gICAgICAgICAgICAvLyAgYHByZUV4aXN0aW5nRmllbGRNYXNrYCBpcyBudWxsLCBub3QgYSBzdHJpbmcsIG9yIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE5vIHZhbGlkIGBiaWRpR2VuZXJhdGVDb250ZW50U2V0dXBgIHdhcyBmb3VuZCBvciBleHRyYWN0ZWQuXG4gICAgICAgIC8vIFwiTG9jayBhZGRpdGlvbmFsIG51bGwgZmllbGRzIGlmIGFueVwiLlxuICAgICAgICBpZiAocHJlRXhpc3RpbmdGaWVsZE1hc2sgIT09IG51bGwgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocHJlRXhpc3RpbmdGaWVsZE1hc2spICYmXG4gICAgICAgICAgICBwcmVFeGlzdGluZ0ZpZWxkTWFzay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgcHJlLWV4aXN0aW5nIGZpZWxkIG1hc2ssIGl0J3MgYSBzdHJpbmcsIGFuZCBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gZW1wdHksIHRoZW4gd2Ugc2hvdWxkIGxvY2sgYWxsIGZpZWxkcy5cbiAgICAgICAgICAgIHJlcXVlc3REaWN0WydmaWVsZE1hc2snXSA9IHByZUV4aXN0aW5nRmllbGRNYXNrLmpvaW4oJywnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0RGljdFsnZmllbGRNYXNrJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcXVlc3REaWN0O1xufVxuY2xhc3MgVG9rZW5zIGV4dGVuZHMgQmFzZU1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBpQ2xpZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVwaGVtZXJhbCBhdXRoIHRva2VuIHJlc291cmNlLlxuICAgICAqXG4gICAgICogQGV4cGVyaW1lbnRhbFxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBFcGhlbWVyYWwgYXV0aCB0b2tlbnMgaXMgb25seSBzdXBwb3J0ZWQgaW4gdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLlxuICAgICAqIEl0IGNhbiBiZSB1c2VkIGZvciB0aGUgc2Vzc2lvbiBjb25uZWN0aW9uIHRvIHRoZSBMaXZlIGNvbnN0cmFpbmVkIEFQSS5cbiAgICAgKiBTdXBwb3J0IGluIHYxYWxwaGEgb25seS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNyZWF0ZSByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGNyZWF0ZWQgYXV0aCB0b2tlbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBhaSA9IG5ldyBHb29nbGVHZW5BSSh7XG4gICAgICogICAgIGFwaUtleTogdG9rZW4ubmFtZSxcbiAgICAgKiAgICAgaHR0cE9wdGlvbnM6IHsgYXBpVmVyc2lvbjogJ3YxYWxwaGEnIH0gIC8vIFN1cHBvcnQgaW4gdjFhbHBoYSBvbmx5LlxuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogLy8gQ2FzZSAxOiBJZiBMaXZlRXBoZW1lcmFsUGFyYW1ldGVycyBpcyB1bnNldCwgdW5sb2NrIExpdmVDb25uZWN0Q29uZmlnXG4gICAgICogLy8gd2hlbiB1c2luZyB0aGUgdG9rZW4gaW4gTGl2ZSBBUEkgc2Vzc2lvbnMuIEVhY2ggc2Vzc2lvbiBjb25uZWN0aW9uIGNhblxuICAgICAqIC8vIHVzZSBhIGRpZmZlcmVudCBjb25maWd1cmF0aW9uLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID0ge1xuICAgICAqICAgICB1c2VzOiAzLFxuICAgICAqICAgICBleHBpcmVUaW1lOiAnMjAyNS0wNS0wMVQwMDowMDowMFonLFxuICAgICAqIH1cbiAgICAgKiBjb25zdCB0b2tlbiA9IGF3YWl0IGFpLnRva2Vucy5jcmVhdGUoY29uZmlnKTtcbiAgICAgKlxuICAgICAqIC8vIENhc2UgMjogSWYgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnMgaXMgc2V0LCBsb2NrIGFsbCBmaWVsZHMgaW5cbiAgICAgKiAvLyBMaXZlQ29ubmVjdENvbmZpZyB3aGVuIHVzaW5nIHRoZSB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy4gRm9yXG4gICAgICogLy8gZXhhbXBsZSwgY2hhbmdpbmcgYG91dHB1dEF1ZGlvVHJhbnNjcmlwdGlvbmAgaW4gdGhlIExpdmUgQVBJXG4gICAgICogLy8gY29ubmVjdGlvbiB3aWxsIGJlIGlnbm9yZWQgYnkgdGhlIEFQSS5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDM6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBzZXQsIGxvY2sgTGl2ZUNvbm5lY3RDb25maWcgd2l0aCBzZXQgYW5kIGFkZGl0aW9uYWwgZmllbGRzIChlLmcuXG4gICAgICogLy8gcmVzcG9uc2VNb2RhbGl0aWVzLCBzeXN0ZW1JbnN0cnVjdGlvbiwgdGVtcGVyYXR1cmUgaW4gdGhpcyBleGFtcGxlKSB3aGVuXG4gICAgICogLy8gdXNpbmcgdGhlIHRva2VuIGluIExpdmUgQVBJIHNlc3Npb25zLlxuICAgICAqIGNvbnN0IGNvbmZpZzogQ3JlYXRlQXV0aFRva2VuQ29uZmlnID1cbiAgICAgKiAgICAgdXNlczogMyxcbiAgICAgKiAgICAgZXhwaXJlVGltZTogJzIwMjUtMDUtMDFUMDA6MDA6MDBaJyxcbiAgICAgKiAgICAgTGl2ZUVwaGVtZXJhbFBhcmFtZXRlcnM6IHtcbiAgICAgKiAgICAgICAgbW9kZWw6ICdnZW1pbmktMi4wLWZsYXNoLTAwMScsXG4gICAgICogICAgICAgIGNvbmZpZzoge1xuICAgICAqICAgICAgICAgICAncmVzcG9uc2VNb2RhbGl0aWVzJzogWydBVURJTyddLFxuICAgICAqICAgICAgICAgICAnc3lzdGVtSW5zdHJ1Y3Rpb24nOiAnQWx3YXlzIGFuc3dlciBpbiBFbmdsaXNoLicsXG4gICAgICogICAgICAgIH1cbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgbG9ja0FkZGl0aW9uYWxGaWVsZHM6IFsndGVtcGVyYXR1cmUnXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICpcbiAgICAgKiAvLyBDYXNlIDQ6IElmIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzIGlzIHNldCBhbmQgbG9ja0FkZGl0aW9uYWxGaWVsZHMgaXNcbiAgICAgKiAvLyBlbXB0eSBhcnJheSwgbG9jayBMaXZlQ29ubmVjdENvbmZpZyB3aXRoIHNldCBmaWVsZHMgKGUuZy5cbiAgICAgKiAvLyByZXNwb25zZU1vZGFsaXRpZXMsIHN5c3RlbUluc3RydWN0aW9uIGluIHRoaXMgZXhhbXBsZSkgd2hlbiB1c2luZyB0aGVcbiAgICAgKiAvLyB0b2tlbiBpbiBMaXZlIEFQSSBzZXNzaW9ucy5cbiAgICAgKiBjb25zdCBjb25maWc6IENyZWF0ZUF1dGhUb2tlbkNvbmZpZyA9XG4gICAgICogICAgIHVzZXM6IDMsXG4gICAgICogICAgIGV4cGlyZVRpbWU6ICcyMDI1LTA1LTAxVDAwOjAwOjAwWicsXG4gICAgICogICAgIExpdmVFcGhlbWVyYWxQYXJhbWV0ZXJzOiB7XG4gICAgICogICAgICAgIG1vZGVsOiAnZ2VtaW5pLTIuMC1mbGFzaC0wMDEnLFxuICAgICAqICAgICAgICBjb25maWc6IHtcbiAgICAgKiAgICAgICAgICAgJ3Jlc3BvbnNlTW9kYWxpdGllcyc6IFsnQVVESU8nXSxcbiAgICAgKiAgICAgICAgICAgJ3N5c3RlbUluc3RydWN0aW9uJzogJ0Fsd2F5cyBhbnN3ZXIgaW4gRW5nbGlzaC4nLFxuICAgICAqICAgICAgICB9XG4gICAgICogICAgIH0sXG4gICAgICogICAgIGxvY2tBZGRpdGlvbmFsRmllbGRzOiBbXSxcbiAgICAgKiB9XG4gICAgICogY29uc3QgdG9rZW4gPSBhd2FpdCBhaS50b2tlbnMuY3JlYXRlKGNvbmZpZyk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY3JlYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBjbGllbnQudG9rZW5zLmNyZWF0ZSBtZXRob2QgaXMgb25seSBzdXBwb3J0ZWQgYnkgdGhlIEdlbWluaSBEZXZlbG9wZXIgQVBJLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZUF1dGhUb2tlblBhcmFtZXRlcnNUb01sZGV2KHRoaXMuYXBpQ2xpZW50LCBwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgnYXV0aF90b2tlbnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5Wydjb25maWcnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJvZHkgPSBjb252ZXJ0QmlkaVNldHVwVG9Ub2tlblNldHVwKGJvZHksIHBhcmFtcy5jb25maWcpO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF1dGhUb2tlbkZyb21NbGRldihhcGlSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgR09PR0xFX0FQSV9LRVlfSEVBREVSID0gJ3gtZ29vZy1hcGkta2V5JztcbmNvbnN0IFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSA9ICdodHRwczovL3d3dy5nb29nbGVhcGlzLmNvbS9hdXRoL2Nsb3VkLXBsYXRmb3JtJztcbmNsYXNzIE5vZGVBdXRoIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFwaUtleSA9IG9wdHMuYXBpS2V5O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZlcnRleEF1dGhPcHRpb25zID0gYnVpbGRHb29nbGVBdXRoT3B0aW9ucyhvcHRzLmdvb2dsZUF1dGhPcHRpb25zKTtcbiAgICAgICAgdGhpcy5nb29nbGVBdXRoID0gbmV3IEdvb2dsZUF1dGgodmVydGV4QXV0aE9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBhZGRBdXRoSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlLZXkuc3RhcnRzV2l0aCgnYXV0aF90b2tlbnMvJykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VwaGVtZXJhbCB0b2tlbnMgYXJlIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBsaXZlIEFQSS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWRkS2V5SGVhZGVyKGhlYWRlcnMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH1cbiAgICBhZGRLZXlIZWFkZXIoaGVhZGVycykge1xuICAgICAgICBpZiAoaGVhZGVycy5nZXQoR09PR0xFX0FQSV9LRVlfSEVBREVSKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFwaUtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIHRoaXMgbWV0aG9kIGlzIG9ubHkgY2FsbGVkXG4gICAgICAgICAgICAvLyB3aGVuIGFwaUtleSBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgQVBJIGtleSBoZWFkZXIgYnV0IGFwaUtleSBpcyBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaGVhZGVycy5hcHBlbmQoR09PR0xFX0FQSV9LRVlfSEVBREVSLCB0aGlzLmFwaUtleSk7XG4gICAgfVxuICAgIGFzeW5jIGFkZEdvb2dsZUF1dGhIZWFkZXJzKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZ29vZ2xlQXV0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4sIGFkZEdvb2dsZUF1dGhIZWFkZXJzIHNob3VsZCBvbmx5IGJlXG4gICAgICAgICAgICAvLyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhcGlLZXkgc2V0IGFuZCBpbiB0aGVzZSBjYXNlcyBnb29nbGVBdXRoXG4gICAgICAgICAgICAvLyBpcyBzZXQuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBzZXQgZ29vZ2xlLWF1dGggaGVhZGVycyBidXQgZ29vZ2xlQXV0aCBpcyB1bnNldCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGF1dGhIZWFkZXJzID0gYXdhaXQgdGhpcy5nb29nbGVBdXRoLmdldFJlcXVlc3RIZWFkZXJzKCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGF1dGhIZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoaGVhZGVycy5nZXQoa2V5KSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCBhdXRoSGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkR29vZ2xlQXV0aE9wdGlvbnMoZ29vZ2xlQXV0aE9wdGlvbnMpIHtcbiAgICBsZXQgYXV0aE9wdGlvbnM7XG4gICAgaWYgKCFnb29nbGVBdXRoT3B0aW9ucykge1xuICAgICAgICBhdXRoT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHNjb3BlczogW1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRV0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGF1dGhPcHRpb25zID0gZ29vZ2xlQXV0aE9wdGlvbnM7XG4gICAgICAgIGlmICghYXV0aE9wdGlvbnMuc2NvcGVzKSB7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucy5zY29wZXMgPSBbUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFXTtcbiAgICAgICAgICAgIHJldHVybiBhdXRoT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodHlwZW9mIGF1dGhPcHRpb25zLnNjb3BlcyA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3BlcyAhPT0gUkVRVUlSRURfVkVSVEVYX0FJX1NDT1BFKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoYXV0aE9wdGlvbnMuc2NvcGVzKSAmJlxuICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLnNjb3Blcy5pbmRleE9mKFJFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRSkgPCAwKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF1dGggc2NvcGVzLiBTY29wZXMgbXVzdCBpbmNsdWRlOiAke1JFUVVJUkVEX1ZFUlRFWF9BSV9TQ09QRX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXV0aE9wdGlvbnM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlRG93bmxvYWRlciB7XG4gICAgYXN5bmMgZG93bmxvYWQocGFyYW1zLCBhcGlDbGllbnQpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5kb3dubG9hZFBhdGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdyaXRlciA9IGNyZWF0ZVdyaXRlU3RyZWFtKHBhcmFtcy5kb3dubG9hZFBhdGgpO1xuICAgICAgICAgICAgICAgIFJlYWRhYmxlLmZyb21XZWIocmVzcG9uc2UucmVzcG9uc2VJbnRlcm5hbC5ib2R5KS5waXBlKHdyaXRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZUZpbGUocGFyYW1zLmRvd25sb2FkUGF0aCwgcmVzcG9uc2UsIHsgZW5jb2Rpbmc6ICdiYXNlNjQnIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHdyaXRlIGZpbGUgdG8gJHtwYXJhbXMuZG93bmxvYWRQYXRofTogJHtlcnJvcn1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWRGaWxlKHBhcmFtcywgYXBpQ2xpZW50KSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgbmFtZSA9IHRGaWxlTmFtZShwYXJhbXMuZmlsZSk7XG4gICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgcGF0aDogYGZpbGVzLyR7bmFtZX06ZG93bmxvYWRgLFxuICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICBxdWVyeVBhcmFtczoge1xuICAgICAgICAgICAgICAgICdhbHQnOiAnbWVkaWEnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNHZW5lcmF0ZWRWaWRlbyhwYXJhbXMuZmlsZSkpIHtcbiAgICAgICAgY29uc3QgdmlkZW9CeXRlcyA9IChfYyA9IHBhcmFtcy5maWxlLnZpZGVvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmlkZW9CeXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0J5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCBnZW5lcmF0ZWQgdmlkZW8sIFVyaSBvciB2aWRlb0J5dGVzIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZpZGVvKHBhcmFtcy5maWxlKSkge1xuICAgICAgICBjb25zdCB2aWRlb0J5dGVzID0gcGFyYW1zLmZpbGUudmlkZW9CeXRlcztcbiAgICAgICAgaWYgKHR5cGVvZiB2aWRlb0J5dGVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZpZGVvQnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBkb3dubG9hZCB2aWRlbywgVXJpIG9yIHZpZGVvQnl0ZXMgbm90IGZvdW5kLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIGZpbGUgdHlwZScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgTm9kZVdlYlNvY2tldEZhY3Rvcnkge1xuICAgIGNyZWF0ZSh1cmwsIGhlYWRlcnMsIGNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVXZWJTb2NrZXQodXJsLCBoZWFkZXJzLCBjYWxsYmFja3MpO1xuICAgIH1cbn1cbmNsYXNzIE5vZGVXZWJTb2NrZXQge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgaGVhZGVycywgY2FsbGJhY2tzKSB7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy53cyA9IG5ldyBOb2RlV3MuV2ViU29ja2V0KHRoaXMudXJsLCB7IGhlYWRlcnM6IHRoaXMuaGVhZGVycyB9KTtcbiAgICAgICAgdGhpcy53cy5vbm9wZW4gPSB0aGlzLmNhbGxiYWNrcy5vbm9wZW47XG4gICAgICAgIHRoaXMud3Mub25lcnJvciA9IHRoaXMuY2FsbGJhY2tzLm9uZXJyb3I7XG4gICAgICAgIHRoaXMud3Mub25jbG9zZSA9IHRoaXMuY2FsbGJhY2tzLm9uY2xvc2U7XG4gICAgICAgIHRoaXMud3Mub25tZXNzYWdlID0gdGhpcy5jYWxsYmFja3Mub25tZXNzYWdlO1xuICAgIH1cbiAgICBzZW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMud3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IGNvbm5lY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud3Muc2VuZChtZXNzYWdlKTtcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLndzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgR29vZ2xlIEdlbiBBSSBTREsgZ2VuZXJhdG9yIERPIE5PVCBFRElULlxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ191cmwnLCAnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvTWxkZXYoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBpZiAoZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd2YWxpZGF0aW9uRGF0YXNldCddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndmFsaWRhdGlvbkRhdGFzZXQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnZGlzcGxheU5hbWUnXSwgZnJvbVR1bmVkTW9kZWxEaXNwbGF5TmFtZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZXNjcmlwdGlvbiBwYXJhbWV0ZXIgaXMgbm90IHN1cHBvcnRlZCBpbiBHZW1pbmkgQVBJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXBvY2hDb3VudCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXBvY2hDb3VudCddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUVwb2NoQ291bnQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgXSk7XG4gICAgaWYgKGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuaW5nVGFzaycsICdoeXBlcnBhcmFtZXRlcnMnLCAnbGVhcm5pbmdSYXRlTXVsdGlwbGllciddLCBmcm9tTGVhcm5pbmdSYXRlTXVsdGlwbGllcik7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cG9ydExhc3RDaGVja3BvaW50T25seSddKSAhPT1cbiAgICAgICAgdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5IHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQnXSkgIT09XG4gICAgICAgIHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYWRhcHRlclNpemUnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FkYXB0ZXJTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXRjaFNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JhdGNoU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUJhdGNoU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdiYXRjaFNpemUnXSwgZnJvbUJhdGNoU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xlYXJuaW5nUmF0ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUxlYXJuaW5nUmF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWyd0dW5pbmdUYXNrJywgJ2h5cGVycGFyYW1ldGVycycsICdsZWFybmluZ1JhdGUnXSwgZnJvbUxlYXJuaW5nUmF0ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbGFiZWxzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIEdlbWluaSBBUEkuJyk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYkNvbmZpZ1RvVmVydGV4KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVZhbGlkYXRpb25EYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmFsaWRhdGlvbkRhdGFzZXQnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmFsaWRhdGlvbkRhdGFzZXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnXSwgdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tVmFsaWRhdGlvbkRhdGFzZXQsIHRvT2JqZWN0KSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3R1bmVkTW9kZWxEaXNwbGF5TmFtZSddLCBmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbURlc2NyaXB0aW9uID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydkZXNjcmlwdGlvbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbURlc2NyaXB0aW9uICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FcG9jaENvdW50ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaENvdW50J10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRXBvY2hDb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICdoeXBlclBhcmFtZXRlcnMnLCAnZXBvY2hDb3VudCddLCBmcm9tRXBvY2hDb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnbGVhcm5pbmdSYXRlTXVsdGlwbGllcicsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ2h5cGVyUGFyYW1ldGVycycsICdsZWFybmluZ1JhdGVNdWx0aXBsaWVyJ10sIGZyb21MZWFybmluZ1JhdGVNdWx0aXBsaWVyKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cG9ydExhc3RDaGVja3BvaW50T25seSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ2V4cG9ydExhc3RDaGVja3BvaW50T25seScsXG4gICAgXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnZXhwb3J0TGFzdENoZWNrcG9pbnRPbmx5J10sIGZyb21FeHBvcnRMYXN0Q2hlY2twb2ludE9ubHkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQWRhcHRlclNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2FkYXB0ZXJTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tQWRhcHRlclNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLCAnaHlwZXJQYXJhbWV0ZXJzJywgJ2FkYXB0ZXJTaXplJ10sIGZyb21BZGFwdGVyU2l6ZSk7XG4gICAgfVxuICAgIGlmIChnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2JhdGNoU2l6ZSddKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmF0Y2hTaXplIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbGVhcm5pbmdSYXRlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsZWFybmluZ1JhdGUgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gVmVydGV4IEFJLicpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTGFiZWxzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydsYWJlbHMnXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21MYWJlbHMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnbGFiZWxzJ10sIGZyb21MYWJlbHMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ1Rhc2snLCAndHJhaW5pbmdEYXRhJ10sIHR1bmluZ0RhdGFzZXRUb01sZGV2KGZyb21UcmFpbmluZ0RhdGFzZXQpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9NbGRldihmcm9tQ29uZmlnLCB0b09iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbUJhc2VNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnYmFzZU1vZGVsJ10pO1xuICAgIGlmIChmcm9tQmFzZU1vZGVsICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnYmFzZU1vZGVsJ10sIGZyb21CYXNlTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUHJlVHVuZWRNb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3ByZVR1bmVkTW9kZWwnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUHJlVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ByZVR1bmVkTW9kZWwnXSwgZnJvbVByZVR1bmVkTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHJhaW5pbmdEYXRhc2V0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHJhaW5pbmdEYXRhc2V0JyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVRyYWluaW5nRGF0YXNldCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCB0dW5pbmdEYXRhc2V0VG9WZXJ0ZXgoZnJvbVRyYWluaW5nRGF0YXNldCwgdG9PYmplY3QpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNvbmZpZyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY29uZmlnJ10pO1xuICAgIGlmIChmcm9tQ29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgY3JlYXRlVHVuaW5nSm9iQ29uZmlnVG9WZXJ0ZXgoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydfdXJsJywgJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBnZXRUdW5pbmdKb2JQYXJhbWV0ZXJzVG9WZXJ0ZXgoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnX3VybCcsICduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNDb25maWdUb01sZGV2KGZyb21PYmplY3QsIHBhcmVudE9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVBhZ2VTaXplID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlU2l6ZSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VTaXplICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdwYWdlU2l6ZSddLCBmcm9tUGFnZVNpemUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFnZVRva2VuID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydwYWdlVG9rZW4nXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21QYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VUb2tlbiddLCBmcm9tUGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUZpbHRlciA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZmlsdGVyJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ19xdWVyeScsICdmaWx0ZXInXSwgZnJvbUZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzQ29uZmlnVG9WZXJ0ZXgoZnJvbU9iamVjdCwgcGFyZW50T2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tUGFnZVNpemUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VTaXplJ10pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tUGFnZVNpemUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ3BhZ2VTaXplJ10sIGZyb21QYWdlU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21QYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BhZ2VUb2tlbiddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydfcXVlcnknLCAncGFnZVRva2VuJ10sIGZyb21QYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRmlsdGVyID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydmaWx0ZXInXSk7XG4gICAgaWYgKHBhcmVudE9iamVjdCAhPT0gdW5kZWZpbmVkICYmIGZyb21GaWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aChwYXJlbnRPYmplY3QsIFsnX3F1ZXJ5JywgJ2ZpbHRlciddLCBmcm9tRmlsdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvTWxkZXYoZnJvbUNvbmZpZywgdG9PYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiBsaXN0VHVuaW5nSm9ic1BhcmFtZXRlcnNUb1ZlcnRleChmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tQ29uZmlnID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjb25maWcnXSk7XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgICBsaXN0VHVuaW5nSm9ic0NvbmZpZ1RvVmVydGV4KGZyb21Db25maWcsIHRvT2JqZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gbGlzdFR1bmluZ0pvYnNSZXNwb25zZUZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5leHRQYWdlVG9rZW4gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICduZXh0UGFnZVRva2VuJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbU5leHRQYWdlVG9rZW4gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduZXh0UGFnZVRva2VuJ10sIGZyb21OZXh0UGFnZVRva2VuKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmluZ0pvYnMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3R1bmVkTW9kZWxzJ10pO1xuICAgIGlmIChmcm9tVHVuaW5nSm9icyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tVHVuaW5nSm9icztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdKb2JGcm9tTWxkZXYoaXRlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyd0dW5pbmdKb2JzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmV4dFBhZ2VUb2tlbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ25leHRQYWdlVG9rZW4nLFxuICAgIF0pO1xuICAgIGlmIChmcm9tTmV4dFBhZ2VUb2tlbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25leHRQYWdlVG9rZW4nXSwgZnJvbU5leHRQYWdlVG9rZW4pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nSm9icyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndHVuaW5nSm9icyddKTtcbiAgICBpZiAoZnJvbVR1bmluZ0pvYnMgIT0gbnVsbCkge1xuICAgICAgICBsZXQgdHJhbnNmb3JtZWRMaXN0ID0gZnJvbVR1bmluZ0pvYnM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iRnJvbVZlcnRleChpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0pvYnMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuZWRNb2RlbENoZWNrcG9pbnRGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21DaGVja3BvaW50SWQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NoZWNrcG9pbnRJZCddKTtcbiAgICBpZiAoZnJvbUNoZWNrcG9pbnRJZCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NoZWNrcG9pbnRJZCddLCBmcm9tQ2hlY2twb2ludElkKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVwb2NoID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcG9jaCddKTtcbiAgICBpZiAoZnJvbUVwb2NoICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXBvY2gnXSwgZnJvbUVwb2NoKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0ZXAgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0ZXAnXSk7XG4gICAgaWYgKGZyb21TdGVwICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RlcCddLCBmcm9tU3RlcCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kcG9pbnQnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50J10sIGZyb21FbmRwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxGcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtb2RlbCddLCBmcm9tTW9kZWwpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kcG9pbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50J10sIGZyb21FbmRwb2ludCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmVkTW9kZWxGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21Nb2RlbCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbW9kZWwnXSk7XG4gICAgaWYgKGZyb21Nb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ21vZGVsJ10sIGZyb21Nb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21FbmRwb2ludCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZW5kcG9pbnQnXSk7XG4gICAgaWYgKGZyb21FbmRwb2ludCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2VuZHBvaW50J10sIGZyb21FbmRwb2ludCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DaGVja3BvaW50cyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnY2hlY2twb2ludHMnXSk7XG4gICAgaWYgKGZyb21DaGVja3BvaW50cyAhPSBudWxsKSB7XG4gICAgICAgIGxldCB0cmFuc2Zvcm1lZExpc3QgPSBmcm9tQ2hlY2twb2ludHM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRyYW5zZm9ybWVkTGlzdCkpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybWVkTGlzdCA9IHRyYW5zZm9ybWVkTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuZWRNb2RlbENoZWNrcG9pbnRGcm9tVmVydGV4KGl0ZW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY2hlY2twb2ludHMnXSwgdHJhbnNmb3JtZWRMaXN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRGF0YXNldFRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZ2NzVXJpJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnY3NVcmkgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndmVydGV4RGF0YXNldFJlc291cmNlJ10pICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgcGFyYW1ldGVyIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2VtaW5pIEFQSS4nKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4YW1wbGVzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydleGFtcGxlcyddKTtcbiAgICBpZiAoZnJvbUV4YW1wbGVzICE9IG51bGwpIHtcbiAgICAgICAgbGV0IHRyYW5zZm9ybWVkTGlzdCA9IGZyb21FeGFtcGxlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodHJhbnNmb3JtZWRMaXN0KSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtZWRMaXN0ID0gdHJhbnNmb3JtZWRMaXN0Lm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0dW5pbmdFeGFtcGxlVG9NbGRldihpdGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2V4YW1wbGVzJywgJ2V4YW1wbGVzJ10sIHRyYW5zZm9ybWVkTGlzdCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0RhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbUdjc1VyaSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21WZXJ0ZXhEYXRhc2V0UmVzb3VyY2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd2ZXJ0ZXhEYXRhc2V0UmVzb3VyY2UnLFxuICAgIF0pO1xuICAgIGlmIChwYXJlbnRPYmplY3QgIT09IHVuZGVmaW5lZCAmJiBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgocGFyZW50T2JqZWN0LCBbJ3N1cGVydmlzZWRUdW5pbmdTcGVjJywgJ3RyYWluaW5nRGF0YXNldFVyaSddLCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlKTtcbiAgICB9XG4gICAgaWYgKGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZXhhbXBsZXMnXSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4YW1wbGVzIHBhcmFtZXRlciBpcyBub3Qgc3VwcG9ydGVkIGluIFZlcnRleCBBSS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nRXhhbXBsZVRvTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVRleHRJbnB1dCA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsndGV4dElucHV0J10pO1xuICAgIGlmIChmcm9tVGV4dElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndGV4dElucHV0J10sIGZyb21UZXh0SW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tT3V0cHV0ID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydvdXRwdXQnXSk7XG4gICAgaWYgKGZyb21PdXRwdXQgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydvdXRwdXQnXSwgZnJvbU91dHB1dCk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cbmZ1bmN0aW9uIHR1bmluZ0pvYkZyb21NbGRldihmcm9tT2JqZWN0KSB7XG4gICAgY29uc3QgdG9PYmplY3QgPSB7fTtcbiAgICBjb25zdCBmcm9tU2RrSHR0cFJlc3BvbnNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc2RrSHR0cFJlc3BvbnNlJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVNka0h0dHBSZXNwb25zZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Nka0h0dHBSZXNwb25zZSddLCBmcm9tU2RrSHR0cFJlc3BvbnNlKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ25hbWUnXSk7XG4gICAgaWYgKGZyb21OYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnbmFtZSddLCBmcm9tTmFtZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGF0ZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnc3RhdGUnXSk7XG4gICAgaWYgKGZyb21TdGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXRlJ10sIHRUdW5pbmdKb2JTdGF0dXMoZnJvbVN0YXRlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21DcmVhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydjcmVhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tQ3JlYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSwgZnJvbUNyZWF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU3RhcnRUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nVGFzaycsXG4gICAgICAgICdzdGFydFRpbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3RhcnRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhcnRUaW1lJ10sIGZyb21TdGFydFRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRW5kVGltZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3R1bmluZ1Rhc2snLFxuICAgICAgICAnY29tcGxldGVUaW1lJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUVuZFRpbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmRUaW1lJ10sIGZyb21FbmRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVVwZGF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21VcGRhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndXBkYXRlVGltZSddLCBmcm9tVXBkYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21EZXNjcmlwdGlvbiA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZGVzY3JpcHRpb24nXSk7XG4gICAgaWYgKGZyb21EZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10sIGZyb21EZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IGZyb21CYXNlTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Jhc2VNb2RlbCddKTtcbiAgICBpZiAoZnJvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2Jhc2VNb2RlbCddLCBmcm9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ19zZWxmJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21NbGRldihmcm9tVHVuZWRNb2RlbCkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tQmFzZU1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUN1c3RvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2N1c3RvbUJhc2VNb2RlbCddLCBmcm9tQ3VzdG9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGVyaW1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSk7XG4gICAgaWYgKGZyb21FeHBlcmltZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwZXJpbWVudCddLCBmcm9tRXhwZXJpbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0VXJpJ10pO1xuICAgIGlmIChmcm9tT3V0cHV0VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VXJpJ10sIGZyb21PdXRwdXRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGlwZWxpbmVKb2IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10pO1xuICAgIGlmIChmcm9tUGlwZWxpbmVKb2IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwaXBlbGluZUpvYiddLCBmcm9tUGlwZWxpbmVKb2IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmljZUFjY291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2aWNlQWNjb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2aWNlQWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZpY2VBY2NvdW50J10sIGZyb21TZXJ2aWNlQWNjb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVvVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Zlb1R1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVvVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Zlb1R1bmluZ1NwZWMnXSwgZnJvbVZlb1R1bmluZ1NwZWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdKb2JGcm9tVmVydGV4KGZyb21PYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21TZGtIdHRwUmVzcG9uc2UgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZGtIdHRwUmVzcG9uc2UnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU2RrSHR0cFJlc3BvbnNlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc2RrSHR0cFJlc3BvbnNlJ10sIGZyb21TZGtIdHRwUmVzcG9uc2UpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTmFtZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnbmFtZSddKTtcbiAgICBpZiAoZnJvbU5hbWUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWyduYW1lJ10sIGZyb21OYW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN0YXRlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydzdGF0ZSddKTtcbiAgICBpZiAoZnJvbVN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnc3RhdGUnXSwgdFR1bmluZ0pvYlN0YXR1cyhmcm9tU3RhdGUpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUNyZWF0ZVRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2NyZWF0ZVRpbWUnXSk7XG4gICAgaWYgKGZyb21DcmVhdGVUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnY3JlYXRlVGltZSddLCBmcm9tQ3JlYXRlVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21TdGFydFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3N0YXJ0VGltZSddKTtcbiAgICBpZiAoZnJvbVN0YXJ0VGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3N0YXJ0VGltZSddLCBmcm9tU3RhcnRUaW1lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuZFRpbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2VuZFRpbWUnXSk7XG4gICAgaWYgKGZyb21FbmRUaW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZW5kVGltZSddLCBmcm9tRW5kVGltZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21VcGRhdGVUaW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd1cGRhdGVUaW1lJ10pO1xuICAgIGlmIChmcm9tVXBkYXRlVGltZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3VwZGF0ZVRpbWUnXSwgZnJvbVVwZGF0ZVRpbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRXJyb3IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Vycm9yJ10pO1xuICAgIGlmIChmcm9tRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlcnJvciddLCBmcm9tRXJyb3IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRGVzY3JpcHRpb24gPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2Rlc2NyaXB0aW9uJ10pO1xuICAgIGlmIChmcm9tRGVzY3JpcHRpb24gIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkZXNjcmlwdGlvbiddLCBmcm9tRGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydiYXNlTW9kZWwnXSk7XG4gICAgaWYgKGZyb21CYXNlTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydiYXNlTW9kZWwnXSwgZnJvbUJhc2VNb2RlbCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyd0dW5lZE1vZGVsJ10pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmVkTW9kZWwnXSwgdHVuZWRNb2RlbEZyb21WZXJ0ZXgoZnJvbVR1bmVkTW9kZWwpKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVByZVR1bmVkTW9kZWwgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdwcmVUdW5lZE1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVByZVR1bmVkTW9kZWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwcmVUdW5lZE1vZGVsJ10sIGZyb21QcmVUdW5lZE1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbVN1cGVydmlzZWRUdW5pbmdTcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnc3VwZXJ2aXNlZFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYyddLCBmcm9tU3VwZXJ2aXNlZFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVHVuaW5nRGF0YVN0YXRzID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndHVuaW5nRGF0YVN0YXRzJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbVR1bmluZ0RhdGFTdGF0cyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3R1bmluZ0RhdGFTdGF0cyddLCBmcm9tVHVuaW5nRGF0YVN0YXRzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVuY3J5cHRpb25TcGVjID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnZW5jcnlwdGlvblNwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tRW5jcnlwdGlvblNwZWMgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydlbmNyeXB0aW9uU3BlYyddLCBmcm9tRW5jcnlwdGlvblNwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3BhcnRuZXJNb2RlbFR1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tUGFydG5lck1vZGVsVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3BhcnRuZXJNb2RlbFR1bmluZ1NwZWMnXSwgZnJvbVBhcnRuZXJNb2RlbFR1bmluZ1NwZWMpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tQ3VzdG9tQmFzZU1vZGVsID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAnY3VzdG9tQmFzZU1vZGVsJyxcbiAgICBdKTtcbiAgICBpZiAoZnJvbUN1c3RvbUJhc2VNb2RlbCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2N1c3RvbUJhc2VNb2RlbCddLCBmcm9tQ3VzdG9tQmFzZU1vZGVsKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUV4cGVyaW1lbnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2V4cGVyaW1lbnQnXSk7XG4gICAgaWYgKGZyb21FeHBlcmltZW50ICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXhwZXJpbWVudCddLCBmcm9tRXhwZXJpbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21MYWJlbHMgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2xhYmVscyddKTtcbiAgICBpZiAoZnJvbUxhYmVscyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ2xhYmVscyddLCBmcm9tTGFiZWxzKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbU91dHB1dFVyaSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnb3V0cHV0VXJpJ10pO1xuICAgIGlmIChmcm9tT3V0cHV0VXJpICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnb3V0cHV0VXJpJ10sIGZyb21PdXRwdXRVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tUGlwZWxpbmVKb2IgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ3BpcGVsaW5lSm9iJ10pO1xuICAgIGlmIChmcm9tUGlwZWxpbmVKb2IgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydwaXBlbGluZUpvYiddLCBmcm9tUGlwZWxpbmVKb2IpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tU2VydmljZUFjY291bnQgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICdzZXJ2aWNlQWNjb3VudCcsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZXJ2aWNlQWNjb3VudCAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3NlcnZpY2VBY2NvdW50J10sIGZyb21TZXJ2aWNlQWNjb3VudCk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbXG4gICAgICAgICd0dW5lZE1vZGVsRGlzcGxheU5hbWUnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVHVuZWRNb2RlbERpc3BsYXlOYW1lICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsndHVuZWRNb2RlbERpc3BsYXlOYW1lJ10sIGZyb21UdW5lZE1vZGVsRGlzcGxheU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVvVHVuaW5nU3BlYyA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Zlb1R1bmluZ1NwZWMnLFxuICAgIF0pO1xuICAgIGlmIChmcm9tVmVvVHVuaW5nU3BlYyAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3Zlb1R1bmluZ1NwZWMnXSwgZnJvbVZlb1R1bmluZ1NwZWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9PYmplY3Q7XG59XG5mdW5jdGlvbiB0dW5pbmdPcGVyYXRpb25Gcm9tTWxkZXYoZnJvbU9iamVjdCkge1xuICAgIGNvbnN0IHRvT2JqZWN0ID0ge307XG4gICAgY29uc3QgZnJvbVNka0h0dHBSZXNwb25zZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFtcbiAgICAgICAgJ3Nka0h0dHBSZXNwb25zZScsXG4gICAgXSk7XG4gICAgaWYgKGZyb21TZGtIdHRwUmVzcG9uc2UgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydzZGtIdHRwUmVzcG9uc2UnXSwgZnJvbVNka0h0dHBSZXNwb25zZSk7XG4gICAgfVxuICAgIGNvbnN0IGZyb21OYW1lID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWyduYW1lJ10pO1xuICAgIGlmIChmcm9tTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ25hbWUnXSwgZnJvbU5hbWUpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tTWV0YWRhdGEgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ21ldGFkYXRhJ10pO1xuICAgIGlmIChmcm9tTWV0YWRhdGEgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydtZXRhZGF0YSddLCBmcm9tTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tRG9uZSA9IGdldFZhbHVlQnlQYXRoKGZyb21PYmplY3QsIFsnZG9uZSddKTtcbiAgICBpZiAoZnJvbURvbmUgIT0gbnVsbCkge1xuICAgICAgICBzZXRWYWx1ZUJ5UGF0aCh0b09iamVjdCwgWydkb25lJ10sIGZyb21Eb25lKTtcbiAgICB9XG4gICAgY29uc3QgZnJvbUVycm9yID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgWydlcnJvciddKTtcbiAgICBpZiAoZnJvbUVycm9yICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVCeVBhdGgodG9PYmplY3QsIFsnZXJyb3InXSwgZnJvbUVycm9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqZWN0O1xufVxuZnVuY3Rpb24gdHVuaW5nVmFsaWRhdGlvbkRhdGFzZXRUb1ZlcnRleChmcm9tT2JqZWN0LCBwYXJlbnRPYmplY3QpIHtcbiAgICBjb25zdCB0b09iamVjdCA9IHt9O1xuICAgIGNvbnN0IGZyb21HY3NVcmkgPSBnZXRWYWx1ZUJ5UGF0aChmcm9tT2JqZWN0LCBbJ2djc1VyaSddKTtcbiAgICBpZiAoZnJvbUdjc1VyaSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHRvT2JqZWN0LCBbJ3ZhbGlkYXRpb25EYXRhc2V0VXJpJ10sIGZyb21HY3NVcmkpO1xuICAgIH1cbiAgICBjb25zdCBmcm9tVmVydGV4RGF0YXNldFJlc291cmNlID0gZ2V0VmFsdWVCeVBhdGgoZnJvbU9iamVjdCwgW1xuICAgICAgICAndmVydGV4RGF0YXNldFJlc291cmNlJyxcbiAgICBdKTtcbiAgICBpZiAocGFyZW50T2JqZWN0ICE9PSB1bmRlZmluZWQgJiYgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlQnlQYXRoKHBhcmVudE9iamVjdCwgWydzdXBlcnZpc2VkVHVuaW5nU3BlYycsICd0cmFpbmluZ0RhdGFzZXRVcmknXSwgZnJvbVZlcnRleERhdGFzZXRSZXNvdXJjZSk7XG4gICAgfVxuICAgIHJldHVybiB0b09iamVjdDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjUgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY2xhc3MgVHVuaW5ncyBleHRlbmRzIEJhc2VNb2R1bGUge1xuICAgIGNvbnN0cnVjdG9yKGFwaUNsaWVudCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IGFwaUNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldHMgYSBUdW5pbmdKb2IuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIHJlc291cmNlIG5hbWUgb2YgdGhlIHR1bmluZyBqb2IuXG4gICAgICAgICAqIEByZXR1cm4gLSBBIFR1bmluZ0pvYiBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleHBlcmltZW50YWwgLSBUaGUgU0RLJ3MgdHVuaW5nIGltcGxlbWVudGF0aW9uIGlzIGV4cGVyaW1lbnRhbCwgYW5kIG1heVxuICAgICAgICAgKiBjaGFuZ2UgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXQgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXRJbnRlcm5hbChwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTGlzdHMgdHVuaW5nIGpvYnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGxpc3QgcmVxdWVzdC5cbiAgICAgICAgICogQHJldHVybiAtIEEgbGlzdCBvZiB0dW5pbmcgam9icy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpc3QgPSBhc3luYyAocGFyYW1zID0ge30pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUGFnZXIoUGFnZWRJdGVtLlBBR0VEX0lURU1fVFVOSU5HX0pPQlMsICh4KSA9PiB0aGlzLmxpc3RJbnRlcm5hbCh4KSwgYXdhaXQgdGhpcy5saXN0SW50ZXJuYWwocGFyYW1zKSwgcGFyYW1zKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBzdXBlcnZpc2VkIGZpbmUtdHVuaW5nIGpvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgdHVuaW5nIGpvYi5cbiAgICAgICAgICogQHJldHVybiAtIEEgVHVuaW5nSm9iIG9wZXJhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4cGVyaW1lbnRhbCAtIFRoZSBTREsncyB0dW5pbmcgaW1wbGVtZW50YXRpb24gaXMgZXhwZXJpbWVudGFsLCBhbmQgbWF5XG4gICAgICAgICAqIGNoYW5nZSBpbiBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnR1bmUgPSBhc3luYyAocGFyYW1zKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5iYXNlTW9kZWwuc3RhcnRzV2l0aCgncHJvamVjdHMvJykpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlVHVuZWRNb2RlbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR1bmVkTW9kZWxOYW1lOiBwYXJhbXMuYmFzZU1vZGVsLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnByZVR1bmVkTW9kZWxDaGVja3BvaW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZVR1bmVkTW9kZWwuY2hlY2twb2ludElkID0gcGFyYW1zLmNvbmZpZy5wcmVUdW5lZE1vZGVsQ2hlY2twb2ludElkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgcHJlVHVuZWRNb2RlbDogcHJlVHVuZWRNb2RlbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zUHJpdmF0ZS5iYXNlTW9kZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnR1bmVJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtc1ByaXZhdGUgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50dW5lSW50ZXJuYWwocGFyYW1zUHJpdmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zUHJpdmF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0gYXdhaXQgdGhpcy50dW5lTWxkZXZJbnRlcm5hbChwYXJhbXNQcml2YXRlKTtcbiAgICAgICAgICAgICAgICBsZXQgdHVuZWRNb2RlbE5hbWUgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAob3BlcmF0aW9uWydtZXRhZGF0YSddICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uWydtZXRhZGF0YSddWyd0dW5lZE1vZGVsJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbWV0YWRhdGEnXVsndHVuZWRNb2RlbCddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb25bJ25hbWUnXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvblsnbmFtZSddLmluY2x1ZGVzKCcvb3BlcmF0aW9ucy8nKSkge1xuICAgICAgICAgICAgICAgICAgICB0dW5lZE1vZGVsTmFtZSA9IG9wZXJhdGlvblsnbmFtZSddLnNwbGl0KCcvb3BlcmF0aW9ucy8nKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdHVuaW5nSm9iID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0dW5lZE1vZGVsTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6IEpvYlN0YXRlLkpPQl9TVEFURV9RVUVVRUQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHVuaW5nSm9iO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBnZXRJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX0nLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHR1bmluZ0pvYkZyb21WZXJ0ZXgoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gZ2V0VHVuaW5nSm9iUGFyYW1ldGVyc1RvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3tuYW1lfScsIGJvZHlbJ191cmwnXSk7XG4gICAgICAgICAgICBxdWVyeVBhcmFtcyA9IGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ191cmwnXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gdGhpcy5hcGlDbGllbnRcbiAgICAgICAgICAgICAgICAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYyA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9kID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nSm9iRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZFJlc3AgPSBuZXcgTGlzdFR1bmluZ0pvYnNSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odHlwZWRSZXNwLCByZXNwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZWRSZXNwO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gbGlzdFR1bmluZ0pvYnNQYXJhbWV0ZXJzVG9NbGRldihwYXJhbXMpO1xuICAgICAgICAgICAgcGF0aCA9IGZvcm1hdE1hcCgndHVuZWRNb2RlbHMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwUmVzcG9uc2UuanNvbigpLnRoZW4oKGpzb25SZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGpzb25SZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2Uuc2RrSHR0cFJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaHR0cFJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRoZW4oKGFwaVJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IGxpc3RUdW5pbmdKb2JzUmVzcG9uc2VGcm9tTWxkZXYoYXBpUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVkUmVzcCA9IG5ldyBMaXN0VHVuaW5nSm9ic1Jlc3BvbnNlKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0eXBlZFJlc3AsIHJlc3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlZFJlc3A7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgdHVuaW5nIGpvYi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhlIGNhbmNlbCByZXF1ZXN0LlxuICAgICAqIEByZXR1cm4gVGhlIGVtcHR5IHJlc3BvbnNlIHJldHVybmVkIGJ5IHRoZSBBUEkuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzXG4gICAgICogYXdhaXQgYWkudHVuaW5ncy5jYW5jZWwoe25hbWU6ICcuLi4nfSk7IC8vIFRoZSBzZXJ2ZXItZ2VuZXJhdGVkIHJlc291cmNlIG5hbWUuXG4gICAgICogYGBgXG4gICAgICovXG4gICAgYXN5bmMgY2FuY2VsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICBjb25zdCBib2R5ID0gY2FuY2VsVHVuaW5nSm9iUGFyYW1ldGVyc1RvVmVydGV4KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2EgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfYiA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNhbmNlbFR1bmluZ0pvYlBhcmFtZXRlcnNUb01sZGV2KHBhcmFtcyk7XG4gICAgICAgICAgICBwYXRoID0gZm9ybWF0TWFwKCd7bmFtZX06Y2FuY2VsJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5hcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtczogcXVlcnlQYXJhbXMsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGh0dHBPcHRpb25zOiAoX2MgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWw6IChfZCA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVJbnRlcm5hbChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuICAgICAgICBsZXQgcGF0aCA9ICcnO1xuICAgICAgICBsZXQgcXVlcnlQYXJhbXMgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYXBpQ2xpZW50LmlzVmVydGV4QUkoKSkge1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGNyZWF0ZVR1bmluZ0pvYlBhcmFtZXRlcnNQcml2YXRlVG9WZXJ0ZXgocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmluZ0pvYnMnLCBib2R5WydfdXJsJ10pO1xuICAgICAgICAgICAgcXVlcnlQYXJhbXMgPSBib2R5WydfcXVlcnknXTtcbiAgICAgICAgICAgIGRlbGV0ZSBib2R5WydfdXJsJ107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICByZXNwb25zZSA9IHRoaXMuYXBpQ2xpZW50XG4gICAgICAgICAgICAgICAgLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXM6IHF1ZXJ5UGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczogKF9hID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBPcHRpb25zLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsOiAoX2IgPSBwYXJhbXMuY29uZmlnKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChodHRwUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaHR0cFJlc3BvbnNlLmpzb24oKS50aGVuKChqc29uUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBqc29uUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnNka0h0dHBSZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGh0dHBSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS50aGVuKChhcGlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3AgPSB0dW5pbmdKb2JGcm9tVmVydGV4KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG1ldGhvZCBpcyBvbmx5IHN1cHBvcnRlZCBieSB0aGUgVmVydGV4IEFJLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHR1bmVNbGRldkludGVybmFsKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGxldCBwYXRoID0gJyc7XG4gICAgICAgIGxldCBxdWVyeVBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodGhpcy5hcGlDbGllbnQuaXNWZXJ0ZXhBSSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbWV0aG9kIGlzIG9ubHkgc3VwcG9ydGVkIGJ5IHRoZSBHZW1pbmkgRGV2ZWxvcGVyIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBjcmVhdGVUdW5pbmdKb2JQYXJhbWV0ZXJzUHJpdmF0ZVRvTWxkZXYocGFyYW1zKTtcbiAgICAgICAgICAgIHBhdGggPSBmb3JtYXRNYXAoJ3R1bmVkTW9kZWxzJywgYm9keVsnX3VybCddKTtcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zID0gYm9keVsnX3F1ZXJ5J107XG4gICAgICAgICAgICBkZWxldGUgYm9keVsnX3VybCddO1xuICAgICAgICAgICAgZGVsZXRlIGJvZHlbJ19xdWVyeSddO1xuICAgICAgICAgICAgcmVzcG9uc2UgPSB0aGlzLmFwaUNsaWVudFxuICAgICAgICAgICAgICAgIC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBxdWVyeVBhcmFtcyxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICAgICAgICAgICAgICBodHRwTWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IChfYSA9IHBhcmFtcy5jb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5odHRwT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbDogKF9iID0gcGFyYW1zLmNvbmZpZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFib3J0U2lnbmFsLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoaHR0cFJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGh0dHBSZXNwb25zZS5qc29uKCkudGhlbigoanNvblJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ganNvblJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5zZGtIdHRwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBodHRwUmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGhlbigoYXBpUmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwID0gdHVuaW5nT3BlcmF0aW9uRnJvbU1sZGV2KGFwaVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBNQVhfQ0hVTktfU0laRSA9IDEwMjQgKiAxMDI0ICogODsgLy8gYnl0ZXNcbmNvbnN0IE1BWF9SRVRSWV9DT1VOVCA9IDM7XG5jb25zdCBJTklUSUFMX1JFVFJZX0RFTEFZX01TID0gMTAwMDtcbmNvbnN0IERFTEFZX01VTFRJUExJRVIgPSAyO1xuY29uc3QgWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEID0gJ3gtZ29vZy11cGxvYWQtc3RhdHVzJztcbmFzeW5jIGZ1bmN0aW9uIHVwbG9hZEJsb2IoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBsZXQgZmlsZVNpemUgPSAwO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCByZXNwb25zZSA9IG5ldyBIdHRwUmVzcG9uc2UobmV3IFJlc3BvbnNlKCkpO1xuICAgIGxldCB1cGxvYWRDb21tYW5kID0gJ3VwbG9hZCc7XG4gICAgZmlsZVNpemUgPSBmaWxlLnNpemU7XG4gICAgd2hpbGUgKG9mZnNldCA8IGZpbGVTaXplKSB7XG4gICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShvZmZzZXQsIG9mZnNldCArIGNodW5rU2l6ZSk7XG4gICAgICAgIGlmIChvZmZzZXQgKyBjaHVua1NpemUgPj0gZmlsZVNpemUpIHtcbiAgICAgICAgICAgIHVwbG9hZENvbW1hbmQgKz0gJywgZmluYWxpemUnO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeUNvdW50ID0gMDtcbiAgICAgICAgbGV0IGN1cnJlbnREZWxheU1zID0gSU5JVElBTF9SRVRSWV9ERUxBWV9NUztcbiAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgIHJlc3BvbnNlID0gYXdhaXQgYXBpQ2xpZW50LnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHBhdGg6ICcnLFxuICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgIGh0dHBNZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBodHRwT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYmFzZVVybDogdXBsb2FkVXJsLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICdYLUdvb2ctVXBsb2FkLU9mZnNldCc6IFN0cmluZyhvZmZzZXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogU3RyaW5nKGNodW5rU2l6ZSksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgYXdhaXQgc2xlZXAoY3VycmVudERlbGF5TXMpO1xuICAgICAgICAgICAgY3VycmVudERlbGF5TXMgPSBjdXJyZW50RGVsYXlNcyAqIERFTEFZX01VTFRJUExJRVI7XG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgLy8gVGhlIGB4LWdvb2ctdXBsb2FkLXN0YXR1c2AgaGVhZGVyIGZpZWxkIGNhbiBiZSBgYWN0aXZlYCwgYGZpbmFsYCBhbmRcbiAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgaWYgKCgoX2IgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnYWN0aXZlJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyhiLzQwMTM5MTQzMCkgSW52ZXN0aWdhdGUgd2h5IHRoZSB1cGxvYWQgc3RhdHVzIGlzIG5vdCBmaW5hbGl6ZWRcbiAgICAgICAgLy8gZXZlbiB0aG91Z2ggYWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQuXG4gICAgICAgIGlmIChmaWxlU2l6ZSA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgIGlmICgoKF9jID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmhlYWRlcnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tYX0dPT0dfVVBMT0FEX1NUQVRVU19IRUFERVJfRklFTERdKSAhPT0gJ2ZpbmFsJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byB1cGxvYWQgZmlsZTogVXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2VKc29uWydmaWxlJ107XG59XG5hc3luYyBmdW5jdGlvbiBnZXRCbG9iU3RhdChmaWxlKSB7XG4gICAgY29uc3QgZmlsZVN0YXQgPSB7IHNpemU6IGZpbGUuc2l6ZSwgdHlwZTogZmlsZS50eXBlIH07XG4gICAgcmV0dXJuIGZpbGVTdGF0O1xufVxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmVQcm9taXNlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmVQcm9taXNlLCBtcykpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyNSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jbGFzcyBOb2RlVXBsb2FkZXIge1xuICAgIGFzeW5jIHN0YXQoZmlsZSkge1xuICAgICAgICBjb25zdCBmaWxlU3RhdCA9IHsgc2l6ZTogMCwgdHlwZTogdW5kZWZpbmVkIH07XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU3RhdCA9IGF3YWl0IGZzLnN0YXQoZmlsZSk7XG4gICAgICAgICAgICBmaWxlU3RhdC5zaXplID0gb3JpZ2luYWxTdGF0LnNpemU7XG4gICAgICAgICAgICBmaWxlU3RhdC50eXBlID0gdGhpcy5pbmZlck1pbWVUeXBlKGZpbGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVTdGF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGdldEJsb2JTdGF0KGZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHVwbG9hZChmaWxlLCB1cGxvYWRVcmwsIGFwaUNsaWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGZpbGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy51cGxvYWRGaWxlRnJvbVBhdGgoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVwbG9hZEJsb2IoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluZmVycyB0aGUgTUlNRSB0eXBlIG9mIGEgZmlsZSBiYXNlZCBvbiBpdHMgZXh0ZW5zaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZpbGVQYXRoIFRoZSBwYXRoIHRvIHRoZSBmaWxlLlxuICAgICAqIEByZXR1cm5zIFRoZSBNSU1FIHR5cGUgb2YgdGhlIGZpbGUsIG9yIHVuZGVmaW5lZCBpZiBpdCBjYW5ub3QgYmUgaW5mZXJyZWQuXG4gICAgICovXG4gICAgaW5mZXJNaW1lVHlwZShmaWxlUGF0aCkge1xuICAgICAgICAvLyBHZXQgdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9uID0gZmlsZVBhdGguc2xpY2UoZmlsZVBhdGgubGFzdEluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgICAvLyBDcmVhdGUgYSBtYXAgb2YgZmlsZSBleHRlbnNpb25zIHRvIE1JTUUgdHlwZXMuXG4gICAgICAgIGNvbnN0IG1pbWVUeXBlcyA9IHtcbiAgICAgICAgICAgICdhYWMnOiAnYXVkaW8vYWFjJyxcbiAgICAgICAgICAgICdhYncnOiAnYXBwbGljYXRpb24veC1hYml3b3JkJyxcbiAgICAgICAgICAgICdhcmMnOiAnYXBwbGljYXRpb24veC1mcmVlYXJjJyxcbiAgICAgICAgICAgICdhdmknOiAndmlkZW8veC1tc3ZpZGVvJyxcbiAgICAgICAgICAgICdhencnOiAnYXBwbGljYXRpb24vdm5kLmFtYXpvbi5lYm9vaycsXG4gICAgICAgICAgICAnYmluJzogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScsXG4gICAgICAgICAgICAnYm1wJzogJ2ltYWdlL2JtcCcsXG4gICAgICAgICAgICAnYnonOiAnYXBwbGljYXRpb24veC1iemlwJyxcbiAgICAgICAgICAgICdiejInOiAnYXBwbGljYXRpb24veC1iemlwMicsXG4gICAgICAgICAgICAnY3NoJzogJ2FwcGxpY2F0aW9uL3gtY3NoJyxcbiAgICAgICAgICAgICdjc3MnOiAndGV4dC9jc3MnLFxuICAgICAgICAgICAgJ2Nzdic6ICd0ZXh0L2NzdicsXG4gICAgICAgICAgICAnZG9jJzogJ2FwcGxpY2F0aW9uL21zd29yZCcsXG4gICAgICAgICAgICAnZG9jeCc6ICdhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5kb2N1bWVudCcsXG4gICAgICAgICAgICAnZW90JzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1mb250b2JqZWN0JyxcbiAgICAgICAgICAgICdlcHViJzogJ2FwcGxpY2F0aW9uL2VwdWIremlwJyxcbiAgICAgICAgICAgICdneic6ICdhcHBsaWNhdGlvbi9nemlwJyxcbiAgICAgICAgICAgICdnaWYnOiAnaW1hZ2UvZ2lmJyxcbiAgICAgICAgICAgICdodG0nOiAndGV4dC9odG1sJyxcbiAgICAgICAgICAgICdodG1sJzogJ3RleHQvaHRtbCcsXG4gICAgICAgICAgICAnaWNvJzogJ2ltYWdlL3ZuZC5taWNyb3NvZnQuaWNvbicsXG4gICAgICAgICAgICAnaWNzJzogJ3RleHQvY2FsZW5kYXInLFxuICAgICAgICAgICAgJ2phcic6ICdhcHBsaWNhdGlvbi9qYXZhLWFyY2hpdmUnLFxuICAgICAgICAgICAgJ2pwZWcnOiAnaW1hZ2UvanBlZycsXG4gICAgICAgICAgICAnanBnJzogJ2ltYWdlL2pwZWcnLFxuICAgICAgICAgICAgJ2pzJzogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnanNvbic6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICdqc29ubGQnOiAnYXBwbGljYXRpb24vbGQranNvbicsXG4gICAgICAgICAgICAna21sJzogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua21sK3htbCcsXG4gICAgICAgICAgICAna216JzogJ2FwcGxpY2F0aW9uL3ZuZC5nb29nbGUtZWFydGgua216K3htbCcsXG4gICAgICAgICAgICAnbWpzJzogJ3RleHQvamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnbXAzJzogJ2F1ZGlvL21wZWcnLFxuICAgICAgICAgICAgJ21wNCc6ICd2aWRlby9tcDQnLFxuICAgICAgICAgICAgJ21wZWcnOiAndmlkZW8vbXBlZycsXG4gICAgICAgICAgICAnbXBrZyc6ICdhcHBsaWNhdGlvbi92bmQuYXBwbGUuaW5zdGFsbGVyK3htbCcsXG4gICAgICAgICAgICAnb2R0JzogJ2FwcGxpY2F0aW9uL3ZuZC5vYXNpcy5vcGVuZG9jdW1lbnQudGV4dCcsXG4gICAgICAgICAgICAnb2dhJzogJ2F1ZGlvL29nZycsXG4gICAgICAgICAgICAnb2d2JzogJ3ZpZGVvL29nZycsXG4gICAgICAgICAgICAnb2d4JzogJ2FwcGxpY2F0aW9uL29nZycsXG4gICAgICAgICAgICAnb3B1cyc6ICdhdWRpby9vcHVzJyxcbiAgICAgICAgICAgICdvdGYnOiAnZm9udC9vdGYnLFxuICAgICAgICAgICAgJ3BuZyc6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgJ3BkZic6ICdhcHBsaWNhdGlvbi9wZGYnLFxuICAgICAgICAgICAgJ3BocCc6ICdhcHBsaWNhdGlvbi94LWh0dHBkLXBocCcsXG4gICAgICAgICAgICAncHB0JzogJ2FwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50JyxcbiAgICAgICAgICAgICdwcHR4JzogJ2FwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5wcmVzZW50YXRpb24nLFxuICAgICAgICAgICAgJ3Jhcic6ICdhcHBsaWNhdGlvbi92bmQucmFyJyxcbiAgICAgICAgICAgICdydGYnOiAnYXBwbGljYXRpb24vcnRmJyxcbiAgICAgICAgICAgICdzaCc6ICdhcHBsaWNhdGlvbi94LXNoJyxcbiAgICAgICAgICAgICdzdmcnOiAnaW1hZ2Uvc3ZnK3htbCcsXG4gICAgICAgICAgICAnc3dmJzogJ2FwcGxpY2F0aW9uL3gtc2hvY2t3YXZlLWZsYXNoJyxcbiAgICAgICAgICAgICd0YXInOiAnYXBwbGljYXRpb24veC10YXInLFxuICAgICAgICAgICAgJ3RpZic6ICdpbWFnZS90aWZmJyxcbiAgICAgICAgICAgICd0aWZmJzogJ2ltYWdlL3RpZmYnLFxuICAgICAgICAgICAgJ3RzJzogJ3ZpZGVvL21wMnQnLFxuICAgICAgICAgICAgJ3R0Zic6ICdmb250L3R0ZicsXG4gICAgICAgICAgICAndHh0JzogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgICAgJ3ZzZCc6ICdhcHBsaWNhdGlvbi92bmQudmlzaW8nLFxuICAgICAgICAgICAgJ3dhdic6ICdhdWRpby93YXYnLFxuICAgICAgICAgICAgJ3dlYmEnOiAnYXVkaW8vd2VibScsXG4gICAgICAgICAgICAnd2VibSc6ICd2aWRlby93ZWJtJyxcbiAgICAgICAgICAgICd3ZWJwJzogJ2ltYWdlL3dlYnAnLFxuICAgICAgICAgICAgJ3dvZmYnOiAnZm9udC93b2ZmJyxcbiAgICAgICAgICAgICd3b2ZmMic6ICdmb250L3dvZmYyJyxcbiAgICAgICAgICAgICd4aHRtbCc6ICdhcHBsaWNhdGlvbi94aHRtbCt4bWwnLFxuICAgICAgICAgICAgJ3hscyc6ICdhcHBsaWNhdGlvbi92bmQubXMtZXhjZWwnLFxuICAgICAgICAgICAgJ3hsc3gnOiAnYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuc2hlZXQnLFxuICAgICAgICAgICAgJ3htbCc6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgICAgICAgICAgJ3h1bCc6ICdhcHBsaWNhdGlvbi92bmQubW96aWxsYS54dWwreG1sJyxcbiAgICAgICAgICAgICd6aXAnOiAnYXBwbGljYXRpb24vemlwJyxcbiAgICAgICAgICAgICczZ3AnOiAndmlkZW8vM2dwcCcsXG4gICAgICAgICAgICAnM2cyJzogJ3ZpZGVvLzNncHAyJyxcbiAgICAgICAgICAgICc3eic6ICdhcHBsaWNhdGlvbi94LTd6LWNvbXByZXNzZWQnLFxuICAgICAgICB9O1xuICAgICAgICAvLyBMb29rIHVwIHRoZSBNSU1FIHR5cGUgYmFzZWQgb24gdGhlIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IG1pbWVUeXBlc1tmaWxlRXh0ZW5zaW9uLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAvLyBSZXR1cm4gdGhlIE1JTUUgdHlwZS5cbiAgICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgICBhc3luYyB1cGxvYWRGaWxlRnJvbVBhdGgoZmlsZSwgdXBsb2FkVXJsLCBhcGlDbGllbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGxldCBmaWxlU2l6ZSA9IDA7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgcmVzcG9uc2UgPSBuZXcgSHR0cFJlc3BvbnNlKG5ldyBSZXNwb25zZSgpKTtcbiAgICAgICAgbGV0IHVwbG9hZENvbW1hbmQgPSAndXBsb2FkJztcbiAgICAgICAgbGV0IGZpbGVIYW5kbGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaWxlSGFuZGxlID0gYXdhaXQgZnMub3BlbihmaWxlLCAncicpO1xuICAgICAgICAgICAgaWYgKCFmaWxlSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gb3BlbiBmaWxlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWxlU2l6ZSA9IChhd2FpdCBmaWxlSGFuZGxlLnN0YXQoKSkuc2l6ZTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZzZXQgPCBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKE1BWF9DSFVOS19TSVpFLCBmaWxlU2l6ZSAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKG9mZnNldCArIGNodW5rU2l6ZSA+PSBmaWxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB1cGxvYWRDb21tYW5kICs9ICcsIGZpbmFsaXplJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmtTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJ5dGVzUmVhZDogYnl0ZXNSZWFkIH0gPSBhd2FpdCBmaWxlSGFuZGxlLnJlYWQoYnVmZmVyLCAwLCBjaHVua1NpemUsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGVzUmVhZCAhPT0gY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHJlYWQgJHtjaHVua1NpemV9IGJ5dGVzIGZyb20gZmlsZSBhdCBvZmZzZXQgJHtvZmZzZXR9LiBieXRlcyBhY3R1YWxseSByZWFkOiAke2J5dGVzUmVhZH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBuZXcgQmxvYihbYnVmZmVyXSk7XG4gICAgICAgICAgICAgICAgbGV0IHJldHJ5Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGVsYXlNcyA9IElOSVRJQUxfUkVUUllfREVMQVlfTVM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJldHJ5Q291bnQgPCBNQVhfUkVUUllfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBhd2FpdCBhcGlDbGllbnQucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaHR0cE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGlWZXJzaW9uOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlVXJsOiB1cGxvYWRVcmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnWC1Hb29nLVVwbG9hZC1Db21tYW5kJzogdXBsb2FkQ29tbWFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1gtR29vZy1VcGxvYWQtT2Zmc2V0JzogU3RyaW5nKG9mZnNldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IFN0cmluZyhieXRlc1JlYWQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzbGVlcChjdXJyZW50RGVsYXlNcyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnREZWxheU1zID0gY3VycmVudERlbGF5TXMgKiBERUxBWV9NVUxUSVBMSUVSO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gYnl0ZXNSZWFkO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgeC1nb29nLXVwbG9hZC1zdGF0dXNgIGhlYWRlciBmaWVsZCBjYW4gYmUgYGFjdGl2ZWAsIGBmaW5hbGAgYW5kXG4gICAgICAgICAgICAgICAgLy9gY2FuY2VsbGVkYCBpbiByZXNwb3NuZS5cbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5oZWFkZXJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbWF9HT09HX1VQTE9BRF9TVEFUVVNfSEVBREVSX0ZJRUxEXSkgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmlsZVNpemUgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQWxsIGNvbnRlbnQgaGFzIGJlZW4gdXBsb2FkZWQsIGJ1dCB0aGUgdXBsb2FkIHN0YXR1cyBpcyBub3QgZmluYWxpemVkLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IChhd2FpdCAocmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmpzb24oKSkpO1xuICAgICAgICAgICAgaWYgKCgoX2MgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UuaGVhZGVycykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jW1hfR09PR19VUExPQURfU1RBVFVTX0hFQURFUl9GSUVMRF0pICE9PSAnZmluYWwnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGU6IFVwbG9hZCBzdGF0dXMgaXMgbm90IGZpbmFsaXplZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZUpzb25bJ2ZpbGUnXTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZmlsZSBoYW5kbGUgaXMgYWx3YXlzIGNsb3NlZFxuICAgICAgICAgICAgaWYgKGZpbGVIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBmaWxlSGFuZGxlLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDI1IEdvb2dsZSBMTENcbiAqIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG4gKi9cbmNvbnN0IExBTkdVQUdFX0xBQkVMX1BSRUZJWCA9ICdnbC1ub2RlLyc7XG4vKipcbiAqIFRoZSBHb29nbGUgR2VuQUkgU0RLLlxuICpcbiAqIEByZW1hcmtzXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gdGhlIEdlbkFJIGZlYXR1cmVzIHRocm91Z2ggZWl0aGVyIHRoZSB7QGxpbmtcbiAqIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IEdlbWluaSBBUEl9IG9yXG4gKiB0aGUge0BsaW5rIGh0dHBzOi8vY2xvdWQuZ29vZ2xlLmNvbS92ZXJ0ZXgtYWkvZG9jcy9yZWZlcmVuY2UvcmVzdCB8IFZlcnRleCBBSVxuICogQVBJfS5cbiAqXG4gKiBUaGUge0BsaW5rIEdvb2dsZUdlbkFJT3B0aW9ucy52ZXJ0ZXhhaX0gdmFsdWUgZGV0ZXJtaW5lcyB3aGljaCBvZiB0aGUgQVBJXG4gKiBzZXJ2aWNlcyB0byB1c2UuXG4gKlxuICogV2hlbiB1c2luZyB0aGUgR2VtaW5pIEFQSSwgYSB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zLmFwaUtleX0gbXVzdCBhbHNvIGJlXG4gKiBzZXQuIFdoZW4gdXNpbmcgVmVydGV4IEFJLCBib3RoIHtAbGluayBHb29nbGVHZW5BSU9wdGlvbnMucHJvamVjdH0gYW5kIHtAbGlua1xuICogR29vZ2xlR2VuQUlPcHRpb25zLmxvY2F0aW9ufSBtdXN0IGJlIHNldCwgb3IgYSB7QGxpbmtcbiAqIEdvb2dsZUdlbkFJT3B0aW9ucy5hcGlLZXl9IG11c3QgYmUgc2V0IHdoZW4gdXNpbmcgRXhwcmVzcyBNb2RlLlxuICpcbiAqIEV4cGxpY2l0bHkgcGFzc2VkIGluIHZhbHVlcyBpbiB7QGxpbmsgR29vZ2xlR2VuQUlPcHRpb25zfSB3aWxsIGFsd2F5cyB0YWtlXG4gKiBwcmVjZWRlbmNlIG92ZXIgZW52aXJvbm1lbnQgdmFyaWFibGVzLiBJZiBib3RoIHByb2plY3QvbG9jYXRpb24gYW5kIGFwaV9rZXlcbiAqIGV4aXN0IGluIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHRoZSBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogSW5pdGlhbGl6aW5nIHRoZSBTREsgZm9yIHVzaW5nIHRoZSBHZW1pbmkgQVBJOlxuICogYGBgdHNcbiAqIGltcG9ydCB7R29vZ2xlR2VuQUl9IGZyb20gJ0Bnb29nbGUvZ2VuYWknO1xuICogY29uc3QgYWkgPSBuZXcgR29vZ2xlR2VuQUkoe2FwaUtleTogJ0dFTUlOSV9BUElfS0VZJ30pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEluaXRpYWxpemluZyB0aGUgU0RLIGZvciB1c2luZyB0aGUgVmVydGV4IEFJIEFQSTpcbiAqIGBgYHRzXG4gKiBpbXBvcnQge0dvb2dsZUdlbkFJfSBmcm9tICdAZ29vZ2xlL2dlbmFpJztcbiAqIGNvbnN0IGFpID0gbmV3IEdvb2dsZUdlbkFJKHtcbiAqICAgdmVydGV4YWk6IHRydWUsXG4gKiAgIHByb2plY3Q6ICdQUk9KRUNUX0lEJyxcbiAqICAgbG9jYXRpb246ICdQUk9KRUNUX0xPQ0FUSU9OJ1xuICogfSk7XG4gKiBgYGBcbiAqXG4gKi9cbmNsYXNzIEdvb2dsZUdlbkFJIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAvLyBWYWxpZGF0ZSBleHBsaWNpdGx5IHNldCBpbml0aWFsaXplciB2YWx1ZXMuXG4gICAgICAgIGlmICgob3B0aW9ucy5wcm9qZWN0IHx8IG9wdGlvbnMubG9jYXRpb24pICYmIG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3QvbG9jYXRpb24gYW5kIEFQSSBrZXkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBpbiB0aGUgY2xpZW50IGluaXRpYWxpemVyLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmVydGV4YWkgPVxuICAgICAgICAgICAgKF9iID0gKF9hID0gb3B0aW9ucy52ZXJ0ZXhhaSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZ2V0Qm9vbGVhbkVudignR09PR0xFX0dFTkFJX1VTRV9WRVJURVhBSScpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZTtcbiAgICAgICAgY29uc3QgZW52QXBpS2V5ID0gZ2V0QXBpS2V5RnJvbUVudigpO1xuICAgICAgICBjb25zdCBlbnZQcm9qZWN0ID0gZ2V0RW52KCdHT09HTEVfQ0xPVURfUFJPSkVDVCcpO1xuICAgICAgICBjb25zdCBlbnZMb2NhdGlvbiA9IGdldEVudignR09PR0xFX0NMT1VEX0xPQ0FUSU9OJyk7XG4gICAgICAgIHRoaXMuYXBpS2V5ID0gKF9jID0gb3B0aW9ucy5hcGlLZXkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGVudkFwaUtleTtcbiAgICAgICAgdGhpcy5wcm9qZWN0ID0gKF9kID0gb3B0aW9ucy5wcm9qZWN0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBlbnZQcm9qZWN0O1xuICAgICAgICB0aGlzLmxvY2F0aW9uID0gKF9lID0gb3B0aW9ucy5sb2NhdGlvbikgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogZW52TG9jYXRpb247XG4gICAgICAgIC8vIEhhbmRsZSB3aGVuIHRvIHVzZSBWZXJ0ZXggQUkgaW4gZXhwcmVzcyBtb2RlIChhcGkga2V5KVxuICAgICAgICBpZiAob3B0aW9ucy52ZXJ0ZXhhaSkge1xuICAgICAgICAgICAgaWYgKChfZiA9IG9wdGlvbnMuZ29vZ2xlQXV0aE9wdGlvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jcmVkZW50aWFscykge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGNyZWRlbnRpYWxzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IGFwaV9rZXkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgR29vZ2xlIENsb3VkIGNyZWRlbnRpYWxzIHdpbGwgdGFrZSBwcmVjZWRlbmNlJyArXG4gICAgICAgICAgICAgICAgICAgICcgb3ZlciB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZS4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgYW5kIGV4cGxpY2l0IHByb2plY3QvbG9jYXRpb24gYWxyZWFkeSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICAgICAgaWYgKChlbnZQcm9qZWN0IHx8IGVudkxvY2F0aW9uKSAmJiBvcHRpb25zLmFwaUtleSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IGFwaV9rZXkgdGFrZXMgcHJlY2VkZW5jZSBvdmVyIGltcGxpY2l0IHByb2plY3QvbG9jYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc29sZS5kZWJ1ZygnVGhlIHVzZXIgcHJvdmlkZWQgVmVydGV4IEFJIEFQSSBrZXkgd2lsbCB0YWtlIHByZWNlZGVuY2Ugb3ZlcicgK1xuICAgICAgICAgICAgICAgICAgICAnIHRoZSBwcm9qZWN0L2xvY2F0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChvcHRpb25zLnByb2plY3QgfHwgb3B0aW9ucy5sb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhwbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgdXNlciBwcm92aWRlZCBwcm9qZWN0L2xvY2F0aW9uIHdpbGwgdGFrZSBwcmVjZWRlbmNlIG92ZXInICtcbiAgICAgICAgICAgICAgICAgICAgJyB0aGUgQVBJIGtleSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlLZXkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoZW52UHJvamVjdCB8fCBlbnZMb2NhdGlvbikgJiYgZW52QXBpS2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgcHJvamVjdC9sb2NhdGlvbiB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgaW1wbGljaXQgYXBpX2tleS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKCdUaGUgcHJvamVjdC9sb2NhdGlvbiBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgd2lsbCB0YWtlJyArXG4gICAgICAgICAgICAgICAgICAgICcgcHJlY2VkZW5jZSBvdmVyIHRoZSBBUEkga2V5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwaUtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChvcHRpb25zLmh0dHBPcHRpb25zLCBvcHRpb25zLnZlcnRleGFpLCBnZXRFbnYoJ0dPT0dMRV9WRVJURVhfQkFTRV9VUkwnKSwgZ2V0RW52KCdHT09HTEVfR0VNSU5JX0JBU0VfVVJMJykpO1xuICAgICAgICBpZiAoYmFzZVVybCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaHR0cE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmh0dHBPcHRpb25zLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5odHRwT3B0aW9ucyA9IHsgYmFzZVVybDogYmFzZVVybCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXBpVmVyc2lvbiA9IG9wdGlvbnMuYXBpVmVyc2lvbjtcbiAgICAgICAgY29uc3QgYXV0aCA9IG5ldyBOb2RlQXV0aCh7XG4gICAgICAgICAgICBhcGlLZXk6IHRoaXMuYXBpS2V5LFxuICAgICAgICAgICAgZ29vZ2xlQXV0aE9wdGlvbnM6IG9wdGlvbnMuZ29vZ2xlQXV0aE9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBBcGlDbGllbnQoe1xuICAgICAgICAgICAgYXV0aDogYXV0aCxcbiAgICAgICAgICAgIHByb2plY3Q6IHRoaXMucHJvamVjdCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiB0aGlzLmxvY2F0aW9uLFxuICAgICAgICAgICAgYXBpVmVyc2lvbjogdGhpcy5hcGlWZXJzaW9uLFxuICAgICAgICAgICAgYXBpS2V5OiB0aGlzLmFwaUtleSxcbiAgICAgICAgICAgIHZlcnRleGFpOiB0aGlzLnZlcnRleGFpLFxuICAgICAgICAgICAgaHR0cE9wdGlvbnM6IG9wdGlvbnMuaHR0cE9wdGlvbnMsXG4gICAgICAgICAgICB1c2VyQWdlbnRFeHRyYTogTEFOR1VBR0VfTEFCRUxfUFJFRklYICsgcHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgICAgICAgdXBsb2FkZXI6IG5ldyBOb2RlVXBsb2FkZXIoKSxcbiAgICAgICAgICAgIGRvd25sb2FkZXI6IG5ldyBOb2RlRG93bmxvYWRlcigpLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5tb2RlbHMgPSBuZXcgTW9kZWxzKHRoaXMuYXBpQ2xpZW50KTtcbiAgICAgICAgdGhpcy5saXZlID0gbmV3IExpdmUodGhpcy5hcGlDbGllbnQsIGF1dGgsIG5ldyBOb2RlV2ViU29ja2V0RmFjdG9yeSgpKTtcbiAgICAgICAgdGhpcy5iYXRjaGVzID0gbmV3IEJhdGNoZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLmNoYXRzID0gbmV3IENoYXRzKHRoaXMubW9kZWxzLCB0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuY2FjaGVzID0gbmV3IENhY2hlcyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuZmlsZXMgPSBuZXcgRmlsZXModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBuZXcgT3BlcmF0aW9ucyh0aGlzLmFwaUNsaWVudCk7XG4gICAgICAgIHRoaXMuYXV0aFRva2VucyA9IG5ldyBUb2tlbnModGhpcy5hcGlDbGllbnQpO1xuICAgICAgICB0aGlzLnR1bmluZ3MgPSBuZXcgVHVuaW5ncyh0aGlzLmFwaUNsaWVudCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RW52KGVudikge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIHJldHVybiAoX2MgPSAoX2IgPSAoX2EgPSBwcm9jZXNzID09PSBudWxsIHx8IHByb2Nlc3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3MuZW52KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbZW52XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnRyaW0oKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0Qm9vbGVhbkVudihlbnYpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9Cb29sZWFuKGdldEVudihlbnYpKTtcbn1cbmZ1bmN0aW9uIHN0cmluZ1RvQm9vbGVhbihzdHIpIHtcbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbmZ1bmN0aW9uIGdldEFwaUtleUZyb21FbnYoKSB7XG4gICAgY29uc3QgZW52R29vZ2xlQXBpS2V5ID0gZ2V0RW52KCdHT09HTEVfQVBJX0tFWScpO1xuICAgIGNvbnN0IGVudkdlbWluaUFwaUtleSA9IGdldEVudignR0VNSU5JX0FQSV9LRVknKTtcbiAgICBpZiAoZW52R29vZ2xlQXBpS2V5ICYmIGVudkdlbWluaUFwaUtleSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0JvdGggR09PR0xFX0FQSV9LRVkgYW5kIEdFTUlOSV9BUElfS0VZIGFyZSBzZXQuIFVzaW5nIEdPT0dMRV9BUElfS0VZLicpO1xuICAgIH1cbiAgICByZXR1cm4gZW52R29vZ2xlQXBpS2V5IHx8IGVudkdlbWluaUFwaUtleSB8fCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB7IEFjdGl2aXR5SGFuZGxpbmcsIEFkYXB0ZXJTaXplLCBBcGlFcnJvciwgQXBpU3BlYywgQXV0aFR5cGUsIEJhdGNoZXMsIEJlaGF2aW9yLCBCbG9ja2VkUmVhc29uLCBDYWNoZXMsIENoYXQsIENoYXRzLCBDb21wdXRlVG9rZW5zUmVzcG9uc2UsIENvbnRlbnRSZWZlcmVuY2VJbWFnZSwgQ29udHJvbFJlZmVyZW5jZUltYWdlLCBDb250cm9sUmVmZXJlbmNlVHlwZSwgQ291bnRUb2tlbnNSZXNwb25zZSwgQ3JlYXRlRmlsZVJlc3BvbnNlLCBEZWxldGVDYWNoZWRDb250ZW50UmVzcG9uc2UsIERlbGV0ZUZpbGVSZXNwb25zZSwgRGVsZXRlTW9kZWxSZXNwb25zZSwgRHluYW1pY1JldHJpZXZhbENvbmZpZ01vZGUsIEVkaXRJbWFnZVJlc3BvbnNlLCBFZGl0TW9kZSwgRW1iZWRDb250ZW50UmVzcG9uc2UsIEVuZFNlbnNpdGl2aXR5LCBFbnZpcm9ubWVudCwgRmVhdHVyZVNlbGVjdGlvblByZWZlcmVuY2UsIEZpbGVTb3VyY2UsIEZpbGVTdGF0ZSwgRmlsZXMsIEZpbmlzaFJlYXNvbiwgRnVuY3Rpb25DYWxsaW5nQ29uZmlnTW9kZSwgRnVuY3Rpb25SZXNwb25zZSwgRnVuY3Rpb25SZXNwb25zZUJsb2IsIEZ1bmN0aW9uUmVzcG9uc2VGaWxlRGF0YSwgRnVuY3Rpb25SZXNwb25zZVBhcnQsIEZ1bmN0aW9uUmVzcG9uc2VTY2hlZHVsaW5nLCBHZW5lcmF0ZUNvbnRlbnRSZXNwb25zZSwgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VQcm9tcHRGZWVkYmFjaywgR2VuZXJhdGVDb250ZW50UmVzcG9uc2VVc2FnZU1ldGFkYXRhLCBHZW5lcmF0ZUltYWdlc1Jlc3BvbnNlLCBHZW5lcmF0ZVZpZGVvc09wZXJhdGlvbiwgR2VuZXJhdGVWaWRlb3NSZXNwb25zZSwgR29vZ2xlR2VuQUksIEhhcm1CbG9ja01ldGhvZCwgSGFybUJsb2NrVGhyZXNob2xkLCBIYXJtQ2F0ZWdvcnksIEhhcm1Qcm9iYWJpbGl0eSwgSGFybVNldmVyaXR5LCBIdHRwUmVzcG9uc2UsIEltYWdlUHJvbXB0TGFuZ3VhZ2UsIElubGluZWRFbWJlZENvbnRlbnRSZXNwb25zZSwgSW5saW5lZFJlc3BvbnNlLCBKb2JTdGF0ZSwgTGFuZ3VhZ2UsIExpc3RCYXRjaEpvYnNSZXNwb25zZSwgTGlzdENhY2hlZENvbnRlbnRzUmVzcG9uc2UsIExpc3RGaWxlc1Jlc3BvbnNlLCBMaXN0TW9kZWxzUmVzcG9uc2UsIExpc3RUdW5pbmdKb2JzUmVzcG9uc2UsIExpdmUsIExpdmVDbGllbnRUb29sUmVzcG9uc2UsIExpdmVNdXNpY1BsYXliYWNrQ29udHJvbCwgTGl2ZU11c2ljU2VydmVyTWVzc2FnZSwgTGl2ZVNlbmRUb29sUmVzcG9uc2VQYXJhbWV0ZXJzLCBMaXZlU2VydmVyTWVzc2FnZSwgTWFza1JlZmVyZW5jZUltYWdlLCBNYXNrUmVmZXJlbmNlTW9kZSwgTWVkaWFNb2RhbGl0eSwgTWVkaWFSZXNvbHV0aW9uLCBNb2RhbGl0eSwgTW9kZSwgTW9kZWxzLCBNdXNpY0dlbmVyYXRpb25Nb2RlLCBPcGVyYXRpb25zLCBPdXRjb21lLCBQYWdlZEl0ZW0sIFBhZ2VyLCBQZXJzb25HZW5lcmF0aW9uLCBSYXdSZWZlcmVuY2VJbWFnZSwgUmVjb250ZXh0SW1hZ2VSZXNwb25zZSwgUmVwbGF5UmVzcG9uc2UsIFNhZmV0eUZpbHRlckxldmVsLCBTY2FsZSwgU2VnbWVudEltYWdlUmVzcG9uc2UsIFNlZ21lbnRNb2RlLCBTZXNzaW9uLCBTaW5nbGVFbWJlZENvbnRlbnRSZXNwb25zZSwgU3RhcnRTZW5zaXRpdml0eSwgU3R5bGVSZWZlcmVuY2VJbWFnZSwgU3ViamVjdFJlZmVyZW5jZUltYWdlLCBTdWJqZWN0UmVmZXJlbmNlVHlwZSwgVG9rZW5zLCBUcmFmZmljVHlwZSwgVHVuaW5nTW9kZSwgVHVuaW5nVGFzaywgVHVybkNvbXBsZXRlUmVhc29uLCBUdXJuQ292ZXJhZ2UsIFR5cGUsIFVwc2NhbGVJbWFnZVJlc3BvbnNlLCBVcmxSZXRyaWV2YWxTdGF0dXMsIFZpZGVvQ29tcHJlc3Npb25RdWFsaXR5LCBWaWRlb0dlbmVyYXRpb25NYXNrTW9kZSwgVmlkZW9HZW5lcmF0aW9uUmVmZXJlbmNlVHlwZSwgY3JlYXRlTW9kZWxDb250ZW50LCBjcmVhdGVQYXJ0RnJvbUJhc2U2NCwgY3JlYXRlUGFydEZyb21Db2RlRXhlY3V0aW9uUmVzdWx0LCBjcmVhdGVQYXJ0RnJvbUV4ZWN1dGFibGVDb2RlLCBjcmVhdGVQYXJ0RnJvbUZ1bmN0aW9uQ2FsbCwgY3JlYXRlUGFydEZyb21GdW5jdGlvblJlc3BvbnNlLCBjcmVhdGVQYXJ0RnJvbVRleHQsIGNyZWF0ZVBhcnRGcm9tVXJpLCBjcmVhdGVVc2VyQ29udGVudCwgbWNwVG9Ub29sLCBzZXREZWZhdWx0QmFzZVVybHMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@google/genai/dist/node/index.mjs\n");

/***/ })

};
;